=== ./cdk/bin/basketball-review-cdk.js ===
#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const cdk = require("aws-cdk-lib");
const basketball_review_stack_1 = require("../lib/basketball-review-stack");
const app = new cdk.App();
new basketball_review_stack_1.BasketballReviewStack(app, 'BasketballReviewStack', {
    env: {
        account: process.env.CDK_DEFAULT_ACCOUNT,
        region: process.env.CDK_DEFAULT_REGION,
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFza2V0YmFsbC1yZXZpZXctY2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYmFza2V0YmFsbC1yZXZpZXctY2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHVDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkMsNEVBQXVFO0FBRXZFLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQzFCLElBQUksK0NBQXFCLENBQUMsR0FBRyxFQUFFLHVCQUF1QixFQUFFO0lBQ3RELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQjtRQUN4QyxNQUFNLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0I7S0FDdkM7Q0FDRixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG5pbXBvcnQgJ3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3Rlcic7XG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnYXdzLWNkay1saWInO1xuaW1wb3J0IHsgQmFza2V0YmFsbFJldmlld1N0YWNrIH0gZnJvbSAnLi4vbGliL2Jhc2tldGJhbGwtcmV2aWV3LXN0YWNrJztcblxuY29uc3QgYXBwID0gbmV3IGNkay5BcHAoKTtcbm5ldyBCYXNrZXRiYWxsUmV2aWV3U3RhY2soYXBwLCAnQmFza2V0YmFsbFJldmlld1N0YWNrJywge1xuICBlbnY6IHtcbiAgICBhY2NvdW50OiBwcm9jZXNzLmVudi5DREtfREVGQVVMVF9BQ0NPVU5ULFxuICAgIHJlZ2lvbjogcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfUkVHSU9OLFxuICB9LFxufSk7ICJdfQ==


=== ./cdk/bin/basketball-review-cdk.d.ts ===
#!/usr/bin/env node
import 'source-map-support/register';



=== ./cdk/bin/basketball-review-cdk.ts ===
#!/usr/bin/env node
import 'source-map-support/register';
import * as cdk from 'aws-cdk-lib';
import { BasketballReviewStack } from '../lib/basketball-review-stack';

const app = new cdk.App();
new BasketballReviewStack(app, 'BasketballReviewStack', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
}); 


=== ./cdk/cdk.json ===
{
  "app": "npx ts-node --prefer-ts-exts bin/basketball-review-cdk.ts",
  "watch": {
    "include": [
      "**"
    ],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/aws-lambda:recognizeVersionProps": true,
    "@aws-cdk/aws-cloudfront:defaultSecurityPolicyTLSv1.2_2021": true,
    "@aws-cdk/aws-apigateway:usagePlanKeyOrderInsensitiveId": true,
    "@aws-cdk/core:stackRelativeExports": true,
    "@aws-cdk/aws-rds:lowercaseDbIdentifier": true,
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/aws-lambda:recognizeVersionProps": true
  }
} 


=== ./cdk/lambda/players/index.js ===
const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');

// Configure DynamoDB for local development
const dynamoConfig = {
  region: process.env.AWS_REGION || 'ap-southeast-2' // Use your actual region
};

// Use local DynamoDB if running locally
if (process.env.AWS_SAM_LOCAL || process.env.DYNAMODB_ENDPOINT) {
  dynamoConfig.endpoint = process.env.DYNAMODB_ENDPOINT || 'http://dynamodb-local:8000';
}

const dynamodb = new AWS.DynamoDB.DocumentClient(dynamoConfig);

const TABLE_NAME = process.env.TABLE_NAME;

exports.handler = async (event) => {
  console.log('Players function received:', JSON.stringify(event, null, 2));
  
  const { httpMethod, pathParameters, body, headers } = event;
  const corsHeaders = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Org-Id',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
  };

  // Extract organization ID from headers (for multi-tenant SAAS)
  const orgId = headers['X-Org-Id'] || headers['x-org-id'] || 'default';
  
  if (!orgId || orgId === 'undefined') {
    return {
      statusCode: 400,
      headers: corsHeaders,
      body: JSON.stringify({ 
        success: false, 
        error: { message: 'Organization ID required' } 
      })
    };
  }

  try {
    switch (httpMethod) {
      case 'OPTIONS':
        return {
          statusCode: 200,
          headers: corsHeaders,
          body: ''
        };

      case 'GET':
        if (pathParameters && pathParameters.id) {
          // Get single player
          const result = await dynamodb.get({
            TableName: TABLE_NAME,
            Key: {
              PK: `ORG#${orgId}#PLAYER#${pathParameters.id}`,
              SK: `PLAYER#${pathParameters.id}`
            }
          }).promise();
          
          if (!result.Item) {
            return {
              statusCode: 404,
              headers: corsHeaders,
              body: JSON.stringify({ success: false, error: { message: 'Player not found' } })
            };
          }
          
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: result.Item.Data })
          };
        } else {
          // Get all players for organization
          const result = await dynamodb.query({
            TableName: TABLE_NAME,
            IndexName: 'OrgTypeIndex',
            KeyConditionExpression: 'OrgId = :orgId AND #type = :type',
            ExpressionAttributeNames: {
              '#type': 'Type'
            },
            ExpressionAttributeValues: {
              ':orgId': orgId,
              ':type': 'PLAYER'
            }
          }).promise();
          
          const players = result.Items
            .filter(item => item.Data && item.Data.isActive !== false)
            .map(item => item.Data);
            
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: players })
          };
        }

      case 'POST':
        // Create new player
        const playerData = JSON.parse(body);
        const playerId = uuidv4();
        const now = new Date().toISOString();
        
        const newPlayer = {
          id: playerId,
          orgId: orgId,
          name: playerData.name,
          position: playerData.position || null,
          height: playerData.height || null,
          weight: playerData.weight || null,
          jerseyNumber: playerData.jerseyNumber || null,
          profileImageUrl: null,
          isActive: true,
          totalGamesPlayed: 0,
          careerPoints: 0,
          careerAssists: 0,
          careerRebounds: 0,
          careerSteals: 0,
          careerBlocks: 0,
          careerFouls: 0,
          careerTurnovers: 0,
          careerFgMade: 0,
          careerFgAttempts: 0,
          careerFtMade: 0,
          careerFtAttempts: 0,
          careerMinutesPlayed: 0,
          createdAt: now,
          updatedAt: now
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            PK: `ORG#${orgId}#PLAYER#${playerId}`,
            SK: `PLAYER#${playerId}`,
            OrgId: orgId,
            Type: 'PLAYER',
            Data: newPlayer,
            CreatedAt: now
          }
        }).promise();

        return {
          statusCode: 201,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: newPlayer })
        };

      case 'PUT':
        // Update player
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Player ID required' } })
          };
        }

        const updateData = JSON.parse(body);
        const existingPlayer = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#PLAYER#${pathParameters.id}`,
            SK: `PLAYER#${pathParameters.id}`
          }
        }).promise();

        if (!existingPlayer.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Player not found' } })
          };
        }

        const updatedPlayer = {
          ...existingPlayer.Item.Data,
          ...updateData,
          orgId: orgId, // Ensure orgId cannot be changed
          updatedAt: new Date().toISOString()
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            ...existingPlayer.Item,
            Data: updatedPlayer
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: updatedPlayer })
        };

      case 'DELETE':
        // Soft delete player
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Player ID required' } })
          };
        }

        const playerToDelete = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#PLAYER#${pathParameters.id}`,
            SK: `PLAYER#${pathParameters.id}`
          }
        }).promise();

        if (!playerToDelete.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Player not found' } })
          };
        }

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            ...playerToDelete.Item,
            Data: {
              ...playerToDelete.Item.Data,
              isActive: false,
              updatedAt: new Date().toISOString()
            }
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, message: 'Player deleted successfully' })
        };

      default:
        return {
          statusCode: 405,
          headers: corsHeaders,
          body: JSON.stringify({ success: false, error: { message: 'Method not allowed' } })
        };
    }
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ success: false, error: { message: 'Internal server error' } })
    };
  }
}; 


=== ./cdk/lambda/uploads/index.js ===
const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');

// Configure AWS services for local development
const awsConfig = {
  region: process.env.AWS_REGION || 'ap-southeast-2'
};

// Configure DynamoDB for local development
const dynamoConfig = { ...awsConfig };
if (process.env.AWS_SAM_LOCAL || process.env.DYNAMODB_ENDPOINT) {
  dynamoConfig.endpoint = process.env.DYNAMODB_ENDPOINT || 'http://dynamodb-local:8000';
}

const dynamodb = new AWS.DynamoDB.DocumentClient(dynamoConfig);
const s3 = new AWS.S3(awsConfig);

const TABLE_NAME = process.env.TABLE_NAME;
const BUCKET_NAME = process.env.BUCKET_NAME;

exports.handler = async (event) => {
  console.log('Uploads function received:', JSON.stringify(event, null, 2));
  
  const { httpMethod, pathParameters, body, headers } = event;
  const corsHeaders = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Org-Id',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
  };

  // Extract organization ID from headers (for multi-tenant SAAS)
  const orgId = headers['X-Org-Id'] || headers['x-org-id'] || 'default';
  
  if (!orgId || orgId === 'undefined') {
    return {
      statusCode: 400,
      headers: corsHeaders,
      body: JSON.stringify({ 
        success: false, 
        error: { message: 'Organization ID required' } 
      })
    };
  }

  try {
    switch (httpMethod) {
      case 'OPTIONS':
        return {
          statusCode: 200,
          headers: corsHeaders,
          body: ''
        };

      case 'POST':
        // Generate presigned URL for upload
        const uploadRequest = JSON.parse(body);
        const { fileName, fileType, uploadType = 'general' } = uploadRequest;
        
        if (!fileName || !fileType) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ 
              success: false, 
              error: { message: 'fileName and fileType are required' } 
            })
          };
        }

        const fileId = uuidv4();
        const fileExtension = fileName.split('.').pop();
        const s3Key = `${orgId}/${uploadType}/${fileId}.${fileExtension}`;
        
        // Generate presigned URL for upload
        const presignedUrl = s3.getSignedUrl('putObject', {
          Bucket: BUCKET_NAME,
          Key: s3Key,
          ContentType: fileType,
          Expires: 300 // 5 minutes
        });

        // Store file metadata in DynamoDB
        const now = new Date().toISOString();
        const fileRecord = {
          id: fileId,
          orgId: orgId,
          fileName: fileName,
          fileType: fileType,
          uploadType: uploadType,
          s3Key: s3Key,
          url: `https://${BUCKET_NAME}.s3.amazonaws.com/${s3Key}`,
          status: 'pending',
          createdAt: now,
          updatedAt: now
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            PK: `ORG#${orgId}#UPLOAD#${fileId}`,
            SK: `UPLOAD#${fileId}`,
            OrgId: orgId,
            Type: 'UPLOAD',
            Data: fileRecord,
            CreatedAt: now
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ 
            success: true, 
            data: {
              uploadUrl: presignedUrl,
              fileId: fileId,
              s3Key: s3Key
            }
          })
        };

      case 'GET':
        if (pathParameters && pathParameters.id) {
          // Get single upload record
          const result = await dynamodb.get({
            TableName: TABLE_NAME,
            Key: {
              PK: `ORG#${orgId}#UPLOAD#${pathParameters.id}`,
              SK: `UPLOAD#${pathParameters.id}`
            }
          }).promise();
          
          if (!result.Item) {
            return {
              statusCode: 404,
              headers: corsHeaders,
              body: JSON.stringify({ success: false, error: { message: 'Upload not found' } })
            };
          }
          
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: result.Item.Data })
          };
        } else {
          // Get all uploads for organization
          const result = await dynamodb.query({
            TableName: TABLE_NAME,
            IndexName: 'OrgTypeIndex',
            KeyConditionExpression: 'OrgId = :orgId AND #type = :type',
            ExpressionAttributeNames: {
              '#type': 'Type'
            },
            ExpressionAttributeValues: {
              ':orgId': orgId,
              ':type': 'UPLOAD'
            }
          }).promise();
          
          const uploads = result.Items.map(item => item.Data);
          
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: uploads })
          };
        }

      case 'PUT':
        // Update upload status
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Upload ID required' } })
          };
        }

        const updateData = JSON.parse(body);
        const existingUpload = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#UPLOAD#${pathParameters.id}`,
            SK: `UPLOAD#${pathParameters.id}`
          }
        }).promise();

        if (!existingUpload.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Upload not found' } })
          };
        }

        const updatedUpload = {
          ...existingUpload.Item.Data,
          ...updateData,
          orgId: orgId, // Ensure orgId cannot be changed
          updatedAt: new Date().toISOString()
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            ...existingUpload.Item,
            Data: updatedUpload
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: updatedUpload })
        };

      case 'DELETE':
        // Delete upload and S3 file
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Upload ID required' } })
          };
        }

        const uploadToDelete = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#UPLOAD#${pathParameters.id}`,
            SK: `UPLOAD#${pathParameters.id}`
          }
        }).promise();

        if (!uploadToDelete.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Upload not found' } })
          };
        }

        // Delete from S3
        try {
          await s3.deleteObject({
            Bucket: BUCKET_NAME,
            Key: uploadToDelete.Item.Data.s3Key
          }).promise();
        } catch (s3Error) {
          console.error('Error deleting from S3:', s3Error);
          // Continue with DynamoDB deletion even if S3 deletion fails
        }

        // Delete from DynamoDB
        await dynamodb.delete({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#UPLOAD#${pathParameters.id}`,
            SK: `UPLOAD#${pathParameters.id}`
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, message: 'Upload deleted successfully' })
        };

      default:
        return {
          statusCode: 405,
          headers: corsHeaders,
          body: JSON.stringify({ success: false, error: { message: 'Method not allowed' } })
        };
    }
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ success: false, error: { message: 'Internal server error' } })
    };
  }
}; 


=== ./cdk/lambda/teams/index.js ===
const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');

// Configure DynamoDB for local development
const dynamoConfig = {
  region: process.env.AWS_REGION || 'ap-southeast-2'
};

// Use local DynamoDB if running locally
if (process.env.AWS_SAM_LOCAL || process.env.DYNAMODB_ENDPOINT) {
  dynamoConfig.endpoint = process.env.DYNAMODB_ENDPOINT || 'http://dynamodb-local:8000';
}

const dynamodb = new AWS.DynamoDB.DocumentClient(dynamoConfig);

const TABLE_NAME = process.env.TABLE_NAME;

exports.handler = async (event) => {
  console.log('Teams function received:', JSON.stringify(event, null, 2));
  
  const { httpMethod, pathParameters, body, headers } = event;
  const corsHeaders = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Org-Id',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
  };

  // Extract organization ID from headers (for multi-tenant SAAS)
  const orgId = headers['X-Org-Id'] || headers['x-org-id'] || 'default';
  
  if (!orgId || orgId === 'undefined') {
    return {
      statusCode: 400,
      headers: corsHeaders,
      body: JSON.stringify({ 
        success: false, 
        error: { message: 'Organization ID required' } 
      })
    };
  }

  try {
    switch (httpMethod) {
      case 'OPTIONS':
        return {
          statusCode: 200,
          headers: corsHeaders,
          body: ''
        };

      case 'GET':
        if (pathParameters && pathParameters.id) {
          // Get single team
          const result = await dynamodb.get({
            TableName: TABLE_NAME,
            Key: {
              PK: `ORG#${orgId}#TEAM#${pathParameters.id}`,
              SK: `TEAM#${pathParameters.id}`
            }
          }).promise();
          
          if (!result.Item) {
            return {
              statusCode: 404,
              headers: corsHeaders,
              body: JSON.stringify({ success: false, error: { message: 'Team not found' } })
            };
          }
          
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: result.Item.Data })
          };
        } else {
          // Get all teams for organization
          const result = await dynamodb.query({
            TableName: TABLE_NAME,
            IndexName: 'OrgTypeIndex',
            KeyConditionExpression: 'OrgId = :orgId AND #type = :type',
            ExpressionAttributeNames: {
              '#type': 'Type'
            },
            ExpressionAttributeValues: {
              ':orgId': orgId,
              ':type': 'TEAM'
            }
          }).promise();
          
          const teams = result.Items
            .filter(item => item.Data && item.Data.isActive !== false)
            .map(item => item.Data);
            
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: teams })
          };
        }

      case 'POST':
        // Create new team
        const teamData = JSON.parse(body);
        const teamId = uuidv4();
        const now = new Date().toISOString();
        
        const newTeam = {
          id: teamId,
          orgId: orgId,
          name: teamData.name,
          description: teamData.description || null,
          logoUrl: teamData.logoUrl || null,
          isActive: true,
          players: [], // Array of player IDs
          createdAt: now,
          updatedAt: now
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            PK: `ORG#${orgId}#TEAM#${teamId}`,
            SK: `TEAM#${teamId}`,
            OrgId: orgId,
            Type: 'TEAM',
            Data: newTeam,
            CreatedAt: now
          }
        }).promise();

        return {
          statusCode: 201,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: newTeam })
        };

      case 'PUT':
        // Update team
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Team ID required' } })
          };
        }

        const updateData = JSON.parse(body);
        const existingTeam = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#TEAM#${pathParameters.id}`,
            SK: `TEAM#${pathParameters.id}`
          }
        }).promise();

        if (!existingTeam.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Team not found' } })
          };
        }

        const updatedTeam = {
          ...existingTeam.Item.Data,
          ...updateData,
          orgId: orgId, // Ensure orgId cannot be changed
          updatedAt: new Date().toISOString()
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            ...existingTeam.Item,
            Data: updatedTeam
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: updatedTeam })
        };

      case 'DELETE':
        // Soft delete team
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Team ID required' } })
          };
        }

        const teamToDelete = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#TEAM#${pathParameters.id}`,
            SK: `TEAM#${pathParameters.id}`
          }
        }).promise();

        if (!teamToDelete.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Team not found' } })
          };
        }

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            ...teamToDelete.Item,
            Data: {
              ...teamToDelete.Item.Data,
              isActive: false,
              updatedAt: new Date().toISOString()
            }
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, message: 'Team deleted successfully' })
        };

      default:
        return {
          statusCode: 405,
          headers: corsHeaders,
          body: JSON.stringify({ success: false, error: { message: 'Method not allowed' } })
        };
    }
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ success: false, error: { message: 'Internal server error' } })
    };
  }
}; 


=== ./cdk/lambda/games/index.js ===
const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');

// Configure DynamoDB for local development
const dynamoConfig = {
  region: process.env.AWS_REGION || 'ap-southeast-2'
};

// Use local DynamoDB if running locally
if (process.env.AWS_SAM_LOCAL || process.env.DYNAMODB_ENDPOINT) {
  dynamoConfig.endpoint = process.env.DYNAMODB_ENDPOINT || 'http://dynamodb-local:8000';
}

const dynamodb = new AWS.DynamoDB.DocumentClient(dynamoConfig);

const TABLE_NAME = process.env.TABLE_NAME;

exports.handler = async (event) => {
  console.log('Games function received:', JSON.stringify(event, null, 2));
  
  const { httpMethod, pathParameters, body, headers } = event;
  const corsHeaders = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Org-Id',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
  };

  // Extract organization ID from headers (for multi-tenant SAAS)
  const orgId = headers['X-Org-Id'] || headers['x-org-id'] || 'default';
  
  if (!orgId || orgId === 'undefined') {
    return {
      statusCode: 400,
      headers: corsHeaders,
      body: JSON.stringify({ 
        success: false, 
        error: { message: 'Organization ID required' } 
      })
    };
  }

  try {
    switch (httpMethod) {
      case 'OPTIONS':
        return {
          statusCode: 200,
          headers: corsHeaders,
          body: ''
        };

      case 'GET':
        if (pathParameters && pathParameters.id) {
          // Get single game
          const result = await dynamodb.get({
            TableName: TABLE_NAME,
            Key: {
              PK: `ORG#${orgId}#GAME#${pathParameters.id}`,
              SK: `GAME#${pathParameters.id}`
            }
          }).promise();
          
          if (!result.Item) {
            return {
              statusCode: 404,
              headers: corsHeaders,
              body: JSON.stringify({ success: false, error: { message: 'Game not found' } })
            };
          }
          
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: result.Item.Data })
          };
        } else {
          // Get all games for organization
          const result = await dynamodb.query({
            TableName: TABLE_NAME,
            IndexName: 'OrgTypeIndex',
            KeyConditionExpression: 'OrgId = :orgId AND #type = :type',
            ExpressionAttributeNames: {
              '#type': 'Type'
            },
            ExpressionAttributeValues: {
              ':orgId': orgId,
              ':type': 'GAME'
            }
          }).promise();
          
          const games = result.Items.map(item => item.Data);
          
          return {
            statusCode: 200,
            headers: corsHeaders,
            body: JSON.stringify({ success: true, data: games })
          };
        }

      case 'POST':
        // Create new game
        const gameData = JSON.parse(body);
        const gameId = uuidv4();
        const now = new Date().toISOString();
        
        const newGame = {
          id: gameId,
          orgId: orgId,
          homeTeamId: gameData.homeTeamId || null,
          homeTeamName: gameData.homeTeamName,
          awayTeamId: gameData.awayTeamId || null,
          awayTeamName: gameData.awayTeamName,
          gameFormat: gameData.gameFormat || 'quarters',
          gameDate: gameData.gameDate || now,
          homeTeamScore: 0,
          awayTeamScore: 0,
          totalDuration: 0,
          isCompleted: false,
          notes: gameData.notes || null,
          periodScores: [],
          playerStats: {},
          gameEvents: [],
          createdAt: now,
          updatedAt: now
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            PK: `ORG#${orgId}#GAME#${gameId}`,
            SK: `GAME#${gameId}`,
            OrgId: orgId,
            Type: 'GAME',
            Data: newGame,
            CreatedAt: now
          }
        }).promise();

        return {
          statusCode: 201,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: newGame })
        };

      case 'PUT':
        // Update game
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Game ID required' } })
          };
        }

        const updateData = JSON.parse(body);
        const existingGame = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#GAME#${pathParameters.id}`,
            SK: `GAME#${pathParameters.id}`
          }
        }).promise();

        if (!existingGame.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Game not found' } })
          };
        }

        const updatedGame = {
          ...existingGame.Item.Data,
          ...updateData,
          orgId: orgId, // Ensure orgId cannot be changed
          updatedAt: new Date().toISOString()
        };

        await dynamodb.put({
          TableName: TABLE_NAME,
          Item: {
            ...existingGame.Item,
            Data: updatedGame
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, data: updatedGame })
        };

      case 'DELETE':
        // Delete game
        if (!pathParameters || !pathParameters.id) {
          return {
            statusCode: 400,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Game ID required' } })
          };
        }

        const gameToDelete = await dynamodb.get({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#GAME#${pathParameters.id}`,
            SK: `GAME#${pathParameters.id}`
          }
        }).promise();

        if (!gameToDelete.Item) {
          return {
            statusCode: 404,
            headers: corsHeaders,
            body: JSON.stringify({ success: false, error: { message: 'Game not found' } })
          };
        }

        await dynamodb.delete({
          TableName: TABLE_NAME,
          Key: {
            PK: `ORG#${orgId}#GAME#${pathParameters.id}`,
            SK: `GAME#${pathParameters.id}`
          }
        }).promise();

        return {
          statusCode: 200,
          headers: corsHeaders,
          body: JSON.stringify({ success: true, message: 'Game deleted successfully' })
        };

      default:
        return {
          statusCode: 405,
          headers: corsHeaders,
          body: JSON.stringify({ success: false, error: { message: 'Method not allowed' } })
        };
    }
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ success: false, error: { message: 'Internal server error' } })
    };
  }
}; 


=== ./cdk/lib/basketball-review-stack.js ===
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasketballReviewStack = void 0;
const cdk = require("aws-cdk-lib");
const lambda = require("aws-cdk-lib/aws-lambda");
const dynamodb = require("aws-cdk-lib/aws-dynamodb");
const s3 = require("aws-cdk-lib/aws-s3");
const apigateway = require("aws-cdk-lib/aws-apigateway");
const iam = require("aws-cdk-lib/aws-iam");
class BasketballReviewStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        // Single DynamoDB table for all basketball data (multi-tenant)
        const basketballTable = new dynamodb.Table(this, 'BasketballTable', {
            partitionKey: { name: 'PK', type: dynamodb.AttributeType.STRING },
            sortKey: { name: 'SK', type: dynamodb.AttributeType.STRING },
            billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
            tableName: 'BasketballReview',
            removalPolicy: cdk.RemovalPolicy.DESTROY, // For development
        });
        // Add GSI for querying by organization and type
        basketballTable.addGlobalSecondaryIndex({
            indexName: 'OrgTypeIndex',
            partitionKey: { name: 'OrgId', type: dynamodb.AttributeType.STRING },
            sortKey: { name: 'Type', type: dynamodb.AttributeType.STRING },
        });
        // S3 bucket for file uploads (images, videos)
        const uploadsBucket = new s3.Bucket(this, 'UploadsBucket', {
            bucketName: `basketball-review-uploads-${cdk.Aws.ACCOUNT_ID}`,
            cors: [
                {
                    allowedMethods: [
                        s3.HttpMethods.GET,
                        s3.HttpMethods.POST,
                        s3.HttpMethods.PUT,
                    ],
                    allowedOrigins: ['*'],
                    allowedHeaders: ['*'],
                },
            ],
            removalPolicy: cdk.RemovalPolicy.DESTROY,
        });
        // Shared Lambda role with DynamoDB and S3 permissions
        const lambdaRole = new iam.Role(this, 'LambdaRole', {
            assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
            managedPolicies: [
                iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'),
            ],
            inlinePolicies: {
                DynamoDBAccess: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            effect: iam.Effect.ALLOW,
                            actions: [
                                'dynamodb:GetItem',
                                'dynamodb:PutItem',
                                'dynamodb:UpdateItem',
                                'dynamodb:DeleteItem',
                                'dynamodb:Query',
                                'dynamodb:Scan',
                            ],
                            resources: [
                                basketballTable.tableArn,
                                `${basketballTable.tableArn}/index/*`,
                            ],
                        }),
                    ],
                }),
                S3Access: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            effect: iam.Effect.ALLOW,
                            actions: [
                                's3:GetObject',
                                's3:PutObject',
                                's3:DeleteObject',
                            ],
                            resources: [`${uploadsBucket.bucketArn}/*`],
                        }),
                    ],
                }),
            },
        });
        // Lambda function for Players API
        const playersFunction = new lambda.Function(this, 'PlayersFunction', {
            runtime: lambda.Runtime.NODEJS_18_X,
            handler: 'index.handler',
            code: lambda.Code.fromAsset('lambda/players'),
            role: lambdaRole,
            environment: {
                TABLE_NAME: basketballTable.tableName,
                BUCKET_NAME: uploadsBucket.bucketName,
            },
        });
        // Lambda function for Teams API
        const teamsFunction = new lambda.Function(this, 'TeamsFunction', {
            runtime: lambda.Runtime.NODEJS_18_X,
            handler: 'index.handler',
            code: lambda.Code.fromAsset('lambda/teams'),
            role: lambdaRole,
            environment: {
                TABLE_NAME: basketballTable.tableName,
                BUCKET_NAME: uploadsBucket.bucketName,
            },
        });
        // Lambda function for Games API
        const gamesFunction = new lambda.Function(this, 'GamesFunction', {
            runtime: lambda.Runtime.NODEJS_18_X,
            handler: 'index.handler',
            code: lambda.Code.fromAsset('lambda/games'),
            role: lambdaRole,
            environment: {
                TABLE_NAME: basketballTable.tableName,
                BUCKET_NAME: uploadsBucket.bucketName,
            },
        });
        // Lambda function for Uploads API
        const uploadsFunction = new lambda.Function(this, 'UploadsFunction', {
            runtime: lambda.Runtime.NODEJS_18_X,
            handler: 'index.handler',
            code: lambda.Code.fromAsset('lambda/uploads'),
            role: lambdaRole,
            environment: {
                TABLE_NAME: basketballTable.tableName,
                BUCKET_NAME: uploadsBucket.bucketName,
            },
        });
        // API Gateway
        const api = new apigateway.RestApi(this, 'BasketballApi', {
            restApiName: 'Basketball Review API',
            description: 'Basketball Review SAAS Platform API',
            defaultCorsPreflightOptions: {
                allowOrigins: ['*'],
                allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
                allowHeaders: ['Content-Type', 'Authorization', 'X-Org-Id'],
            },
        });
        // API routes
        const apiResource = api.root.addResource('api');
        // Players routes
        const playersResource = apiResource.addResource('players');
        playersResource.addMethod('GET', new apigateway.LambdaIntegration(playersFunction));
        playersResource.addMethod('POST', new apigateway.LambdaIntegration(playersFunction));
        const playerResource = playersResource.addResource('{id}');
        playerResource.addMethod('GET', new apigateway.LambdaIntegration(playersFunction));
        playerResource.addMethod('PUT', new apigateway.LambdaIntegration(playersFunction));
        playerResource.addMethod('DELETE', new apigateway.LambdaIntegration(playersFunction));
        // Teams routes
        const teamsResource = apiResource.addResource('teams');
        teamsResource.addMethod('GET', new apigateway.LambdaIntegration(teamsFunction));
        teamsResource.addMethod('POST', new apigateway.LambdaIntegration(teamsFunction));
        const teamResource = teamsResource.addResource('{id}');
        teamResource.addMethod('GET', new apigateway.LambdaIntegration(teamsFunction));
        teamResource.addMethod('PUT', new apigateway.LambdaIntegration(teamsFunction));
        teamResource.addMethod('DELETE', new apigateway.LambdaIntegration(teamsFunction));
        // Games routes
        const gamesResource = apiResource.addResource('games');
        gamesResource.addMethod('GET', new apigateway.LambdaIntegration(gamesFunction));
        gamesResource.addMethod('POST', new apigateway.LambdaIntegration(gamesFunction));
        const gameResource = gamesResource.addResource('{id}');
        gameResource.addMethod('GET', new apigateway.LambdaIntegration(gamesFunction));
        gameResource.addMethod('PUT', new apigateway.LambdaIntegration(gamesFunction));
        gameResource.addMethod('DELETE', new apigateway.LambdaIntegration(gamesFunction));
        // Uploads routes
        const uploadsResource = apiResource.addResource('uploads');
        uploadsResource.addMethod('POST', new apigateway.LambdaIntegration(uploadsFunction));
        uploadsResource.addMethod('GET', new apigateway.LambdaIntegration(uploadsFunction));
        // Outputs
        new cdk.CfnOutput(this, 'ApiUrl', {
            value: api.url,
            description: 'Basketball Review API URL',
        });
        new cdk.CfnOutput(this, 'BucketName', {
            value: uploadsBucket.bucketName,
            description: 'S3 Bucket for uploads',
        });
        new cdk.CfnOutput(this, 'TableName', {
            value: basketballTable.tableName,
            description: 'DynamoDB Table Name',
        });
    }
}
exports.BasketballReviewStack = BasketballReviewStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFza2V0YmFsbC1yZXZpZXctc3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJiYXNrZXRiYWxsLXJldmlldy1zdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBbUM7QUFFbkMsaURBQWlEO0FBQ2pELHFEQUFxRDtBQUNyRCx5Q0FBeUM7QUFDekMseURBQXlEO0FBQ3pELDJDQUEyQztBQUUzQyxNQUFhLHFCQUFzQixTQUFRLEdBQUcsQ0FBQyxLQUFLO0lBQ2xELFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBc0I7UUFDOUQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEIsK0RBQStEO1FBQy9ELE1BQU0sZUFBZSxHQUFHLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLEVBQUU7WUFDbEUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUU7WUFDakUsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUU7WUFDNUQsV0FBVyxFQUFFLFFBQVEsQ0FBQyxXQUFXLENBQUMsZUFBZTtZQUNqRCxTQUFTLEVBQUUsa0JBQWtCO1lBQzdCLGFBQWEsRUFBRSxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxrQkFBa0I7U0FDN0QsQ0FBQyxDQUFDO1FBRUgsZ0RBQWdEO1FBQ2hELGVBQWUsQ0FBQyx1QkFBdUIsQ0FBQztZQUN0QyxTQUFTLEVBQUUsY0FBYztZQUN6QixZQUFZLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRTtZQUNwRSxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRTtTQUMvRCxDQUFDLENBQUM7UUFFSCw4Q0FBOEM7UUFDOUMsTUFBTSxhQUFhLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUU7WUFDekQsVUFBVSxFQUFFLDZCQUE2QixHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRTtZQUM3RCxJQUFJLEVBQUU7Z0JBQ0o7b0JBQ0UsY0FBYyxFQUFFO3dCQUNkLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRzt3QkFDbEIsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJO3dCQUNuQixFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUc7cUJBQ25CO29CQUNELGNBQWMsRUFBRSxDQUFDLEdBQUcsQ0FBQztvQkFDckIsY0FBYyxFQUFFLENBQUMsR0FBRyxDQUFDO2lCQUN0QjthQUNGO1lBQ0QsYUFBYSxFQUFFLEdBQUcsQ0FBQyxhQUFhLENBQUMsT0FBTztTQUN6QyxDQUFDLENBQUM7UUFFSCxzREFBc0Q7UUFDdEQsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUU7WUFDbEQsU0FBUyxFQUFFLElBQUksR0FBRyxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDO1lBQzNELGVBQWUsRUFBRTtnQkFDZixHQUFHLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLDBDQUEwQyxDQUFDO2FBQ3ZGO1lBQ0QsY0FBYyxFQUFFO2dCQUNkLGNBQWMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUM7b0JBQ3JDLFVBQVUsRUFBRTt3QkFDVixJQUFJLEdBQUcsQ0FBQyxlQUFlLENBQUM7NEJBQ3RCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUs7NEJBQ3hCLE9BQU8sRUFBRTtnQ0FDUCxrQkFBa0I7Z0NBQ2xCLGtCQUFrQjtnQ0FDbEIscUJBQXFCO2dDQUNyQixxQkFBcUI7Z0NBQ3JCLGdCQUFnQjtnQ0FDaEIsZUFBZTs2QkFDaEI7NEJBQ0QsU0FBUyxFQUFFO2dDQUNULGVBQWUsQ0FBQyxRQUFRO2dDQUN4QixHQUFHLGVBQWUsQ0FBQyxRQUFRLFVBQVU7NkJBQ3RDO3lCQUNGLENBQUM7cUJBQ0g7aUJBQ0YsQ0FBQztnQkFDRixRQUFRLEVBQUUsSUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDO29CQUMvQixVQUFVLEVBQUU7d0JBQ1YsSUFBSSxHQUFHLENBQUMsZUFBZSxDQUFDOzRCQUN0QixNQUFNLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLOzRCQUN4QixPQUFPLEVBQUU7Z0NBQ1AsY0FBYztnQ0FDZCxjQUFjO2dDQUNkLGlCQUFpQjs2QkFDbEI7NEJBQ0QsU0FBUyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsU0FBUyxJQUFJLENBQUM7eUJBQzVDLENBQUM7cUJBQ0g7aUJBQ0YsQ0FBQzthQUNIO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsa0NBQWtDO1FBQ2xDLE1BQU0sZUFBZSxHQUFHLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLEVBQUU7WUFDbkUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztZQUNuQyxPQUFPLEVBQUUsZUFBZTtZQUN4QixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUM7WUFDN0MsSUFBSSxFQUFFLFVBQVU7WUFDaEIsV0FBVyxFQUFFO2dCQUNYLFVBQVUsRUFBRSxlQUFlLENBQUMsU0FBUztnQkFDckMsV0FBVyxFQUFFLGFBQWEsQ0FBQyxVQUFVO2FBQ3RDO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsZ0NBQWdDO1FBQ2hDLE1BQU0sYUFBYSxHQUFHLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsZUFBZSxFQUFFO1lBQy9ELE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7WUFDbkMsT0FBTyxFQUFFLGVBQWU7WUFDeEIsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQztZQUMzQyxJQUFJLEVBQUUsVUFBVTtZQUNoQixXQUFXLEVBQUU7Z0JBQ1gsVUFBVSxFQUFFLGVBQWUsQ0FBQyxTQUFTO2dCQUNyQyxXQUFXLEVBQUUsYUFBYSxDQUFDLFVBQVU7YUFDdEM7U0FDRixDQUFDLENBQUM7UUFFSCxnQ0FBZ0M7UUFDaEMsTUFBTSxhQUFhLEdBQUcsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUU7WUFDL0QsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztZQUNuQyxPQUFPLEVBQUUsZUFBZTtZQUN4QixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO1lBQzNDLElBQUksRUFBRSxVQUFVO1lBQ2hCLFdBQVcsRUFBRTtnQkFDWCxVQUFVLEVBQUUsZUFBZSxDQUFDLFNBQVM7Z0JBQ3JDLFdBQVcsRUFBRSxhQUFhLENBQUMsVUFBVTthQUN0QztTQUNGLENBQUMsQ0FBQztRQUVILGtDQUFrQztRQUNsQyxNQUFNLGVBQWUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFFO1lBQ25FLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7WUFDbkMsT0FBTyxFQUFFLGVBQWU7WUFDeEIsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDO1lBQzdDLElBQUksRUFBRSxVQUFVO1lBQ2hCLFdBQVcsRUFBRTtnQkFDWCxVQUFVLEVBQUUsZUFBZSxDQUFDLFNBQVM7Z0JBQ3JDLFdBQVcsRUFBRSxhQUFhLENBQUMsVUFBVTthQUN0QztTQUNGLENBQUMsQ0FBQztRQUVILGNBQWM7UUFDZCxNQUFNLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRTtZQUN4RCxXQUFXLEVBQUUsdUJBQXVCO1lBQ3BDLFdBQVcsRUFBRSxxQ0FBcUM7WUFDbEQsMkJBQTJCLEVBQUU7Z0JBQzNCLFlBQVksRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDbkIsWUFBWSxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQztnQkFDekQsWUFBWSxFQUFFLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxVQUFVLENBQUM7YUFDNUQ7U0FDRixDQUFDLENBQUM7UUFFSCxhQUFhO1FBQ2IsTUFBTSxXQUFXLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFaEQsaUJBQWlCO1FBQ2pCLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0QsZUFBZSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUNwRixlQUFlLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBRXJGLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0QsY0FBYyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUNuRixjQUFjLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBQ25GLGNBQWMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksVUFBVSxDQUFDLGlCQUFpQixDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFFdEYsZUFBZTtRQUNmLE1BQU0sYUFBYSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkQsYUFBYSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUNoRixhQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBRWpGLE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkQsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUMvRSxZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBQy9FLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksVUFBVSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7UUFFbEYsZUFBZTtRQUNmLE1BQU0sYUFBYSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkQsYUFBYSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUNoRixhQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBRWpGLE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkQsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUMvRSxZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBQy9FLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksVUFBVSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7UUFFbEYsaUJBQWlCO1FBQ2pCLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0QsZUFBZSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUNyRixlQUFlLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBRXBGLFVBQVU7UUFDVixJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRTtZQUNoQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUc7WUFDZCxXQUFXLEVBQUUsMkJBQTJCO1NBQ3pDLENBQUMsQ0FBQztRQUVILElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFO1lBQ3BDLEtBQUssRUFBRSxhQUFhLENBQUMsVUFBVTtZQUMvQixXQUFXLEVBQUUsdUJBQXVCO1NBQ3JDLENBQUMsQ0FBQztRQUVILElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFO1lBQ25DLEtBQUssRUFBRSxlQUFlLENBQUMsU0FBUztZQUNoQyxXQUFXLEVBQUUscUJBQXFCO1NBQ25DLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQWhNRCxzREFnTUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZGsgZnJvbSAnYXdzLWNkay1saWInO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSAnYXdzLWNkay1saWIvYXdzLWxhbWJkYSc7XG5pbXBvcnQgKiBhcyBkeW5hbW9kYiBmcm9tICdhd3MtY2RrLWxpYi9hd3MtZHluYW1vZGInO1xuaW1wb3J0ICogYXMgczMgZnJvbSAnYXdzLWNkay1saWIvYXdzLXMzJztcbmltcG9ydCAqIGFzIGFwaWdhdGV3YXkgZnJvbSAnYXdzLWNkay1saWIvYXdzLWFwaWdhdGV3YXknO1xuaW1wb3J0ICogYXMgaWFtIGZyb20gJ2F3cy1jZGstbGliL2F3cy1pYW0nO1xuXG5leHBvcnQgY2xhc3MgQmFza2V0YmFsbFJldmlld1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBjZGsuU3RhY2tQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwgcHJvcHMpO1xuXG4gICAgLy8gU2luZ2xlIER5bmFtb0RCIHRhYmxlIGZvciBhbGwgYmFza2V0YmFsbCBkYXRhIChtdWx0aS10ZW5hbnQpXG4gICAgY29uc3QgYmFza2V0YmFsbFRhYmxlID0gbmV3IGR5bmFtb2RiLlRhYmxlKHRoaXMsICdCYXNrZXRiYWxsVGFibGUnLCB7XG4gICAgICBwYXJ0aXRpb25LZXk6IHsgbmFtZTogJ1BLJywgdHlwZTogZHluYW1vZGIuQXR0cmlidXRlVHlwZS5TVFJJTkcgfSxcbiAgICAgIHNvcnRLZXk6IHsgbmFtZTogJ1NLJywgdHlwZTogZHluYW1vZGIuQXR0cmlidXRlVHlwZS5TVFJJTkcgfSxcbiAgICAgIGJpbGxpbmdNb2RlOiBkeW5hbW9kYi5CaWxsaW5nTW9kZS5QQVlfUEVSX1JFUVVFU1QsXG4gICAgICB0YWJsZU5hbWU6ICdCYXNrZXRiYWxsUmV2aWV3JyxcbiAgICAgIHJlbW92YWxQb2xpY3k6IGNkay5SZW1vdmFsUG9saWN5LkRFU1RST1ksIC8vIEZvciBkZXZlbG9wbWVudFxuICAgIH0pO1xuXG4gICAgLy8gQWRkIEdTSSBmb3IgcXVlcnlpbmcgYnkgb3JnYW5pemF0aW9uIGFuZCB0eXBlXG4gICAgYmFza2V0YmFsbFRhYmxlLmFkZEdsb2JhbFNlY29uZGFyeUluZGV4KHtcbiAgICAgIGluZGV4TmFtZTogJ09yZ1R5cGVJbmRleCcsXG4gICAgICBwYXJ0aXRpb25LZXk6IHsgbmFtZTogJ09yZ0lkJywgdHlwZTogZHluYW1vZGIuQXR0cmlidXRlVHlwZS5TVFJJTkcgfSxcbiAgICAgIHNvcnRLZXk6IHsgbmFtZTogJ1R5cGUnLCB0eXBlOiBkeW5hbW9kYi5BdHRyaWJ1dGVUeXBlLlNUUklORyB9LFxuICAgIH0pO1xuXG4gICAgLy8gUzMgYnVja2V0IGZvciBmaWxlIHVwbG9hZHMgKGltYWdlcywgdmlkZW9zKVxuICAgIGNvbnN0IHVwbG9hZHNCdWNrZXQgPSBuZXcgczMuQnVja2V0KHRoaXMsICdVcGxvYWRzQnVja2V0Jywge1xuICAgICAgYnVja2V0TmFtZTogYGJhc2tldGJhbGwtcmV2aWV3LXVwbG9hZHMtJHtjZGsuQXdzLkFDQ09VTlRfSUR9YCxcbiAgICAgIGNvcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGFsbG93ZWRNZXRob2RzOiBbXG4gICAgICAgICAgICBzMy5IdHRwTWV0aG9kcy5HRVQsXG4gICAgICAgICAgICBzMy5IdHRwTWV0aG9kcy5QT1NULFxuICAgICAgICAgICAgczMuSHR0cE1ldGhvZHMuUFVULFxuICAgICAgICAgIF0sXG4gICAgICAgICAgYWxsb3dlZE9yaWdpbnM6IFsnKiddLFxuICAgICAgICAgIGFsbG93ZWRIZWFkZXJzOiBbJyonXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICByZW1vdmFsUG9saWN5OiBjZGsuUmVtb3ZhbFBvbGljeS5ERVNUUk9ZLFxuICAgIH0pO1xuXG4gICAgLy8gU2hhcmVkIExhbWJkYSByb2xlIHdpdGggRHluYW1vREIgYW5kIFMzIHBlcm1pc3Npb25zXG4gICAgY29uc3QgbGFtYmRhUm9sZSA9IG5ldyBpYW0uUm9sZSh0aGlzLCAnTGFtYmRhUm9sZScsIHtcbiAgICAgIGFzc3VtZWRCeTogbmV3IGlhbS5TZXJ2aWNlUHJpbmNpcGFsKCdsYW1iZGEuYW1hem9uYXdzLmNvbScpLFxuICAgICAgbWFuYWdlZFBvbGljaWVzOiBbXG4gICAgICAgIGlhbS5NYW5hZ2VkUG9saWN5LmZyb21Bd3NNYW5hZ2VkUG9saWN5TmFtZSgnc2VydmljZS1yb2xlL0FXU0xhbWJkYUJhc2ljRXhlY3V0aW9uUm9sZScpLFxuICAgICAgXSxcbiAgICAgIGlubGluZVBvbGljaWVzOiB7XG4gICAgICAgIER5bmFtb0RCQWNjZXNzOiBuZXcgaWFtLlBvbGljeURvY3VtZW50KHtcbiAgICAgICAgICBzdGF0ZW1lbnRzOiBbXG4gICAgICAgICAgICBuZXcgaWFtLlBvbGljeVN0YXRlbWVudCh7XG4gICAgICAgICAgICAgIGVmZmVjdDogaWFtLkVmZmVjdC5BTExPVyxcbiAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICdkeW5hbW9kYjpHZXRJdGVtJyxcbiAgICAgICAgICAgICAgICAnZHluYW1vZGI6UHV0SXRlbScsXG4gICAgICAgICAgICAgICAgJ2R5bmFtb2RiOlVwZGF0ZUl0ZW0nLFxuICAgICAgICAgICAgICAgICdkeW5hbW9kYjpEZWxldGVJdGVtJyxcbiAgICAgICAgICAgICAgICAnZHluYW1vZGI6UXVlcnknLFxuICAgICAgICAgICAgICAgICdkeW5hbW9kYjpTY2FuJyxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VzOiBbXG4gICAgICAgICAgICAgICAgYmFza2V0YmFsbFRhYmxlLnRhYmxlQXJuLFxuICAgICAgICAgICAgICAgIGAke2Jhc2tldGJhbGxUYWJsZS50YWJsZUFybn0vaW5kZXgvKmAsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgICAgUzNBY2Nlc3M6IG5ldyBpYW0uUG9saWN5RG9jdW1lbnQoe1xuICAgICAgICAgIHN0YXRlbWVudHM6IFtcbiAgICAgICAgICAgIG5ldyBpYW0uUG9saWN5U3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgZWZmZWN0OiBpYW0uRWZmZWN0LkFMTE9XLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgJ3MzOkdldE9iamVjdCcsXG4gICAgICAgICAgICAgICAgJ3MzOlB1dE9iamVjdCcsXG4gICAgICAgICAgICAgICAgJ3MzOkRlbGV0ZU9iamVjdCcsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIHJlc291cmNlczogW2Ake3VwbG9hZHNCdWNrZXQuYnVja2V0QXJufS8qYF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBMYW1iZGEgZnVuY3Rpb24gZm9yIFBsYXllcnMgQVBJXG4gICAgY29uc3QgcGxheWVyc0Z1bmN0aW9uID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCAnUGxheWVyc0Z1bmN0aW9uJywge1xuICAgICAgcnVudGltZTogbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE4X1gsXG4gICAgICBoYW5kbGVyOiAnaW5kZXguaGFuZGxlcicsXG4gICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoJ2xhbWJkYS9wbGF5ZXJzJyksXG4gICAgICByb2xlOiBsYW1iZGFSb2xlLFxuICAgICAgZW52aXJvbm1lbnQ6IHtcbiAgICAgICAgVEFCTEVfTkFNRTogYmFza2V0YmFsbFRhYmxlLnRhYmxlTmFtZSxcbiAgICAgICAgQlVDS0VUX05BTUU6IHVwbG9hZHNCdWNrZXQuYnVja2V0TmFtZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBMYW1iZGEgZnVuY3Rpb24gZm9yIFRlYW1zIEFQSVxuICAgIGNvbnN0IHRlYW1zRnVuY3Rpb24gPSBuZXcgbGFtYmRhLkZ1bmN0aW9uKHRoaXMsICdUZWFtc0Z1bmN0aW9uJywge1xuICAgICAgcnVudGltZTogbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE4X1gsXG4gICAgICBoYW5kbGVyOiAnaW5kZXguaGFuZGxlcicsXG4gICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoJ2xhbWJkYS90ZWFtcycpLFxuICAgICAgcm9sZTogbGFtYmRhUm9sZSxcbiAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgIFRBQkxFX05BTUU6IGJhc2tldGJhbGxUYWJsZS50YWJsZU5hbWUsXG4gICAgICAgIEJVQ0tFVF9OQU1FOiB1cGxvYWRzQnVja2V0LmJ1Y2tldE5hbWUsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gTGFtYmRhIGZ1bmN0aW9uIGZvciBHYW1lcyBBUElcbiAgICBjb25zdCBnYW1lc0Z1bmN0aW9uID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCAnR2FtZXNGdW5jdGlvbicsIHtcbiAgICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xOF9YLFxuICAgICAgaGFuZGxlcjogJ2luZGV4LmhhbmRsZXInLFxuICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KCdsYW1iZGEvZ2FtZXMnKSxcbiAgICAgIHJvbGU6IGxhbWJkYVJvbGUsXG4gICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICBUQUJMRV9OQU1FOiBiYXNrZXRiYWxsVGFibGUudGFibGVOYW1lLFxuICAgICAgICBCVUNLRVRfTkFNRTogdXBsb2Fkc0J1Y2tldC5idWNrZXROYW1lLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIExhbWJkYSBmdW5jdGlvbiBmb3IgVXBsb2FkcyBBUElcbiAgICBjb25zdCB1cGxvYWRzRnVuY3Rpb24gPSBuZXcgbGFtYmRhLkZ1bmN0aW9uKHRoaXMsICdVcGxvYWRzRnVuY3Rpb24nLCB7XG4gICAgICBydW50aW1lOiBsYW1iZGEuUnVudGltZS5OT0RFSlNfMThfWCxcbiAgICAgIGhhbmRsZXI6ICdpbmRleC5oYW5kbGVyJyxcbiAgICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldCgnbGFtYmRhL3VwbG9hZHMnKSxcbiAgICAgIHJvbGU6IGxhbWJkYVJvbGUsXG4gICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICBUQUJMRV9OQU1FOiBiYXNrZXRiYWxsVGFibGUudGFibGVOYW1lLFxuICAgICAgICBCVUNLRVRfTkFNRTogdXBsb2Fkc0J1Y2tldC5idWNrZXROYW1lLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIEFQSSBHYXRld2F5XG4gICAgY29uc3QgYXBpID0gbmV3IGFwaWdhdGV3YXkuUmVzdEFwaSh0aGlzLCAnQmFza2V0YmFsbEFwaScsIHtcbiAgICAgIHJlc3RBcGlOYW1lOiAnQmFza2V0YmFsbCBSZXZpZXcgQVBJJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQmFza2V0YmFsbCBSZXZpZXcgU0FBUyBQbGF0Zm9ybSBBUEknLFxuICAgICAgZGVmYXVsdENvcnNQcmVmbGlnaHRPcHRpb25zOiB7XG4gICAgICAgIGFsbG93T3JpZ2luczogWycqJ10sXG4gICAgICAgIGFsbG93TWV0aG9kczogWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ09QVElPTlMnXSxcbiAgICAgICAgYWxsb3dIZWFkZXJzOiBbJ0NvbnRlbnQtVHlwZScsICdBdXRob3JpemF0aW9uJywgJ1gtT3JnLUlkJ10sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gQVBJIHJvdXRlc1xuICAgIGNvbnN0IGFwaVJlc291cmNlID0gYXBpLnJvb3QuYWRkUmVzb3VyY2UoJ2FwaScpO1xuICAgIFxuICAgIC8vIFBsYXllcnMgcm91dGVzXG4gICAgY29uc3QgcGxheWVyc1Jlc291cmNlID0gYXBpUmVzb3VyY2UuYWRkUmVzb3VyY2UoJ3BsYXllcnMnKTtcbiAgICBwbGF5ZXJzUmVzb3VyY2UuYWRkTWV0aG9kKCdHRVQnLCBuZXcgYXBpZ2F0ZXdheS5MYW1iZGFJbnRlZ3JhdGlvbihwbGF5ZXJzRnVuY3Rpb24pKTtcbiAgICBwbGF5ZXJzUmVzb3VyY2UuYWRkTWV0aG9kKCdQT1NUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24ocGxheWVyc0Z1bmN0aW9uKSk7XG4gICAgXG4gICAgY29uc3QgcGxheWVyUmVzb3VyY2UgPSBwbGF5ZXJzUmVzb3VyY2UuYWRkUmVzb3VyY2UoJ3tpZH0nKTtcbiAgICBwbGF5ZXJSZXNvdXJjZS5hZGRNZXRob2QoJ0dFVCcsIG5ldyBhcGlnYXRld2F5LkxhbWJkYUludGVncmF0aW9uKHBsYXllcnNGdW5jdGlvbikpO1xuICAgIHBsYXllclJlc291cmNlLmFkZE1ldGhvZCgnUFVUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24ocGxheWVyc0Z1bmN0aW9uKSk7XG4gICAgcGxheWVyUmVzb3VyY2UuYWRkTWV0aG9kKCdERUxFVEUnLCBuZXcgYXBpZ2F0ZXdheS5MYW1iZGFJbnRlZ3JhdGlvbihwbGF5ZXJzRnVuY3Rpb24pKTtcblxuICAgIC8vIFRlYW1zIHJvdXRlc1xuICAgIGNvbnN0IHRlYW1zUmVzb3VyY2UgPSBhcGlSZXNvdXJjZS5hZGRSZXNvdXJjZSgndGVhbXMnKTtcbiAgICB0ZWFtc1Jlc291cmNlLmFkZE1ldGhvZCgnR0VUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24odGVhbXNGdW5jdGlvbikpO1xuICAgIHRlYW1zUmVzb3VyY2UuYWRkTWV0aG9kKCdQT1NUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24odGVhbXNGdW5jdGlvbikpO1xuICAgIFxuICAgIGNvbnN0IHRlYW1SZXNvdXJjZSA9IHRlYW1zUmVzb3VyY2UuYWRkUmVzb3VyY2UoJ3tpZH0nKTtcbiAgICB0ZWFtUmVzb3VyY2UuYWRkTWV0aG9kKCdHRVQnLCBuZXcgYXBpZ2F0ZXdheS5MYW1iZGFJbnRlZ3JhdGlvbih0ZWFtc0Z1bmN0aW9uKSk7XG4gICAgdGVhbVJlc291cmNlLmFkZE1ldGhvZCgnUFVUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24odGVhbXNGdW5jdGlvbikpO1xuICAgIHRlYW1SZXNvdXJjZS5hZGRNZXRob2QoJ0RFTEVURScsIG5ldyBhcGlnYXRld2F5LkxhbWJkYUludGVncmF0aW9uKHRlYW1zRnVuY3Rpb24pKTtcblxuICAgIC8vIEdhbWVzIHJvdXRlc1xuICAgIGNvbnN0IGdhbWVzUmVzb3VyY2UgPSBhcGlSZXNvdXJjZS5hZGRSZXNvdXJjZSgnZ2FtZXMnKTtcbiAgICBnYW1lc1Jlc291cmNlLmFkZE1ldGhvZCgnR0VUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24oZ2FtZXNGdW5jdGlvbikpO1xuICAgIGdhbWVzUmVzb3VyY2UuYWRkTWV0aG9kKCdQT1NUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24oZ2FtZXNGdW5jdGlvbikpO1xuICAgIFxuICAgIGNvbnN0IGdhbWVSZXNvdXJjZSA9IGdhbWVzUmVzb3VyY2UuYWRkUmVzb3VyY2UoJ3tpZH0nKTtcbiAgICBnYW1lUmVzb3VyY2UuYWRkTWV0aG9kKCdHRVQnLCBuZXcgYXBpZ2F0ZXdheS5MYW1iZGFJbnRlZ3JhdGlvbihnYW1lc0Z1bmN0aW9uKSk7XG4gICAgZ2FtZVJlc291cmNlLmFkZE1ldGhvZCgnUFVUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24oZ2FtZXNGdW5jdGlvbikpO1xuICAgIGdhbWVSZXNvdXJjZS5hZGRNZXRob2QoJ0RFTEVURScsIG5ldyBhcGlnYXRld2F5LkxhbWJkYUludGVncmF0aW9uKGdhbWVzRnVuY3Rpb24pKTtcblxuICAgIC8vIFVwbG9hZHMgcm91dGVzXG4gICAgY29uc3QgdXBsb2Fkc1Jlc291cmNlID0gYXBpUmVzb3VyY2UuYWRkUmVzb3VyY2UoJ3VwbG9hZHMnKTtcbiAgICB1cGxvYWRzUmVzb3VyY2UuYWRkTWV0aG9kKCdQT1NUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24odXBsb2Fkc0Z1bmN0aW9uKSk7XG4gICAgdXBsb2Fkc1Jlc291cmNlLmFkZE1ldGhvZCgnR0VUJywgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24odXBsb2Fkc0Z1bmN0aW9uKSk7XG5cbiAgICAvLyBPdXRwdXRzXG4gICAgbmV3IGNkay5DZm5PdXRwdXQodGhpcywgJ0FwaVVybCcsIHtcbiAgICAgIHZhbHVlOiBhcGkudXJsLFxuICAgICAgZGVzY3JpcHRpb246ICdCYXNrZXRiYWxsIFJldmlldyBBUEkgVVJMJyxcbiAgICB9KTtcblxuICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsICdCdWNrZXROYW1lJywge1xuICAgICAgdmFsdWU6IHVwbG9hZHNCdWNrZXQuYnVja2V0TmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUzMgQnVja2V0IGZvciB1cGxvYWRzJyxcbiAgICB9KTtcblxuICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsICdUYWJsZU5hbWUnLCB7XG4gICAgICB2YWx1ZTogYmFza2V0YmFsbFRhYmxlLnRhYmxlTmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRHluYW1vREIgVGFibGUgTmFtZScsXG4gICAgfSk7XG4gIH1cbn0gIl19


=== ./cdk/lib/basketball-review-stack.d.ts ===
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
export declare class BasketballReviewStack extends cdk.Stack {
    constructor(scope: Construct, id: string, props?: cdk.StackProps);
}



=== ./cdk/lib/basketball-review-stack.ts ===
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as iam from 'aws-cdk-lib/aws-iam';

export class BasketballReviewStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Single DynamoDB table for all basketball data (multi-tenant)
    const basketballTable = new dynamodb.Table(this, 'BasketballTable', {
      partitionKey: { name: 'PK', type: dynamodb.AttributeType.STRING },
      sortKey: { name: 'SK', type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      tableName: 'BasketballReview',
      removalPolicy: cdk.RemovalPolicy.DESTROY, // For development
    });

    // Add GSI for querying by organization and type
    basketballTable.addGlobalSecondaryIndex({
      indexName: 'OrgTypeIndex',
      partitionKey: { name: 'OrgId', type: dynamodb.AttributeType.STRING },
      sortKey: { name: 'Type', type: dynamodb.AttributeType.STRING },
    });

    // S3 bucket for file uploads (images)
    const uploadsBucket = new s3.Bucket(this, 'UploadsBucket', {
      bucketName: `basketball-review-uploads-${cdk.Aws.ACCOUNT_ID}`,
      cors: [
        {
          allowedMethods: [
            s3.HttpMethods.GET,
            s3.HttpMethods.POST,
            s3.HttpMethods.PUT,
          ],
          allowedOrigins: ['*'],
          allowedHeaders: ['*'],
        },
      ],
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // Shared Lambda role with DynamoDB and S3 permissions
    const lambdaRole = new iam.Role(this, 'LambdaRole', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'),
      ],
      inlinePolicies: {
        DynamoDBAccess: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: [
                'dynamodb:GetItem',
                'dynamodb:PutItem',
                'dynamodb:UpdateItem',
                'dynamodb:DeleteItem',
                'dynamodb:Query',
                'dynamodb:Scan',
              ],
              resources: [
                basketballTable.tableArn,
                `${basketballTable.tableArn}/index/*`,
              ],
            }),
          ],
        }),
        S3Access: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: [
                's3:GetObject',
                's3:PutObject',
                's3:DeleteObject',
              ],
              resources: [`${uploadsBucket.bucketArn}/*`],
            }),
          ],
        }),
      },
    });

    // Lambda function for Players API
    const playersFunction = new lambda.Function(this, 'PlayersFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'index.handler',
      code: lambda.Code.fromAsset('lambda/players'),
      role: lambdaRole,
      environment: {
        TABLE_NAME: basketballTable.tableName,
        BUCKET_NAME: uploadsBucket.bucketName,
      },
    });

    // Lambda function for Teams API
    const teamsFunction = new lambda.Function(this, 'TeamsFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'index.handler',
      code: lambda.Code.fromAsset('lambda/teams'),
      role: lambdaRole,
      environment: {
        TABLE_NAME: basketballTable.tableName,
        BUCKET_NAME: uploadsBucket.bucketName,
      },
    });

    // Lambda function for Games API
    const gamesFunction = new lambda.Function(this, 'GamesFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'index.handler',
      code: lambda.Code.fromAsset('lambda/games'),
      role: lambdaRole,
      environment: {
        TABLE_NAME: basketballTable.tableName,
        BUCKET_NAME: uploadsBucket.bucketName,
      },
    });

    // Lambda function for Uploads API
    const uploadsFunction = new lambda.Function(this, 'UploadsFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'index.handler',
      code: lambda.Code.fromAsset('lambda/uploads'),
      role: lambdaRole,
      environment: {
        TABLE_NAME: basketballTable.tableName,
        BUCKET_NAME: uploadsBucket.bucketName,
      },
    });

    // API Gateway
    const api = new apigateway.RestApi(this, 'BasketballApi', {
      restApiName: 'Basketball Review API',
      description: 'Basketball Review SAAS Platform API',
      defaultCorsPreflightOptions: {
        allowOrigins: ['*'],
        allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowHeaders: ['Content-Type', 'Authorization', 'X-Org-Id'],
      },
    });

    // API routes
    const apiResource = api.root.addResource('api');
    
    // Players routes
    const playersResource = apiResource.addResource('players');
    playersResource.addMethod('GET', new apigateway.LambdaIntegration(playersFunction));
    playersResource.addMethod('POST', new apigateway.LambdaIntegration(playersFunction));
    
    const playerResource = playersResource.addResource('{id}');
    playerResource.addMethod('GET', new apigateway.LambdaIntegration(playersFunction));
    playerResource.addMethod('PUT', new apigateway.LambdaIntegration(playersFunction));
    playerResource.addMethod('DELETE', new apigateway.LambdaIntegration(playersFunction));

    // Teams routes
    const teamsResource = apiResource.addResource('teams');
    teamsResource.addMethod('GET', new apigateway.LambdaIntegration(teamsFunction));
    teamsResource.addMethod('POST', new apigateway.LambdaIntegration(teamsFunction));
    
    const teamResource = teamsResource.addResource('{id}');
    teamResource.addMethod('GET', new apigateway.LambdaIntegration(teamsFunction));
    teamResource.addMethod('PUT', new apigateway.LambdaIntegration(teamsFunction));
    teamResource.addMethod('DELETE', new apigateway.LambdaIntegration(teamsFunction));

    // Games routes
    const gamesResource = apiResource.addResource('games');
    gamesResource.addMethod('GET', new apigateway.LambdaIntegration(gamesFunction));
    gamesResource.addMethod('POST', new apigateway.LambdaIntegration(gamesFunction));
    
    const gameResource = gamesResource.addResource('{id}');
    gameResource.addMethod('GET', new apigateway.LambdaIntegration(gamesFunction));
    gameResource.addMethod('PUT', new apigateway.LambdaIntegration(gamesFunction));
    gameResource.addMethod('DELETE', new apigateway.LambdaIntegration(gamesFunction));

    // Uploads routes
    const uploadsResource = apiResource.addResource('uploads');
    uploadsResource.addMethod('POST', new apigateway.LambdaIntegration(uploadsFunction));
    uploadsResource.addMethod('GET', new apigateway.LambdaIntegration(uploadsFunction));

    // Outputs
    new cdk.CfnOutput(this, 'ApiUrl', {
      value: api.url,
      description: 'Basketball Review API URL',
    });

    new cdk.CfnOutput(this, 'BucketName', {
      value: uploadsBucket.bucketName,
      description: 'S3 Bucket for uploads',
    });

    new cdk.CfnOutput(this, 'TableName', {
      value: basketballTable.tableName,
      description: 'DynamoDB Table Name',
    });
  }
} 


=== ./cdk/tsconfig.json ===
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": [
      "es2020"
    ],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": false,
    "inlineSourceMap": true,
    "inlineSources": true,
    "experimentalDecorators": true,
    "strictPropertyInitialization": false,
    "typeRoots": [
      "./node_modules/@types"
    ]
  },
  "exclude": [
    "node_modules",
    "cdk.out"
  ]
} 


=== ./index.html ===
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Basketball Review App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



=== ./.claude/settings.local.json ===
{
  "permissions": {
    "allow": [
      "Bash(npm run dev:*)",
      "Bash(lsof:*)",
      "Bash(npm run type-check:*)",
      "Bash(npm run:*)",
      "Bash(npx tsc:*)",
      "Bash(find:*)",
      "Bash(npm install:*)"
    ],
    "deny": []
  }
}


=== ./tsconfig.json ===
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    
    /* JSX */
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "exclude": ["src/setupTests.ts"]
}



=== ./vite.config.ts ===
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
}) 


=== ./LOCAL_DEVELOPMENT.md ===
# Local Development Guide

This guide explains how to develop the Basketball Review app locally without AWS services.

## Quick Start

1. **Install dependencies:**
   ```bash
   npm install
   ```

2. **Mock mode is already enabled!** 
   The `.env` file has `VITE_MOCK_API=true` set, which enables full local development.

3. **Start the development server:**
   ```bash
   npm run dev
   ```

4. **Open your browser:**
   Navigate to `http://localhost:5173`

## How It Works

### Mock Backend
- All API calls are intercepted and handled locally using localStorage
- No AWS services are required during development
- Data persists across browser sessions
- File uploads are stored as data URLs in localStorage

### Features Available in Mock Mode
-  Player management (create, edit, delete)
-  Team management (create, edit, delete) 
-  Game tracking and statistics
-  Image uploads for players and teams
-  Multi-tenant support (organization switching)
-  Full CRUD operations with persistence

### Switching Between Mock and Real Backend

1. **For local development (mock mode):**
   ```
   VITE_MOCK_API=true
   ```

2. **For production (AWS backend):**
   ```
   VITE_MOCK_API=false
   VITE_API_URL=https://your-api-gateway-url.amazonaws.com
   ```

## Development Workflow

1. **Develop features locally** with mock mode enabled
2. **Test thoroughly** - all data persists in localStorage
3. **Deploy to AWS** when ready using CDK:
   ```bash
   npm run cdk:deploy
   ```

## Mock Data Management

### Clear all mock data:
Open browser console and run:
```javascript
// Clear all basketball mock data
Object.keys(localStorage)
  .filter(key => key.startsWith('basketball-mock-'))
  .forEach(key => localStorage.removeItem(key));
```

### Export mock data:
```javascript
// Export current mock data
const mockData = {};
Object.keys(localStorage)
  .filter(key => key.startsWith('basketball-mock-'))
  .forEach(key => mockData[key] = localStorage.getItem(key));
console.log(JSON.stringify(mockData, null, 2));
```

### Import mock data:
```javascript
// Import mock data
const dataToImport = { /* your data */ };
Object.entries(dataToImport).forEach(([key, value]) => 
  localStorage.setItem(key, value)
);
```

## Architecture Benefits

- **Zero AWS costs** during development
- **Fast iteration** - no deployment needed
- **Works offline** - perfect for development
- **Easy onboarding** - no AWS account needed
- **Clean separation** - frontend has no AWS dependencies

## Next Steps

When you're ready to deploy:
1. Set up AWS credentials
2. Run `npm run cdk:deploy`
3. Update `.env` with the API Gateway URL
4. Set `VITE_MOCK_API=false`

That's it! Happy coding! 


=== ./src/App.tsx ===
import React, { useState } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import BasketballReviewApp from './BasketballReviewApp';
import LandingPage from './components/LandingPage';
import { PlayerDetailPage } from './components/PlayerProfiles/PlayerDetailPage';

/**
 * Main App component - Basketball Review Dashboard
 * Shows landing page first, then navigates to the main app
 */
const App: React.FC = () => {
  const [showLandingPage, setShowLandingPage] = useState(true);

  const handleEnterApp = () => {
    setShowLandingPage(false);
  };

  const handleBackToLanding = () => {
    setShowLandingPage(true);
  };

  if (showLandingPage) {
    return <LandingPage onEnterApp={handleEnterApp} />;
  }

  return (
    <BrowserRouter>
      <div className="relative">
        <Routes>
          <Route path="/" element={<BasketballReviewApp />} />
          <Route path="/players/:playerId" element={<PlayerDetailPage />} />
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
        
        {/* Back to Landing Button - optional */}
        <button
          onClick={handleBackToLanding}
          className="fixed bottom-6 left-6 p-3 bg-zinc-800 hover:bg-zinc-700 text-white rounded-full shadow-lg transition-all duration-200 z-50 opacity-60 hover:opacity-100"
          title="Back to Landing"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
          </svg>
        </button>
      </div>
    </BrowserRouter>
  );
};

export default App;


=== ./src/main.tsx ===
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
) 


=== ./src/BasketballReviewApp.tsx ===
import { useState, useEffect } from 'react';
import { Play, Users, Trophy, Menu, X, BarChart3, ChevronLeft, ChevronRight } from 'lucide-react';

// Components  
import { GameReview } from './components/GameReview/GameReview';
import { PlayersSimplified } from './components/PlayerProfiles/PlayersSimplified';
import { MyTeams } from './components/MyTeams/MyTeams';

type TabType = 'game' | 'players' | 'teams';

const BasketballReviewApp = () => {
  const [activeTab, setActiveTab] = useState<TabType>('players');
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(() => {
    // Load collapsed state from localStorage
    const saved = localStorage.getItem('sidebarCollapsed');
    return saved ? JSON.parse(saved) : false;
  });

  const tabs = [
    {
      id: 'players' as TabType,
      label: 'Players',
      icon: Users,
      component: PlayersSimplified,
      description: 'Manage player profiles and basic information'
    },
    {
      id: 'teams' as TabType,
      label: 'My Teams',
      icon: Trophy,
      component: MyTeams,
      description: 'Create and manage your basketball teams'
    },
    {
      id: 'game' as TabType,
      label: 'Game Review',
      icon: Play,
      component: GameReview,
      description: 'Track live game statistics and manage gameplay'
    }
  ];

  const ActiveComponent = tabs.find(tab => tab.id === activeTab)?.component || PlayersSimplified;
  const activeTabInfo = tabs.find(tab => tab.id === activeTab);

  // Save collapsed state when it changes
  useEffect(() => {
    localStorage.setItem('sidebarCollapsed', JSON.stringify(sidebarCollapsed));
  }, [sidebarCollapsed]);

  const toggleSidebarCollapse = () => {
    setSidebarCollapsed(prev => !prev);
  };

  return (
    <div className="min-h-screen bg-zinc-900 text-white flex">
      {/* Mobile Sidebar Overlay */}
      {sidebarOpen && (
        <div 
          className="fixed inset-0 bg-black/50 z-40 lg:hidden"
          onClick={() => setSidebarOpen(false)}
        />
      )}

      {/* Sidebar */}
      <aside className={`
        fixed lg:static inset-y-0 left-0 z-50 bg-gradient-to-b from-zinc-900 to-zinc-800 
        border-r border-zinc-700 transform transition-all duration-300 ease-in-out
        ${sidebarOpen ? 'translate-x-0' : '-translate-x-full lg:translate-x-0'}
        ${sidebarCollapsed ? 'w-20' : 'w-72'}
      `}>
        {/* Sidebar Header */}
        <div className={`flex items-center ${sidebarCollapsed ? 'justify-center' : 'justify-between'} p-6 border-b border-zinc-700`}>
          <div className={`flex items-center ${sidebarCollapsed ? '' : 'gap-3'}`}>
            <div className="p-2 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-lg">
              <Trophy className="w-6 h-6 text-black" />
            </div>
            {!sidebarCollapsed && (
              <div>
                <h1 className="text-xl font-bold text-white">Basketball Pro</h1>
                <p className="text-xs text-zinc-400">Game Management</p>
              </div>
            )}
          </div>
          {!sidebarCollapsed && (
            <button
              onClick={() => setSidebarOpen(false)}
              className="lg:hidden p-2 hover:bg-zinc-700 rounded-lg transition-colors"
            >
              <X className="w-5 h-5" />
            </button>
          )}
        </div>

        {/* Collapse Toggle Button - Desktop Only */}
        <div className="hidden lg:flex justify-end p-2 border-b border-zinc-700">
          <button
            onClick={toggleSidebarCollapse}
            className="p-2 hover:bg-zinc-700 rounded-lg transition-colors"
            title={sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}
          >
            {sidebarCollapsed ? <ChevronRight className="w-5 h-5" /> : <ChevronLeft className="w-5 h-5" />}
          </button>
        </div>

        {/* Navigation */}
        <nav className="p-4 space-y-2">
          {tabs.map((tab) => {
            const Icon = tab.icon;
            const isActive = activeTab === tab.id;
            return (
              <button
                key={tab.id}
                onClick={() => {
                  setActiveTab(tab.id);
                  setSidebarOpen(false);
                }}
                className={`
                  w-full flex ${sidebarCollapsed ? 'justify-center' : 'items-start gap-4'} p-4 rounded-xl text-left transition-all duration-200
                  ${isActive
                    ? 'bg-gradient-to-r from-yellow-500/10 to-yellow-600/10 border border-yellow-500/20 text-yellow-400'
                    : 'hover:bg-zinc-700/50 text-zinc-300 hover:text-white'
                  }
                `}
                title={sidebarCollapsed ? tab.label : undefined}
              >
                <Icon className={`w-5 h-5 ${sidebarCollapsed ? '' : 'mt-0.5'} ${isActive ? 'text-yellow-400' : ''}`} />
                {!sidebarCollapsed && (
                  <div className="flex-1 min-w-0">
                    <div className={`font-medium ${isActive ? 'text-yellow-400' : ''}`}>
                      {tab.label}
                    </div>
                    <div className="text-xs text-zinc-400 mt-1 leading-relaxed">
                      {tab.description}
                    </div>
                  </div>
                )}
              </button>
            );
          })}
        </nav>

        {/* Sidebar Footer */}
        <div className="absolute bottom-0 left-0 right-0 p-4 border-t border-zinc-700">
          <div className={`flex items-center ${sidebarCollapsed ? 'justify-center' : 'gap-3'} text-sm text-zinc-400`}>
            <BarChart3 className="w-4 h-4" />
            {!sidebarCollapsed && <span>React + Express App</span>}
          </div>
        </div>
      </aside>

      {/* Main Content Area */}
      <div className="flex-1 flex flex-col min-h-screen">
        {/* Top Header */}
        <header className="bg-zinc-900/50 backdrop-blur-sm border-b border-zinc-700 px-4 lg:px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button
                onClick={() => setSidebarOpen(true)}
                className="lg:hidden p-2 hover:bg-zinc-700 rounded-lg transition-colors"
              >
                <Menu className="w-5 h-5" />
              </button>
              
              <div>
                <h2 className="text-xl font-semibold text-white">
                  {activeTabInfo?.label}
                </h2>
                <p className="text-sm text-zinc-400">
                  {activeTabInfo?.description}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <div className="text-sm text-zinc-400">
                Basketball Review App
              </div>
            </div>
          </div>
        </header>

        {/* Main Content */}
        <main className="flex-1 p-4 lg:p-6 overflow-auto">
          <div className="h-full">
            <ActiveComponent />
          </div>
        </main>
      </div>
    </div>
  );
};

export default BasketballReviewApp; 


=== ./src/types/api.types.ts ===
// API Response Types

export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    message: string;
    statusCode?: number;
    details?: any;
  };
  message?: string;
}

// Auth Types
export interface User {
  id: string;
  email: string;
  name: string;
}

export interface AuthData {
  user: User;
  token: string;
}

// Player Types
export interface Player {
  id: string;
  coachId: string;
  name: string;
  position?: string;
  height?: string;
  weight?: string;
  jerseyNumber?: number;
  profileImageUrl?: string;
  isActive: boolean;
  totalGamesPlayed: number;
  careerPoints: number;
  careerAssists: number;
  careerRebounds: number;
  careerSteals: number;
  careerBlocks: number;
  careerFouls: number;
  careerTurnovers: number;
  careerFgMade: number;
  careerFgAttempts: number;
  careerFtMade: number;
  careerFtAttempts: number;
  careerMinutesPlayed: number;
  createdAt: string;
  updatedAt: string;
}

// Team Types
export interface Team {
  id: string;
  coachId: string;
  name: string;
  description?: string;
  logoUrl?: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  players?: TeamPlayer[];
}

export interface TeamPlayer {
  id: string;
  teamId: string;
  playerId: string;
  coachId: string;
  isActive: boolean;
  dateJoined: string;
  createdAt: string;
  updatedAt: string;
}

// Game Types
export interface Game {
  id: string;
  coachId: string;
  homeTeamId: string;
  homeTeamName: string;
  awayTeamId?: string;
  awayTeamName: string;
  gameFormat: 'quarters' | 'halves';
  gameDate: string;
  homeTeamScore: number;
  awayTeamScore: number;
  totalDuration: number;
  isCompleted: boolean;
  notes?: string;
  periodScores: any[];
  createdAt: string;
  updatedAt: string;
}

// Stats Types
export interface GameStat {
  id: string;
  coachId: string;
  gameId: string;
  playerId: string;
  points: number;
  assists: number;
  offRebounds: number;
  defRebounds: number;
  steals: number;
  blocks: number;
  fouls: number;
  turnovers: number;
  fgMade: number;
  fgAttempts: number;
  ftMade: number;
  ftAttempts: number;
  minutesPlayed: number;
  plusMinus: number;
  startedOnCourt: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface GameEvent {
  id: string;
  coachId: string;
  gameId: string;
  playerId?: string;
  timestamp: string;
  gameTime?: number;
  period: number;
  periodTime: string;
  eventType: 'SCORE' | 'FOUL' | 'ASSIST' | 'REBOUND' | 'STEAL' | 'BLOCK' | 'TURNOVER' | 'SUBSTITUTION' | 'TIMEOUT' | 'PERIOD_END';
  eventDetail?: string;
  points?: number;
  teamId?: string;
  isHomeTeam?: boolean;
  homeTeamScore?: number;
  awayTeamScore?: number;
  notes?: string;
  createdAt: string;
  updatedAt: string;
}

// Upload Types
export interface UploadResponse {
  imageUrl?: string;
  logoUrl?: string;
  filename: string;
  size: number;
  mimetype: string;
}


=== ./src/types/game.types.ts ===
export interface PlayerStats {
  points: number;
  fouls: number;
  turnovers: number;
  offRebounds: number;
  defRebounds: number;
  assists: number;
  steals: number;
  blocks: number;
  fgMade: number;
  fgAttempts: number;
  ftMade: number;
  ftAttempts: number;
  plusMinus: number;
  timeOnCourt: number;
}

export interface Player {
  id: number;
  name: string;
  onCourt: boolean;
  profileImageUrl?: string;
  stats: PlayerStats;
  startTime: number | null;
}

export interface PeriodScore {
  period: number;
  periodLabel: string;
  teamScore: number;
  opponentScore: number;
  totalTeamScore: number;
  totalOpponentScore: number;
}

export type GameFormat = 'quarters' | 'halves';

export type StatType = keyof PlayerStats | 'fgMissed' | 'ftMissed'; 


=== ./src/utils/gameHelpers.ts ===
import type { Player, PeriodScore, GameFormat } from '../types/game.types';

/**
 * Create initial players with default stats
 */
export const createInitialPlayers = (): Player[] => {
  return Array.from({ length: 10 }, (_, index) => ({
    id: index + 1,
    name: `Player ${index + 1}`,
    onCourt: index < 5, // First 5 players start on court
    stats: {
      points: 0,
      fouls: 0,
      turnovers: 0,
      offRebounds: 0,
      defRebounds: 0,
      assists: 0,
      steals: 0,
      blocks: 0,
      fgMade: 0,
      fgAttempts: 0,
      ftMade: 0,
      ftAttempts: 0,
      plusMinus: 0,
      timeOnCourt: 0
    },
    startTime: index < 5 ? 0 : null
  }));
};

/**
 * Get period label based on format and period number
 */
export const getPeriodLabel = (period: number, format: GameFormat): string => {
  if (format === 'quarters') {
    return `Q${period}`;
  } else {
    return `Half ${period}`;
  }
};

/**
 * Get maximum periods for game format
 */
export const getMaxPeriods = (format: GameFormat): number => {
  return format === 'quarters' ? 4 : 2;
};

/**
 * Create a period score record
 */
export const createPeriodScore = (
  period: number,
  format: GameFormat,
  teamScore: number,
  opponentScore: number,
  periodStartTeamScore: number,
  periodStartOpponentScore: number
): PeriodScore => {
  return {
    period,
    periodLabel: getPeriodLabel(period, format),
    teamScore: teamScore - periodStartTeamScore,
    opponentScore: opponentScore - periodStartOpponentScore,
    totalTeamScore: teamScore,
    totalOpponentScore: opponentScore
  };
};

/**
 * Check if game is in overtime
 */
export const isOvertime = (period: number, format: GameFormat): boolean => {
  return period > getMaxPeriods(format);
};

/**
 * Get game status text
 */
export const getGameStatus = (period: number, format: GameFormat): string => {
  const maxPeriods = getMaxPeriods(format);
  
  if (period <= maxPeriods) {
    return getPeriodLabel(period, format);
  } else {
    const overtimeNumber = period - maxPeriods;
    return `OT${overtimeNumber > 1 ? overtimeNumber : ''}`;
  }
};

/**
 * Create automatic period scores when manual period data is unavailable
 */
export const createAutomaticPeriodScores = (
  finalTeamScore: number,
  finalOpponentScore: number,
  format: GameFormat
): PeriodScore[] => {
  const maxPeriods = getMaxPeriods(format);
  const periods: PeriodScore[] = [];
  
  // Distribute scores evenly across periods with some randomization
  const teamScorePerPeriod = Math.floor(finalTeamScore / maxPeriods);
  const opponentScorePerPeriod = Math.floor(finalOpponentScore / maxPeriods);
  
  // Calculate remainder to distribute
  const teamRemainder = finalTeamScore % maxPeriods;
  const opponentRemainder = finalOpponentScore % maxPeriods;
  
  let cumulativeTeamScore = 0;
  let cumulativeOpponentScore = 0;
  
  for (let period = 1; period <= maxPeriods; period++) {
    // Add base score per period
    let periodTeamScore = teamScorePerPeriod;
    let periodOpponentScore = opponentScorePerPeriod;
    
    // Distribute remainder points, giving preference to later periods
    if (teamRemainder > 0 && period > maxPeriods - teamRemainder) {
      periodTeamScore++;
    }
    if (opponentRemainder > 0 && period > maxPeriods - opponentRemainder) {
      periodOpponentScore++;
    }
    
    cumulativeTeamScore += periodTeamScore;
    cumulativeOpponentScore += periodOpponentScore;
    
    periods.push(createPeriodScore(
      period,
      format,
      cumulativeTeamScore,
      cumulativeOpponentScore,
      cumulativeTeamScore - periodTeamScore,
      cumulativeOpponentScore - periodOpponentScore
    ));
  }
  
  return periods;
}; 


=== ./src/utils/timeFormatters.ts ===
/**
 * Format seconds to MM:SS format
 */
export const formatTime = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
};

/**
 * Format seconds to a more readable format (e.g., "2m 30s")
 */
export const formatTimeReadable = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  
  if (mins === 0) {
    return `${secs}s`;
  }
  
  if (secs === 0) {
    return `${mins}m`;
  }
  
  return `${mins}m ${secs}s`;
};

/**
 * Convert MM:SS string back to seconds
 */
export const parseTimeToSeconds = (timeString: string): number => {
  const parts = timeString.split(':');
  if (parts.length !== 2) return 0;
  
  const mins = parseInt(parts[0], 10) || 0;
  const secs = parseInt(parts[1], 10) || 0;
  
  return mins * 60 + secs;
};

/**
 * Format time for game clock display (handles negative time)
 */
export const formatGameClock = (seconds: number): string => {
  const absSeconds = Math.abs(seconds);
  const formatted = formatTime(absSeconds);
  return seconds < 0 ? `-${formatted}` : formatted;
}; 


=== ./src/utils/exportUtils.ts ===
import type { Player } from '../types/game.types';
import { calculateFGPercentage, calculateFTPercentage, calculateTotalRebounds } from './statCalculations';
import { formatTime } from './timeFormatters';

export interface GameSummary {
  gameInfo: {
    teamName: string;
    opponentName: string;
    finalScore: string;
    gameDate: string;
    totalDuration: string;
  };
  players: Player[];
}

export const exportGameSummaryAsCSV = (gameSummary: GameSummary): void => {
  const { gameInfo, players } = gameSummary;
  
  // Create CSV headers
  const headers = [
    'Player Name',
    'Minutes',
    'Points',
    'Field Goals Made',
    'Field Goals Attempted',
    'FG%',
    'Free Throws Made',
    'Free Throws Attempted',
    'FT%',
    'Offensive Rebounds',
    'Defensive Rebounds',
    'Total Rebounds',
    'Assists',
    'Steals',
    'Blocks',
    'Turnovers',
    'Personal Fouls',
    'Plus/Minus'
  ];

  // Create CSV rows
  const rows = players.map(player => [
    player.name,
    formatTime(player.stats.timeOnCourt),
    player.stats.points.toString(),
    player.stats.fgMade.toString(),
    player.stats.fgAttempts.toString(),
    `${calculateFGPercentage(player.stats.fgMade, player.stats.fgAttempts)}%`,
    player.stats.ftMade.toString(),
    player.stats.ftAttempts.toString(),
    `${calculateFTPercentage(player.stats.ftMade, player.stats.ftAttempts)}%`,
    player.stats.offRebounds.toString(),
    player.stats.defRebounds.toString(),
    calculateTotalRebounds(player.stats.offRebounds, player.stats.defRebounds).toString(),
    player.stats.assists.toString(),
    player.stats.steals.toString(),
    player.stats.blocks.toString(),
    player.stats.turnovers.toString(),
    player.stats.fouls.toString(),
    (player.stats.plusMinus > 0 ? '+' : '') + player.stats.plusMinus.toString()
  ]);

  // Add game info header
  const gameInfoRows = [
    ['GAME SUMMARY'],
    ['Team', gameInfo.teamName],
    ['Opponent', gameInfo.opponentName],
    ['Final Score', gameInfo.finalScore],
    ['Game Date', gameInfo.gameDate],
    ['Duration', gameInfo.totalDuration],
    [''], // Empty row
    ['PLAYER STATISTICS'],
    headers
  ];

  // Combine all rows
  const allRows = [...gameInfoRows, ...rows];

  // Convert to CSV string
  const csvContent = allRows.map(row => 
    row.map(field => 
      // Escape fields that contain commas or quotes
      field.includes(',') || field.includes('"') 
        ? `"${field.replace(/"/g, '""')}"` 
        : field
    ).join(',')
  ).join('\n');

  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `${gameInfo.teamName}_vs_${gameInfo.opponentName}_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const exportGameSummaryAsJSON = (gameSummary: GameSummary): void => {
  const { gameInfo, players } = gameSummary;

  // Create enhanced data structure for JSON export
  const exportData = {
    gameInfo,
    teamStats: {
      totalPoints: players.reduce((sum, p) => sum + p.stats.points, 0),
      totalFouls: players.reduce((sum, p) => sum + p.stats.fouls, 0),
      totalAssists: players.reduce((sum, p) => sum + p.stats.assists, 0),
      totalRebounds: players.reduce((sum, p) => sum + calculateTotalRebounds(p.stats.offRebounds, p.stats.defRebounds), 0),
      totalSteals: players.reduce((sum, p) => sum + p.stats.steals, 0),
      totalBlocks: players.reduce((sum, p) => sum + p.stats.blocks, 0),
      totalTurnovers: players.reduce((sum, p) => sum + p.stats.turnovers, 0),
      teamFGMade: players.reduce((sum, p) => sum + p.stats.fgMade, 0),
      teamFGAttempts: players.reduce((sum, p) => sum + p.stats.fgAttempts, 0),
      teamFTMade: players.reduce((sum, p) => sum + p.stats.ftMade, 0),
      teamFTAttempts: players.reduce((sum, p) => sum + p.stats.ftAttempts, 0)
    },
    players: players.map(player => ({
      ...player,
      calculatedStats: {
        fgPercentage: calculateFGPercentage(player.stats.fgMade, player.stats.fgAttempts),
        ftPercentage: calculateFTPercentage(player.stats.ftMade, player.stats.ftAttempts),
        totalRebounds: calculateTotalRebounds(player.stats.offRebounds, player.stats.defRebounds),
        formattedTime: formatTime(player.stats.timeOnCourt)
      }
    })),
    exportInfo: {
      exportedAt: new Date().toISOString(),
      exportedBy: 'Basketball Review App',
      version: '1.0'
    }
  };

  // Convert to JSON string
  const jsonContent = JSON.stringify(exportData, null, 2);

  // Create and download file
  const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `${gameInfo.teamName}_vs_${gameInfo.opponentName}_${new Date().toISOString().split('T')[0]}.json`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const generateGameSummary = (
  teamName: string,
  opponentName: string,
  teamScore: number,
  opponentScore: number,
  players: Player[],
  gameDate?: Date,
  totalDuration?: number
): GameSummary => {
  return {
    gameInfo: {
      teamName,
      opponentName,
      finalScore: `${teamScore} - ${opponentScore}`,
      gameDate: gameDate ? gameDate.toLocaleDateString() : new Date().toLocaleDateString(),
      totalDuration: totalDuration ? formatTime(totalDuration) : 'N/A'
    },
    players
  };
};


=== ./src/utils/imageUtils.ts ===
/**
 * Image utility functions for resizing and optimizing images before upload
 */

export interface ImageResizeOptions {
  maxWidth?: number;
  maxHeight?: number;
  quality?: number;
  format?: 'image/jpeg' | 'image/png' | 'image/webp';
}

/**
 * Resize an image file to specified dimensions while maintaining aspect ratio
 * @param file - The original image file
 * @param options - Resize options
 * @returns Promise<File> - The resized image file
 */
export const resizeImage = async (
  file: File,
  options: ImageResizeOptions = {}
): Promise<File> => {
  const {
    maxWidth = 800,
    maxHeight = 800,
    quality = 0.8,
    format = 'image/jpeg'
  } = options;

  return new Promise((resolve, reject) => {
    // Create image element
    const img = new Image();
    
    img.onload = () => {
      // Calculate new dimensions while maintaining aspect ratio
      let { width, height } = img;
      
      if (width > height) {
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
      } else {
        if (height > maxHeight) {
          width = (width * maxHeight) / height;
          height = maxHeight;
        }
      }

      // Create canvas for resizing
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        reject(new Error('Failed to get canvas context'));
        return;
      }

      // Set canvas dimensions
      canvas.width = width;
      canvas.height = height;

      // Draw and resize image
      ctx.drawImage(img, 0, 0, width, height);

      // Convert canvas to blob
      canvas.toBlob(
        (blob) => {
          if (!blob) {
            reject(new Error('Failed to create blob from canvas'));
            return;
          }

          // Create new file with same name but potentially different extension
          const fileExtension = format.split('/')[1];
          const originalName = file.name.split('.')[0];
          const newFileName = `${originalName}_resized.${fileExtension}`;

          const resizedFile = new File([blob], newFileName, {
            type: format,
            lastModified: Date.now(),
          });

          resolve(resizedFile);
        },
        format,
        quality
      );
    };

    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };

    // Load the image
    img.src = URL.createObjectURL(file);
  });
};

/**
 * Get image dimensions from a file
 * @param file - The image file
 * @returns Promise with width and height
 */
export const getImageDimensions = (file: File): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
      URL.revokeObjectURL(img.src);
    };

    img.onerror = () => {
      reject(new Error('Failed to load image'));
      URL.revokeObjectURL(img.src);
    };

    img.src = URL.createObjectURL(file);
  });
};

/**
 * Format file size in human readable format
 * @param bytes - File size in bytes
 * @returns Formatted string
 */
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

/**
 * Validate if file is an image and within size limits
 * @param file - File to validate
 * @param maxSizeInMB - Maximum file size in MB
 * @returns Validation result
 */
export const validateImageFile = (file: File, maxSizeInMB: number = 10) => {
  const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
  const maxSizeInBytes = maxSizeInMB * 1024 * 1024;

  if (!validTypes.includes(file.type)) {
    return {
      isValid: false,
      error: 'Please select a valid image file (JPEG, PNG, WebP, or GIF)'
    };
  }

  if (file.size > maxSizeInBytes) {
    return {
      isValid: false,
      error: `File size must be less than ${maxSizeInMB}MB. Current size: ${formatFileSize(file.size)}`
    };
  }

  return { isValid: true };
};

/**
 * Profile image specific resizing with optimized settings
 * @param file - Original image file
 * @returns Promise<File> - Optimized profile image
 */
export const resizeProfileImage = async (file: File): Promise<File> => {
  // Profile images: square, high quality, but reasonable size
  return resizeImage(file, {
    maxWidth: 400,
    maxHeight: 400,
    quality: 0.85,
    format: 'image/jpeg'
  });
};


=== ./src/utils/statCalculations.ts ===
import type { Player } from '../types/game.types';

/**
 * Calculate field goal percentage
 */
export const calculateFGPercentage = (made: number, attempts: number): string => {
  if (attempts === 0) return '0.0';
  return ((made / attempts) * 100).toFixed(1);
};

/**
 * Calculate free throw percentage
 */
export const calculateFTPercentage = (made: number, attempts: number): string => {
  if (attempts === 0) return '0.0';
  return ((made / attempts) * 100).toFixed(1);
};

/**
 * Calculate total rebounds for a player
 */
export const calculateTotalRebounds = (offRebounds: number, defRebounds: number): number => {
  return offRebounds + defRebounds;
};

/**
 * Calculate team fouls from all players
 */
export const calculateTeamFouls = (players: Player[]): number => {
  return players.reduce((total, player) => total + player.stats.fouls, 0);
};

/**
 * Calculate team points from all players
 */
export const calculateTeamPoints = (players: Player[]): number => {
  return players.reduce((total, player) => total + player.stats.points, 0);
};

/**
 * Get players currently on court
 */
export const getPlayersOnCourt = (players: Player[]): Player[] => {
  return players.filter(player => player.onCourt);
};

/**
 * Get players currently on bench
 */
export const getPlayersOnBench = (players: Player[]): Player[] => {
  return players.filter(player => !player.onCourt);
};

/**
 * Validate if substitution is allowed (max 5 players on court)
 */
export const canMakeSubstitution = (players: Player[], playerInId: number): boolean => {
  const playersOnCourt = getPlayersOnCourt(players);
  const playerIn = players.find(p => p.id === playerInId);
  
  if (!playerIn || playerIn.onCourt) return false;
  
  return playersOnCourt.length >= 1; // Need at least 1 player on court to substitute
};

/**
 * Calculate efficiency rating (simplified version)
 */
export const calculatePlayerEfficiency = (player: Player): number => {
  const stats = player.stats;
  return stats.points + stats.assists + calculateTotalRebounds(stats.offRebounds, stats.defRebounds) 
         + stats.steals + stats.blocks - stats.turnovers - stats.fouls;
}; 


=== ./src/index.css ===
@import 'tailwindcss';

/* Custom scrollbar styles */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #1e293b;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #475569;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

/* Global scrollbar for the main content */
* {
  scrollbar-width: thin;
  scrollbar-color: #475569 #1e293b;
}

*::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

*::-webkit-scrollbar-track {
  background: #0f172a;
  border-radius: 4px;
}

*::-webkit-scrollbar-thumb {
  background: #475569;
  border-radius: 4px;
}

*::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

/* Smooth transitions for all elements */
* {
  transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}

/* Enhanced focus states */
button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible {
  outline: 2px solid #eab308;
  outline-offset: 2px;
}

/* Improved text selection */
::selection {
  background-color: #eab308;
  color: #000000;
}

/* Custom animations */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fade-in-up {
  animation: fadeInUp 0.3s ease-out;
}

/* Border gradient animation */
@keyframes borderPulse {
  0%, 100% {
    border-color: #475569;
  }
  50% {
    border-color: #eab308;
  }
}

.border-pulse {
  animation: borderPulse 2s ease-in-out infinite;
}

/* Glass effect for modern UI */
.glass {
  background: rgba(30, 41, 59, 0.7);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Smooth hover transitions for cards */
.hover-lift {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.hover-lift:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
} 


=== ./src/setupTests.ts ===
import '@testing-library/jest-dom';

// Mock image elements
Object.defineProperty(HTMLImageElement.prototype, 'naturalHeight', {
  get: function() {
    return 100;
  },
});

Object.defineProperty(HTMLImageElement.prototype, 'naturalWidth', {
  get: function() {
    return 100;
  },
});

// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn(() => 'mock-url');
global.URL.revokeObjectURL = jest.fn();

// Mock canvas for image thumbnail generation
HTMLCanvasElement.prototype.getContext = jest.fn();

// Mock FileReader
const mockFileReader = {
  result: null,
  onload: null,
  readAsDataURL: jest.fn(function(this: any) {
    this.result = 'data:image/jpeg;base64,mock-base64-data';
    if (this.onload) {
      this.onload();
    }
  })
};

(global as any).FileReader = jest.fn(() => mockFileReader);

// Global test configuration
if (typeof window !== 'undefined') {
  // Additional test setup can go here
}


=== ./src/components/ui/Button.tsx ===
import React from 'react';
import type { ButtonHTMLAttributes } from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'indigo';
  size?: 'small' | 'medium' | 'large';
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'secondary',
  size = 'medium',
  className = '',
  ...props
}) => {
  const baseClasses = 'px-4 py-2 rounded-lg font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed';

  const variantClasses = {
    primary: 'bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-black shadow-lg hover:shadow-xl transform hover:scale-105',
    secondary: 'bg-zinc-700 hover:bg-zinc-600 text-white',
    success: 'bg-emerald-600 hover:bg-emerald-700 text-white',
    danger: 'bg-red-600 hover:bg-red-700 text-white',
    warning: 'bg-amber-600 hover:bg-amber-700 text-white',
    info: 'bg-cyan-600 hover:bg-cyan-700 text-white',
    indigo: 'bg-indigo-600 hover:bg-indigo-700 text-white',
  };

  const sizeClasses = {
    small: 'px-2 py-1 text-sm',
    medium: 'px-4 py-2 text-base',
    large: 'px-6 py-3 text-lg',
  };
  const classes = `${sizeClasses[size]} ${variantClasses[variant]} ${className}`;

  return (
    <button className={classes} {...props}>
      {children}
    </button>
  );
};

export default Button; 


=== ./src/components/MyTeams/MyTeams.tsx ===
import React, { useState } from 'react';
import { Users, ChevronDown, ChevronRight, Settings, UserPlus, FolderPlus, Trophy } from 'lucide-react';
import { useTeamManagement, type Team, type PlayerWithTeam } from '../../hooks/useTeamManagement';
import { TeamCreationModal } from '../TeamManagement/TeamCreationModal';
import { TeamCard } from '../TeamManagement/TeamCard';
import { PlayerTeamAssignmentModal } from '../TeamManagement/PlayerTeamAssignmentModal';
import { PlayerImage } from '../PlayerProfiles/PlayerImage';

interface MyTeamsProps {
  // Props can be added here as needed
}

export const MyTeams: React.FC<MyTeamsProps> = () => {
  const teamManagement = useTeamManagement();
  
  // UI State
  const [showTeamCreationModal, setShowTeamCreationModal] = useState(false);
  const [showPlayerAssignmentModal, setShowPlayerAssignmentModal] = useState(false);
  const [selectedPlayerForAssignment, setSelectedPlayerForAssignment] = useState<PlayerWithTeam | null>(null);
  const [expandedTeams, setExpandedTeams] = useState<Set<string>>(new Set());
  const [viewMode, setViewMode] = useState<'cards' | 'list'>('cards');

  // Team operations
  const handleCreateTeam = async (name: string, description?: string, logoUrl?: string): Promise<boolean> => {
    const result = await teamManagement.createTeam(name, description, logoUrl);
    return result !== null;
  };

  const handleDeleteTeam = (teamId: string) => {
    teamManagement.deleteTeam(teamId);
  };

  const handleEditTeam = (team: Team) => {
    // TODO: Implement team editing modal
    console.log('Edit team:', team);
  };

  const handlePlayerAssignment = (player: PlayerWithTeam) => {
    setSelectedPlayerForAssignment(player);
    setShowPlayerAssignmentModal(true);
  };

  const toggleTeamExpansion = (teamId: string) => {
    setExpandedTeams(prev => {
      const newSet = new Set(prev);
      if (newSet.has(teamId)) {
        newSet.delete(teamId);
      } else {
        newSet.add(teamId);
      }
      return newSet;
    });
  };

  if (teamManagement.loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-400 mx-auto mb-4"></div>
          <p className="text-zinc-400">Loading teams...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col space-y-6">
      {/* Header */}
      <div className="bg-gradient-to-r from-zinc-900 to-zinc-800 rounded-xl p-6 border border-zinc-700">
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div>
            <h2 className="text-3xl font-bold text-yellow-400 flex items-center gap-3 mb-2">
              <Trophy className="w-8 h-8" />
              My Teams
            </h2>
            <p className="text-zinc-300">Create and manage your basketball teams</p>
            <div className="mt-3 flex items-center gap-6 text-sm text-zinc-400">
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-yellow-400 rounded-full"></div>
                Total Teams: {teamManagement.teams.length}
              </span>
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-blue-400 rounded-full"></div>
                Assigned Players: {teamManagement.players.filter(p => p.teams.length > 0).length}
              </span>
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-emerald-400 rounded-full"></div>
                Total Members: {teamManagement.players.reduce((sum, player) => sum + player.teams.length, 0)}
              </span>
            </div>
          </div>
          
          <div className="flex items-center gap-3">
            {/* View Mode Toggle */}
            <div className="flex bg-zinc-800 rounded-lg border border-zinc-700 p-1">
              <button
                onClick={() => setViewMode('cards')}
                className={`px-3 py-2 rounded-md text-sm font-medium transition-all ${
                  viewMode === 'cards'
                    ? 'bg-yellow-500 text-black'
                    : 'text-zinc-400 hover:text-white'
                }`}
              >
                Cards
              </button>
              <button
                onClick={() => setViewMode('list')}
                className={`px-3 py-2 rounded-md text-sm font-medium transition-all ${
                  viewMode === 'list'
                    ? 'bg-yellow-500 text-black'
                    : 'text-zinc-400 hover:text-white'
                }`}
              >
                List
              </button>
            </div>

            <button
              onClick={() => setShowTeamCreationModal(true)}
              className="bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 px-4 py-3 rounded-xl font-semibold text-black transition-all transform hover:scale-105 shadow-lg flex items-center gap-2"
            >
              <FolderPlus className="w-5 h-5" />
              Create Team
            </button>
          </div>
        </div>
      </div>

      {/* Content Area */}
      {teamManagement.teams.length === 0 ? (
        // Empty State
        <div className="text-center py-16">
          <div className="p-4 bg-zinc-800 rounded-full w-24 h-24 mx-auto mb-6 flex items-center justify-center">
            <Trophy className="w-12 h-12 text-zinc-600" />
          </div>
          <h3 className="text-xl font-semibold text-white mb-2">No Teams Created</h3>
          <p className="text-zinc-400 mb-6 max-w-md mx-auto">
            Create your first team to start organizing players and managing games. Teams help you organize players for different age groups, skill levels, or leagues.
          </p>
          <button
            onClick={() => setShowTeamCreationModal(true)}
            className="bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 px-6 py-3 rounded-xl font-semibold text-black transition-all transform hover:scale-105 shadow-lg flex items-center gap-2 mx-auto"
          >
            <FolderPlus className="w-5 h-5" />
            Create Your First Team
          </button>
        </div>
      ) : viewMode === 'cards' ? (
        // Cards View
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {teamManagement.teams.map(team => (
            <TeamCard
              key={team.id}
              team={team}
              onSelect={teamManagement.setSelectedTeamId}
              onEdit={handleEditTeam}
              onDelete={handleDeleteTeam}
              isSelected={teamManagement.selectedTeamId === team.id}
            />
          ))}
        </div>
      ) : (
        // List View - Teams with Players
        <div className="space-y-4">
          {teamManagement.teams.map(team => {
            const teamPlayers = teamManagement.getTeamPlayers(team.id);
            const isExpanded = expandedTeams.has(team.id);

            return (
              <div key={team.id} className="bg-zinc-900 rounded-xl border border-zinc-700">
                {/* Team Header */}
                <div 
                  onClick={() => toggleTeamExpansion(team.id)}
                  className="flex items-center justify-between p-6 cursor-pointer hover:bg-zinc-800/50 transition-colors"
                >
                  <div className="flex items-center gap-4">
                    {isExpanded ? (
                      <ChevronDown className="w-5 h-5 text-zinc-400" />
                    ) : (
                      <ChevronRight className="w-5 h-5 text-zinc-400" />
                    )}
                    <div className="w-12 h-12 rounded-lg overflow-hidden bg-zinc-700 flex items-center justify-center border border-zinc-600">
                      {team.logoUrl ? (
                        <img
                          src={team.logoUrl}
                          alt={`${team.name} logo`}
                          className="w-full h-full object-cover"
                          onError={(e) => {
                            console.error(` Image error for team logo: ${team.logoUrl}`);
                            e.currentTarget.style.display = 'none';
                          }}
                        />
                      ) : (
                        <Trophy className="w-6 h-6 text-yellow-400" />
                      )}
                    </div>
                    <div>
                      <h3 className="text-xl font-bold text-white">{team.name}</h3>
                      <p className="text-sm text-zinc-400">
                        {teamPlayers.length} players  {team.description || 'No description'}
                      </p>
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-3">
                    <div className="text-sm text-zinc-400">
                      Click to {isExpanded ? 'collapse' : 'expand'}
                    </div>
                  </div>
                </div>

                {/* Team Players */}
                {isExpanded && (
                  <div className="px-6 pb-6 border-t border-zinc-700">
                    <div className="pt-6">
                      <div className="flex items-center justify-between mb-4">
                        <h4 className="text-lg font-semibold text-white">Team Roster</h4>
                        <span className="text-sm text-zinc-400">{teamPlayers.length} players</span>
                      </div>
                      
                      {teamPlayers.length === 0 ? (
                        <div className="text-center py-8 border-2 border-dashed border-zinc-700 rounded-lg">
                          <UserPlus className="w-8 h-8 mx-auto mb-3 text-zinc-600" />
                          <p className="text-zinc-400 mb-2">No players assigned to this team</p>
                          <p className="text-sm text-zinc-500">Go to the Players tab to assign players to this team</p>
                        </div>
                      ) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                          {teamPlayers.map(player => (
                            <div
                              key={player.id}
                              className="bg-zinc-800 rounded-lg p-4 border border-zinc-700 hover:border-zinc-600 transition-colors"
                            >
                              <div className="flex items-center gap-3">
                                <div className="w-12 h-12 rounded-full overflow-hidden bg-zinc-700 flex items-center justify-center">
                                  {player.profileImageUrl ? (
                                    <PlayerImage 
                                      profileImageUrl={player.profileImageUrl} 
                                      className="w-12 h-12 rounded-full object-cover"
                                      alt={player.name}
                                    />
                                  ) : (
                                    <Users className="w-6 h-6 text-zinc-400" />
                                  )}
                                </div>
                                <div className="flex-1 min-w-0">
                                  <h5 className="font-medium text-white truncate">{player.name}</h5>
                                  <p className="text-sm text-zinc-400">{player.position || 'No position'}</p>
                                </div>
                              </div>
                              
                              <button
                                onClick={() => handlePlayerAssignment(player)}
                                className="mt-3 w-full bg-zinc-700 hover:bg-zinc-600 text-white text-sm px-3 py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
                              >
                                <Settings className="w-4 h-4" />
                                Manage Teams
                              </button>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}

      {/* Modals */}
      <TeamCreationModal
        isOpen={showTeamCreationModal}
        onClose={() => setShowTeamCreationModal(false)}
        onCreateTeam={handleCreateTeam}
      />

      <PlayerTeamAssignmentModal
        isOpen={showPlayerAssignmentModal}
        onClose={() => setShowPlayerAssignmentModal(false)}
        player={selectedPlayerForAssignment}
        teams={teamManagement.teams}
        onAssignPlayerToTeam={teamManagement.assignPlayerToTeam}
        onRemovePlayerFromTeam={teamManagement.removePlayerFromTeam}
      />
    </div>
  );
}; 


=== ./src/components/GameClock/GameClock.tsx ===
import React from 'react';
import { Clock } from 'lucide-react';
import Button from '../ui/Button';

interface GameClockProps {
  gameClock: number;
  isClockRunning: boolean;
  currentPeriod: number;
  gameFormat: 'quarters' | 'halves';
  onClockToggle: () => void;
  onPeriodChange: (period: number) => void;
  onEndPeriod: () => void;
}

export const GameClock: React.FC<GameClockProps> = ({
  gameClock,
  isClockRunning,
  currentPeriod,
  gameFormat,
  onClockToggle,
  onPeriodChange,
  onEndPeriod,
}) => {
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const getPeriodLabel = () => {
    if (gameFormat === 'quarters') {
      return `Q${currentPeriod}`;
    } else {
      return `Half ${currentPeriod}`;
    }
  };

  const getMaxPeriods = () => {
    return gameFormat === 'quarters' ? 4 : 2;
  };

  return (
    <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-600">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold flex items-center gap-2 text-yellow-400">
          <Clock className="w-5 h-5" />
          Game Clock - {getPeriodLabel()}
        </h3>
        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2">
            <Button
              onClick={() => onPeriodChange(Math.max(1, currentPeriod - 1))}
              variant="secondary"
              className="px-2 py-1 text-sm"
              disabled={currentPeriod === 1}
            >
              -
            </Button>
            <span className="text-lg font-semibold text-yellow-400">{getPeriodLabel()}</span>
            <Button
              onClick={() => onPeriodChange(Math.min(getMaxPeriods(), currentPeriod + 1))}
              variant="secondary"
              className="px-2 py-1 text-sm"
              disabled={currentPeriod === getMaxPeriods()}
            >
              +
            </Button>
          </div>
          <span className="text-2xl font-mono text-yellow-400">{formatTime(gameClock)}</span>
          <Button
            onClick={onClockToggle}
            variant={isClockRunning ? 'danger' : 'success'}
            className="px-4 py-2"
          >
            {isClockRunning ? 'Stop' : 'Start'}
          </Button>
        </div>
      </div>
      
      <div className="flex justify-center">
        <Button
          onClick={onEndPeriod}
          variant="warning"
          className="px-4 py-2 font-semibold"
        >
          End {gameFormat === 'quarters' ? 'Quarter' : 'Half'}
        </Button>
      </div>
    </div>
  );
}; 


=== ./src/components/GameClock/index.ts ===
export { GameClock } from './GameClock'; 


=== ./src/components/LandingPage.tsx ===
import React from 'react';
import { Play, Trophy, Users, BarChart3, ArrowRight, Star, Shield, Zap } from 'lucide-react';

interface LandingPageProps {
  onEnterApp: () => void;
}

const LandingPage: React.FC<LandingPageProps> = ({ onEnterApp }) => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-zinc-900 via-zinc-800 to-zinc-900 text-white">
      {/* Header */}
      <header className="relative z-10 px-6 py-8">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-xl">
              <Trophy className="w-8 h-8 text-black" />
            </div>
            <div>
              <h1 className="text-2xl font-bold text-white">Basketball Pro</h1>
              <p className="text-sm text-zinc-400">Game Management Platform</p>
            </div>
          </div>
          <button
            onClick={onEnterApp}
            className="hidden md:flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-yellow-500 to-yellow-600 text-black font-semibold rounded-xl hover:from-yellow-400 hover:to-yellow-500 transition-all duration-200 shadow-lg hover:shadow-yellow-500/25"
          >
            Enter App
            <ArrowRight className="w-5 h-5" />
          </button>
        </div>
      </header>

      {/* Hero Section */}
      <main className="relative z-10 px-6 py-16">
        <div className="max-w-7xl mx-auto">
          {/* Hero Content */}
          <div className="text-center mb-16">
            <h2 className="text-5xl md:text-7xl font-bold mb-6 bg-gradient-to-r from-white via-yellow-200 to-yellow-400 bg-clip-text text-transparent">
              Elevate Your Game
            </h2>
            <p className="text-xl md:text-2xl text-zinc-300 mb-8 max-w-3xl mx-auto leading-relaxed">
              Professional basketball team management platform. Track players, manage teams, analyze games, and review performance like never before.
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center items-center">
              <button
                onClick={onEnterApp}
                className="flex items-center gap-3 px-8 py-4 bg-gradient-to-r from-yellow-500 to-yellow-600 text-black font-bold rounded-xl hover:from-yellow-400 hover:to-yellow-500 transition-all duration-200 shadow-lg hover:shadow-yellow-500/25 text-lg"
              >
                <Play className="w-6 h-6" />
                Start Managing Your Team
              </button>
              <div className="flex items-center gap-2 text-zinc-400">
                <Star className="w-5 h-5 text-yellow-400" />
                <span>No setup required  Free to start</span>
              </div>
            </div>
          </div>

          {/* Features Grid */}
          <div className="grid md:grid-cols-3 gap-8 mb-16">
            <div className="group p-8 bg-zinc-800/50 rounded-2xl border border-zinc-700 hover:border-yellow-500/50 transition-all duration-300 hover:bg-zinc-800/80">
              <div className="p-3 bg-gradient-to-br from-blue-500/20 to-blue-600/20 rounded-xl w-fit mb-6 group-hover:from-blue-500/30 group-hover:to-blue-600/30 transition-all duration-300">
                <Users className="w-8 h-8 text-blue-400" />
              </div>
              <h3 className="text-2xl font-bold mb-4 text-white">Player Management</h3>
              <p className="text-zinc-300 leading-relaxed">
                Create comprehensive player profiles with photos, stats, and career tracking. Monitor performance and development over time.
              </p>
            </div>

            <div className="group p-8 bg-zinc-800/50 rounded-2xl border border-zinc-700 hover:border-yellow-500/50 transition-all duration-300 hover:bg-zinc-800/80">
              <div className="p-3 bg-gradient-to-br from-green-500/20 to-green-600/20 rounded-xl w-fit mb-6 group-hover:from-green-500/30 group-hover:to-green-600/30 transition-all duration-300">
                <Trophy className="w-8 h-8 text-green-400" />
              </div>
              <h3 className="text-2xl font-bold mb-4 text-white">Team Organization</h3>
              <p className="text-zinc-300 leading-relaxed">
                Build and manage multiple teams with custom rosters, team logos, and organizational structure for leagues and tournaments.
              </p>
            </div>

            <div className="group p-8 bg-zinc-800/50 rounded-2xl border border-zinc-700 hover:border-yellow-500/50 transition-all duration-300 hover:bg-zinc-800/80">
              <div className="p-3 bg-gradient-to-br from-purple-500/20 to-purple-600/20 rounded-xl w-fit mb-6 group-hover:from-purple-500/30 group-hover:to-purple-600/30 transition-all duration-300">
                <BarChart3 className="w-8 h-8 text-purple-400" />
              </div>
              <h3 className="text-2xl font-bold mb-4 text-white">Game Analytics</h3>
              <p className="text-zinc-300 leading-relaxed">
                Real-time game tracking with live scoring, player statistics, and detailed performance analytics to improve your team's game.
              </p>
            </div>
          </div>

          {/* Benefits */}
          <div className="bg-gradient-to-r from-zinc-800/50 to-zinc-700/50 rounded-2xl p-12 border border-zinc-600">
            <h3 className="text-3xl font-bold text-center mb-12 text-white">Why Choose Basketball Pro?</h3>
            <div className="grid md:grid-cols-3 gap-8">
              <div className="flex items-start gap-4">
                <div className="p-2 bg-gradient-to-br from-yellow-500/20 to-yellow-600/20 rounded-lg">
                  <Shield className="w-6 h-6 text-yellow-400" />
                </div>
                <div>
                  <h4 className="text-xl font-semibold mb-2 text-white">Secure & Reliable</h4>
                  <p className="text-zinc-300">Enterprise-grade security with AWS infrastructure ensuring your data is always safe and accessible.</p>
                </div>
              </div>
              <div className="flex items-start gap-4">
                <div className="p-2 bg-gradient-to-br from-blue-500/20 to-blue-600/20 rounded-lg">
                  <Zap className="w-6 h-6 text-blue-400" />
                </div>
                <div>
                  <h4 className="text-xl font-semibold mb-2 text-white">Lightning Fast</h4>
                  <p className="text-zinc-300">Built on modern technology stack for instant response times and seamless user experience.</p>
                </div>
              </div>
              <div className="flex items-start gap-4">
                <div className="p-2 bg-gradient-to-br from-green-500/20 to-green-600/20 rounded-lg">
                  <Users className="w-6 h-6 text-green-400" />
                </div>
                <div>
                  <h4 className="text-xl font-semibold mb-2 text-white">Team Focused</h4>
                  <p className="text-zinc-300">Designed specifically for basketball teams with features that matter most to coaches and players.</p>
                </div>
              </div>
            </div>
          </div>

          {/* Call to Action */}
          <div className="text-center mt-16">
            <h3 className="text-3xl font-bold mb-4 text-white">Ready to Transform Your Team?</h3>
            <p className="text-xl text-zinc-300 mb-8 max-w-2xl mx-auto">
              Join basketball teams worldwide who are already using Basketball Pro to elevate their game management and performance.
            </p>
            <button
              onClick={onEnterApp}
              className="flex items-center gap-3 px-10 py-5 bg-gradient-to-r from-yellow-500 to-yellow-600 text-black font-bold rounded-xl hover:from-yellow-400 hover:to-yellow-500 transition-all duration-200 shadow-lg hover:shadow-yellow-500/25 text-lg mx-auto"
            >
              <Play className="w-6 h-6" />
              Get Started Now
              <ArrowRight className="w-6 h-6" />
            </button>
          </div>
        </div>
      </main>

      {/* Background Elements */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-20 left-10 w-72 h-72 bg-yellow-500/5 rounded-full blur-3xl"></div>
        <div className="absolute bottom-20 right-10 w-96 h-96 bg-blue-500/5 rounded-full blur-3xl"></div>
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-to-r from-yellow-500/3 to-blue-500/3 rounded-full blur-3xl"></div>
      </div>
    </div>
  );
};

export default LandingPage; 


=== ./src/components/ScoreBoard/ScoreBoard.tsx ===
import React from 'react';
import { Timer } from 'lucide-react';
import Button from '../ui/Button';

interface ScoreBoardProps {
  teamName: string;
  opponentName: string;
  teamScore: number;
  opponentScore: number;
  teamFouls: number;
  teamTimeouts: number;
  opponentTimeouts: number;
  onOpponentScore: (points: number) => void;
  onTeamTimeout: () => void;
  onOpponentTimeout: () => void;
}

export const ScoreBoard: React.FC<ScoreBoardProps> = ({
  teamName,
  opponentName,
  teamScore,
  opponentScore,
  teamFouls,
  teamTimeouts,
  onOpponentScore,
  onTeamTimeout,
  onOpponentTimeout,
}) => {
  return (
    <div className="bg-zinc-800 rounded-lg p-4 mb-4 border border-zinc-600">
      <div className="text-center text-3xl font-bold mb-2">
        <span className="text-white">{teamName}: {teamScore}</span>
        <span className="mx-3 text-zinc-400">-</span>
        <span className="text-white">{opponentName}: {opponentScore}</span>
      </div>
      
      <div className="flex justify-center items-center gap-4 mb-2">
        <div className="text-sm">
          <span className="text-zinc-400">Team Fouls:</span>
          <span className="ml-2 font-semibold text-amber-400">{teamFouls}</span>
        </div>
        <div className="text-sm">
          <span className="text-zinc-400">Timeouts:</span>
          <span className="ml-2 font-semibold text-yellow-400">{teamTimeouts}</span>
        </div>
      </div>
      
      <div className="flex justify-center gap-2 mb-4">
        <Button variant="primary" className="px-6 py-3 font-bold" onClick={() => onOpponentScore(1)}>
          {opponentName} +1
        </Button>
        <Button variant="primary" className="px-6 py-3 font-bold" onClick={() => onOpponentScore(2)}>
          {opponentName} +2
        </Button>
        <Button variant="primary" className="px-6 py-3 font-bold" onClick={() => onOpponentScore(3)}>
          {opponentName} +3
        </Button>
      </div>

      {/* Timeout buttons */}
      <div className="grid grid-cols-2 gap-2">
        <Button variant="secondary" className="p-2 text-sm flex items-center justify-center gap-2" onClick={onTeamTimeout}>
          <Timer className="w-4 h-4" />
          {teamName} Timeout
        </Button>
        <Button variant="secondary" className="p-2 text-sm flex items-center justify-center gap-2" onClick={onOpponentTimeout}>
          <Timer className="w-4 h-4" />
          {opponentName} Timeout
        </Button>
      </div>
    </div>
  );
}; 


=== ./src/components/ScoreBoard/index.ts ===
export { ScoreBoard } from './ScoreBoard'; 


=== ./src/components/PlayerProfiles/PlayerImage.tsx ===
import React, { useState } from 'react';
import { User } from 'lucide-react';
import { api } from '../../services/api';

interface PlayerImageProps {
  profileImageUrl: string | null | undefined;
  className: string;
  alt: string;
}

const PlayerImageComponent: React.FC<PlayerImageProps> = ({ profileImageUrl, className, alt }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  // Convert mock URLs to actual data URLs
  const imageUrl = api.getMockImageUrl(profileImageUrl);

  // If no profile image, show default avatar
  if (!imageUrl) {
    return (
      <div className={`${className} flex items-center justify-center bg-zinc-800`}>
        <User className="w-1/3 h-1/3 text-zinc-500" />
      </div>
    );
  }

  // Handle image load error
  if (hasError) {
    return (
      <div className={`${className} flex items-center justify-center bg-zinc-800`}>
        <User className="w-1/3 h-1/3 text-zinc-500" />
      </div>
    );
  }

  return (
    <div className={`${className} relative`}>
      {isLoading && (
        <div className={`${className} absolute inset-0 animate-pulse bg-zinc-700/50 flex items-center justify-center`}>
          <User className="w-1/4 h-1/4 text-zinc-500/50" />
        </div>
      )}
      <img
        src={imageUrl}
        alt={alt}
        className={`${className} object-cover ${isLoading ? 'opacity-0' : 'opacity-100'}`}
        onLoad={() => setIsLoading(false)}
        onError={() => {
          setIsLoading(false);
          setHasError(true);
        }}
      />
    </div>
  );
};

PlayerImageComponent.displayName = 'PlayerImage';

export const PlayerImage = PlayerImageComponent;


=== ./src/components/PlayerProfiles/PlayerDetail.tsx ===
import React, { useState, useEffect } from 'react';
import { ArrowLeft, Trophy, TrendingUp, Calendar, BarChart3, Clock, Star, Activity } from 'lucide-react';
import { PlayerImage } from './PlayerImage';
import { api } from '../../services/api';

interface PlayerDetailProps {
  player: any; // Player data passed from parent
  onBack: () => void;
}

export const PlayerDetail: React.FC<PlayerDetailProps> = ({ player, onBack }) => {
  const [gameStats, setGameStats] = useState<any[]>([]);
  const [, setLoading] = useState(true);

  useEffect(() => {
    fetchGameStats();
  }, [player.id]);

  const fetchGameStats = async () => {
    try {
      setLoading(true);
      
      // Fetch all games and filter for this player's stats
      const gamesResult = await api.games.list();
      if (gamesResult.success && gamesResult.data) {
        // Filter games where this player has stats
        const playerGames = gamesResult.data
          .filter((game: any) => game.playerStats && game.playerStats[player.id])
          .map((game: any) => ({
            ...game.playerStats[player.id],
            gameId: game.id,
            gameDate: game.createdAt,
            opponent: game.opponent
          }));
        setGameStats(playerGames);
      }
      
    } catch (error) {
      console.error('Error fetching game stats:', error);
    } finally {
      setLoading(false);
    }
  };


  const calculateAverages = () => {
    if (!player || gameStats.length === 0) return null;
    
    const totalGames = gameStats.length;
    const totals = gameStats.reduce((acc, game) => ({
      points: acc.points + (game.points || 0),
      assists: acc.assists + (game.assists || 0),
      rebounds: acc.rebounds + (game.offRebounds || 0) + (game.defRebounds || 0),
      steals: acc.steals + (game.steals || 0),
      blocks: acc.blocks + (game.blocks || 0),
      fgMade: acc.fgMade + (game.fgMade || 0),
      fgAttempts: acc.fgAttempts + (game.fgAttempts || 0),
      ftMade: acc.ftMade + (game.ftMade || 0),
      ftAttempts: acc.ftAttempts + (game.ftAttempts || 0),
      minutesPlayed: acc.minutesPlayed + (game.minutesPlayed || 0),
    }), {
      points: 0, assists: 0, rebounds: 0, steals: 0, blocks: 0,
      fgMade: 0, fgAttempts: 0, ftMade: 0, ftAttempts: 0, minutesPlayed: 0
    });

    return {
      ppg: (totals.points / totalGames).toFixed(1),
      apg: (totals.assists / totalGames).toFixed(1),
      rpg: (totals.rebounds / totalGames).toFixed(1),
      spg: (totals.steals / totalGames).toFixed(1),
      bpg: (totals.blocks / totalGames).toFixed(1),
      fgPct: totals.fgAttempts > 0 ? ((totals.fgMade / totals.fgAttempts) * 100).toFixed(1) : '0.0',
      ftPct: totals.ftAttempts > 0 ? ((totals.ftMade / totals.ftAttempts) * 100).toFixed(1) : '0.0',
      mpg: (totals.minutesPlayed / totalGames).toFixed(1),
      totalGames,
      ...totals
    };
  };

  if (!player) {
    return (
      <div className="text-center py-8">
        <p className="text-zinc-400">Player not found</p>
        <button
          onClick={onBack}
          className="mt-4 bg-zinc-700 hover:bg-zinc-600 px-4 py-2 rounded-lg transition-colors"
        >
          Go Back
        </button>
      </div>
    );
  }

  const averages = calculateAverages();

  return (
    <div className="space-y-6">
      {/* Enhanced Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-4">
          <button
            onClick={onBack}
            className="p-3 rounded-xl bg-gradient-to-r from-zinc-800 to-zinc-700 hover:from-zinc-700 hover:to-zinc-600 transition-all transform hover:scale-105 shadow-lg"
          >
            <ArrowLeft className="w-5 h-5 text-white" />
          </button>
          <div>
            <h1 className="text-3xl font-bold text-white flex items-center gap-3">
              <Trophy className="w-8 h-8 text-yellow-400" />
              Player Profile
            </h1>
            <p className="text-zinc-400 mt-1">Detailed performance analysis and insights</p>
          </div>
        </div>
        
      </div>

      {/* Enhanced Player Info Card */}
      <div className="bg-gradient-to-br from-zinc-900 to-zinc-800 rounded-xl p-8 border border-zinc-700 shadow-2xl">
        <div className="flex flex-col lg:flex-row gap-8">
          {/* Player Image Section */}
          <div className="flex-shrink-0 text-center lg:text-left">
            <div className="relative inline-block">
              <div className="w-56 h-56 mx-auto lg:mx-0 rounded-2xl overflow-hidden border-4 border-gradient-to-r from-yellow-500 to-yellow-600 shadow-2xl">
                <PlayerImage
                  profileImageUrl={player.profileImageUrl}
                  className="w-full h-full object-cover"
                  alt={player.name}
                />
              </div>
              {/* Status Indicator */}
              <div className={`absolute -bottom-2 -right-2 w-6 h-6 rounded-full border-4 border-zinc-900 ${player.isActive ? 'bg-green-400' : 'bg-red-400'}`}></div>
            </div>
          </div>

          {/* Player Info Section */}
          <div className="flex-1 space-y-6">
            <div>
              <h2 className="text-4xl font-bold text-white mb-3 bg-gradient-to-r from-white to-zinc-300 bg-clip-text text-transparent">
                {player.name}
              </h2>
              <div className="flex flex-wrap gap-3 mb-4">
                {player.position && (
                  <span className="bg-gradient-to-r from-yellow-500/20 to-yellow-600/20 border border-yellow-500/30 text-yellow-400 px-4 py-2 rounded-lg text-sm font-medium">
                    <Star className="w-4 h-4 inline mr-1" />
                    {player.position}
                  </span>
                )}
                {player.jerseyNumber && (
                  <span className="bg-gradient-to-r from-zinc-800 to-zinc-700 text-zinc-300 px-4 py-2 rounded-lg text-sm font-medium">
                    #{player.jerseyNumber}
                  </span>
                )}
                <span className={`px-4 py-2 rounded-lg text-sm font-medium ${player.isActive ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}`}>
                  <Activity className="w-4 h-4 inline mr-1" />
                  {player.isActive ? 'Active' : 'Inactive'}
                </span>
              </div>
            </div>

            {/* Enhanced Physical Stats */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              {player.height && (
                <div className="bg-zinc-800/50 rounded-lg p-3 text-center">
                  <div className="text-lg font-bold text-white">{player.height}</div>
                  <div className="text-xs text-zinc-400">Height</div>
                </div>
              )}
              {player.weight && (
                <div className="bg-zinc-800/50 rounded-lg p-3 text-center">
                  <div className="text-lg font-bold text-white">{player.weight}</div>
                  <div className="text-xs text-zinc-400">Weight</div>
                </div>
              )}
              <div className="bg-zinc-800/50 rounded-lg p-3 text-center">
                <div className="text-lg font-bold text-yellow-400">{player.totalGamesPlayed || 0}</div>
                <div className="text-xs text-zinc-400">Games</div>
              </div>
              <div className="bg-zinc-800/50 rounded-lg p-3 text-center">
                <div className="text-lg font-bold text-emerald-400">
                  {gameStats.length > 0 ? ((player.careerPoints || 0) / gameStats.length).toFixed(1) : '0.0'}
                </div>
                <div className="text-xs text-zinc-400">Avg PPG</div>
              </div>
            </div>

            {/* Enhanced Career Totals */}
            <div className="bg-zinc-800/30 rounded-xl p-6">
              <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                <Trophy className="w-5 h-5 text-yellow-400" />
                Career Statistics
              </h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
                <div className="text-center">
                  <div className="text-3xl font-bold text-emerald-400 mb-1">{player.careerPoints || 0}</div>
                  <div className="text-sm text-zinc-400">Total Points</div>
                </div>
                <div className="text-center">
                  <div className="text-3xl font-bold text-blue-400 mb-1">{player.careerAssists || 0}</div>
                  <div className="text-sm text-zinc-400">Total Assists</div>
                </div>
                <div className="text-center">
                  <div className="text-3xl font-bold text-purple-400 mb-1">{player.careerRebounds || 0}</div>
                  <div className="text-sm text-zinc-400">Total Rebounds</div>
                </div>
                <div className="text-center">
                  <div className="text-3xl font-bold text-orange-400 mb-1">{player.careerSteals || 0}</div>
                  <div className="text-sm text-zinc-400">Total Steals</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>


      {/* Season Averages */}
      {averages && (
        <div className="bg-gradient-to-br from-zinc-900 to-zinc-800 rounded-xl p-6 border border-zinc-700">
          <div className="flex items-center gap-2 mb-4">
            <BarChart3 className="w-5 h-5 text-yellow-400" />
            <h3 className="text-xl font-bold text-white">Season Averages</h3>
            <span className="text-sm text-zinc-400">({averages.totalGames} games)</span>
          </div>
          
          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4">
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-emerald-400">{averages.ppg}</div>
              <div className="text-xs text-zinc-400">PPG</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-blue-400">{averages.apg}</div>
              <div className="text-xs text-zinc-400">APG</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-purple-400">{averages.rpg}</div>
              <div className="text-xs text-zinc-400">RPG</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-orange-400">{averages.fgPct}%</div>
              <div className="text-xs text-zinc-400">FG%</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-pink-400">{averages.ftPct}%</div>
              <div className="text-xs text-zinc-400">FT%</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-green-400">{averages.spg}</div>
              <div className="text-xs text-zinc-400">SPG</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-red-400">{averages.bpg}</div>
              <div className="text-xs text-zinc-400">BPG</div>
            </div>
            <div className="bg-zinc-800/50 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-yellow-400">{averages.mpg}</div>
              <div className="text-xs text-zinc-400">MPG</div>
            </div>
          </div>
        </div>
      )}

      {/* Game History */}
      <div className="bg-gradient-to-br from-zinc-900 to-zinc-800 rounded-xl p-6 border border-zinc-700">
        <div className="flex items-center gap-2 mb-4">
          <Calendar className="w-5 h-5 text-yellow-400" />
          <h3 className="text-xl font-bold text-white">Game History</h3>
        </div>
        
        {gameStats.length === 0 ? (
          <div className="text-center py-8 text-zinc-400">
            <TrendingUp className="w-8 h-8 mx-auto mb-2 opacity-50" />
            <p>No games played yet</p>
          </div>
        ) : (
          <div className="space-y-3 max-h-96 overflow-y-auto">
            {gameStats.slice().reverse().map((game, index) => (
              <div key={game.id} className="bg-zinc-800/50 rounded-lg p-4 hover:bg-zinc-800/70 transition-colors">
                <div className="flex items-center justify-between mb-2">
                  <div className="text-sm font-medium text-white">Game #{gameStats.length - index}</div>
                  <div className="flex items-center gap-2 text-xs text-zinc-400">
                    <Clock className="w-3 h-3" />
                    {game.minutesPlayed || 0} min
                  </div>
                </div>
                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-3 text-sm">
                  <div className="flex justify-between">
                    <span className="text-zinc-400">PTS</span>
                    <span className="font-bold text-emerald-400">{game.points || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">AST</span>
                    <span className="font-bold text-blue-400">{game.assists || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">REB</span>
                    <span className="font-bold text-purple-400">{(game.offRebounds || 0) + (game.defRebounds || 0)}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">STL</span>
                    <span className="font-bold text-green-400">{game.steals || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">BLK</span>
                    <span className="font-bold text-red-400">{game.blocks || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">FG</span>
                    <span className="font-bold text-orange-400">{game.fgMade || 0}/{game.fgAttempts || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">FT</span>
                    <span className="font-bold text-pink-400">{game.ftMade || 0}/{game.ftAttempts || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-zinc-400">+/-</span>
                    <span className={`font-bold ${(game.plusMinus || 0) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                      {game.plusMinus > 0 ? '+' : ''}{game.plusMinus || 0}
                    </span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}; 


=== ./src/components/PlayerProfiles/PlayersSimplified.tsx ===
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { Plus, Edit2, Trash2, User, Save, X, Users, Camera, Upload } from 'lucide-react';
import { api } from '../../services/api';
import type { Player } from '../../types/api.types';
import { useTeamManagement } from '../../hooks/useTeamManagement';
import { PlayerTeamAssignmentModal } from '../TeamManagement/PlayerTeamAssignmentModal';
import { validateImageFile, resizeProfileImage, formatFileSize } from '../../utils/imageUtils';

export const PlayersSimplified: React.FC = () => {
  const teamManagement = useTeamManagement();
  const navigate = useNavigate();
  const [players, setPlayers] = useState<Player[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showAddForm, setShowAddForm] = useState(false);
  const [editingPlayer, setEditingPlayer] = useState<string | null>(null);
  
  // Team assignment modal state
  const [showTeamAssignmentModal, setShowTeamAssignmentModal] = useState(false);
  const [selectedPlayerForTeams, setSelectedPlayerForTeams] = useState<any>(null);
  
  const [formData, setFormData] = useState({
    name: '',
    position: '',
    height: '',
    weight: '',
    jerseyNumber: '',
    teamId: ''
  });

  // Photo upload state
  const [profileImage, setProfileImage] = useState<File | null>(null);
  const [profileImageUrl, setProfileImageUrl] = useState<string>('');
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const positions = ['PG', 'SG', 'SF', 'PF', 'C'];

  useEffect(() => {
    fetchPlayers();
    teamManagement.fetchTeams();
  }, []);

  const fetchPlayers = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await api.players.list();
      
      if (response.success) {
        setPlayers(response.data || []);
      } else {
        setError(response.error?.message || 'Failed to fetch players');
      }
    } catch (error) {
      console.error('Error fetching players:', error);
      setError(`Failed to fetch players: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleImageSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate image
    const validation = validateImageFile(file);
    if (!validation.isValid) {
      setError(validation.error || 'Invalid image file');
      return;
    }

    try {
      // Resize image
      const resizedFile = await resizeProfileImage(file);
      setProfileImage(resizedFile);
      
      // Create preview
      const url = URL.createObjectURL(resizedFile);
      setPreviewUrl(url);
    } catch (error) {
      console.error('Error processing image:', error);
      setError('Failed to process image');
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      setUploading(true);
      
      // Upload image if one was selected
      let uploadedImageUrl = profileImageUrl || '/default-player.png';
      if (profileImage) {
        const uploadResult = await api.upload.playerImage(profileImage, 'temp-player-id');
        if (uploadResult.success && uploadResult.data?.imageUrl) {
          uploadedImageUrl = uploadResult.data.imageUrl;
        }
      }

      const playerData = {
        ...formData,
        jerseyNumber: formData.jerseyNumber ? parseInt(formData.jerseyNumber) : undefined,
        profileImageUrl: uploadedImageUrl
      };

      if (editingPlayer) {
        const response = await api.players.update(editingPlayer, playerData);
        if (response.success) {
          setPlayers(prev => prev.map(p => 
            p.id === editingPlayer ? response.data : p
          ));
          setEditingPlayer(null);
        } else {
          setError(response.error?.message || 'Failed to update player');
        }
      } else {
        const response = await api.players.create(playerData);
        if (response.success) {
          // Assign to team if selected
          if (formData.teamId) {
            await teamManagement.assignPlayerToTeam(response.data.id, formData.teamId);
          }
          
          setPlayers(prev => [...prev, response.data]);
          setShowAddForm(false);
        } else {
          setError(response.error?.message || 'Failed to create player');
        }
      }
      
      // Reset form
      setFormData({ name: '', position: '', height: '', weight: '', jerseyNumber: '', teamId: '' });
      setProfileImage(null);
      setPreviewUrl(null);
      setProfileImageUrl('');
    } catch (error) {
      console.error('Error saving player:', error);
      setError(`Failed to save player: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setUploading(false);
    }
  };

  const handleEdit = (player: Player) => {
    setEditingPlayer(player.id);
    setFormData({
      name: player.name,
      position: player.position || '',
      height: player.height || '',
      weight: player.weight || '',
      jerseyNumber: player.jerseyNumber?.toString() || '',
      teamId: ''
    });
    setProfileImageUrl(player.profileImageUrl || '');
    setShowAddForm(false);
  };

  const handleDelete = async (playerId: string) => {
    if (!confirm('Are you sure you want to delete this player?')) return;
    
    try {
      const response = await api.players.delete(playerId);
      if (response.success) {
        setPlayers(prev => prev.filter(p => p.id !== playerId));
      } else {
        setError(response.error?.message || 'Failed to delete player');
      }
    } catch (error) {
      console.error('Error deleting player:', error);
      setError(`Failed to delete player: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const handleCancel = () => {
    setShowAddForm(false);
    setEditingPlayer(null);
    setFormData({ name: '', position: '', height: '', weight: '', jerseyNumber: '', teamId: '' });
    setProfileImage(null);
    setPreviewUrl(null);
    setProfileImageUrl('');
    setError(null);
  };

  const handleManageTeams = (player: Player) => {
    // Convert Player to PlayerWithTeam format
    const playerWithTeams = {
      id: player.id,
      name: player.name,
      position: player.position,
      profileImageUrl: player.profileImageUrl,
      isActive: player.isActive || true,
      teams: teamManagement.players.find(p => p.id === player.id)?.teams || []
    };
    setSelectedPlayerForTeams(playerWithTeams);
    setShowTeamAssignmentModal(true);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="w-8 h-8 border-2 border-yellow-500 border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-2xl font-bold text-white">Players</h2>
          <p className="text-zinc-400">Manage your team roster</p>
        </div>
        {!showAddForm && !editingPlayer && (
          <button
            onClick={() => setShowAddForm(true)}
            className="flex items-center gap-2 bg-yellow-500 hover:bg-yellow-600 text-black px-4 py-2 rounded-lg font-medium transition-colors"
          >
            <Plus className="w-4 h-4" />
            Add Player
          </button>
        )}
      </div>

      {/* Error Message */}
      {error && (
        <div className="bg-red-900/20 border border-red-500/20 rounded-lg p-4">
          <p className="text-red-400">{error}</p>
        </div>
      )}

      {/* Add/Edit Form */}
      {(showAddForm || editingPlayer) && (
        <div className="bg-zinc-800 border border-zinc-700 rounded-lg p-6">
          <h3 className="text-lg font-semibold text-white mb-4">
            {editingPlayer ? 'Edit Player' : 'Add New Player'}
          </h3>
          
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Player Name *
                </label>
                <input
                  type="text"
                  name="name"
                  value={formData.name}
                  onChange={handleInputChange}
                  required
                  className="w-full px-3 py-2 bg-zinc-700 border border-zinc-600 rounded-lg text-white focus:ring-2 focus:ring-yellow-500"
                  placeholder="Enter player name"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Position
                </label>
                <select
                  name="position"
                  value={formData.position}
                  onChange={handleInputChange}
                  className="w-full px-3 py-2 bg-zinc-700 border border-zinc-600 rounded-lg text-white focus:ring-2 focus:ring-yellow-500"
                >
                  <option value="">Select position</option>
                  {positions.map(pos => (
                    <option key={pos} value={pos}>{pos}</option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Height
                </label>
                <input
                  type="text"
                  name="height"
                  value={formData.height}
                  onChange={handleInputChange}
                  className="w-full px-3 py-2 bg-zinc-700 border border-zinc-600 rounded-lg text-white focus:ring-2 focus:ring-yellow-500"
                  placeholder="e.g., 6'2&quot;"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Weight
                </label>
                <input
                  type="text"
                  name="weight"
                  value={formData.weight}
                  onChange={handleInputChange}
                  className="w-full px-3 py-2 bg-zinc-700 border border-zinc-600 rounded-lg text-white focus:ring-2 focus:ring-yellow-500"
                  placeholder="e.g., 185 lbs"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Jersey Number
                </label>
                <input
                  type="number"
                  name="jerseyNumber"
                  value={formData.jerseyNumber}
                  onChange={handleInputChange}
                  min="0"
                  max="99"
                  className="w-full px-3 py-2 bg-zinc-700 border border-zinc-600 rounded-lg text-white focus:ring-2 focus:ring-yellow-500"
                  placeholder="e.g., 23"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Assign to Team
                </label>
                <select
                  name="teamId"
                  value={formData.teamId}
                  onChange={handleInputChange}
                  className="w-full px-3 py-2 bg-zinc-700 border border-zinc-600 rounded-lg text-white focus:ring-2 focus:ring-yellow-500"
                  disabled={editingPlayer !== null}
                >
                  <option value="">No team (assign later)</option>
                  {teamManagement.teams.map(team => (
                    <option key={team.id} value={team.id}>{team.name}</option>
                  ))}
                </select>
              </div>
            </div>

            {/* Profile Photo Upload */}
            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Profile Photo
              </label>
              <div className="flex items-center gap-4">
                {/* Preview */}
                <div className="relative w-24 h-24 bg-zinc-700 rounded-lg overflow-hidden">
                  {previewUrl || profileImageUrl ? (
                    <img 
                      src={previewUrl || profileImageUrl} 
                      alt="Profile preview" 
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center">
                      <User className="w-12 h-12 text-zinc-500" />
                    </div>
                  )}
                </div>

                {/* Upload Button */}
                <div>
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    onChange={handleImageSelect}
                    className="hidden"
                  />
                  <button
                    type="button"
                    onClick={() => fileInputRef.current?.click()}
                    className="flex items-center gap-2 bg-zinc-600 hover:bg-zinc-500 text-white px-4 py-2 rounded-lg font-medium transition-colors"
                    disabled={uploading}
                  >
                    <Upload className="w-4 h-4" />
                    {uploading ? 'Uploading...' : 'Choose Photo'}
                  </button>
                  <p className="text-xs text-zinc-400 mt-1">
                    Default image will be used if none selected
                  </p>
                </div>
              </div>
            </div>

            <div className="flex gap-3 pt-4">
              <button
                type="submit"
                className="flex items-center gap-2 bg-yellow-500 hover:bg-yellow-600 text-black px-4 py-2 rounded-lg font-medium transition-colors"
              >
                <Save className="w-4 h-4" />
                {editingPlayer ? 'Update Player' : 'Add Player'}
              </button>
              <button
                type="button"
                onClick={handleCancel}
                className="flex items-center gap-2 bg-zinc-600 hover:bg-zinc-500 text-white px-4 py-2 rounded-lg font-medium transition-colors"
              >
                <X className="w-4 h-4" />
                Cancel
              </button>
            </div>
          </form>
        </div>
      )}

      {/* Players List */}
      <div className="grid gap-4">
        {players.length === 0 ? (
          <div className="text-center py-12">
            <User className="w-16 h-16 text-zinc-600 mx-auto mb-4" />
            <h3 className="text-lg font-medium text-zinc-400 mb-2">No players yet</h3>
            <p className="text-zinc-500">Add your first player to get started</p>
          </div>
        ) : (
          players.map((player) => (
            <div
              key={player.id}
              className="bg-zinc-800 border border-zinc-700 rounded-lg p-4 hover:border-zinc-600 transition-colors"
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 bg-zinc-700 rounded-full flex items-center justify-center overflow-hidden">
                    {player.profileImageUrl ? (
                      <img 
                        src={player.profileImageUrl} 
                        alt={player.name}
                        className="w-full h-full object-cover"
                        onError={(e) => {
                          e.currentTarget.src = '/default-player.png';
                        }}
                      />
                    ) : (
                      <img 
                        src="/default-player.png" 
                        alt={player.name}
                        className="w-full h-full object-cover"
                      />
                    )}
                  </div>
                  <div>
                    <h3 
                      className="font-semibold text-white hover:text-yellow-400 cursor-pointer transition-colors"
                      onClick={() => navigate(`/players/${player.id}`)}
                    >
                      {player.name}
                    </h3>
                    <div className="text-sm text-zinc-400 flex gap-2">
                      {player.position && <span key="position">{player.position}</span>}
                      {player.jerseyNumber && <span key="jersey">#{player.jerseyNumber}</span>}
                      {player.height && <span key="height">{player.height}</span>}
                      {player.weight && <span key="weight">{player.weight}</span>}
                    </div>
                    {/* Team assignments */}
                    <div className="text-xs text-zinc-500 mt-1">
                      {(() => {
                        const playerTeams = teamManagement.players.find(p => p.id === player.id)?.teams || [];
                        if (playerTeams.length === 0) {
                          return <span>No team assignments</span>;
                        }
                        return (
                          <span className="text-blue-400">
                            Teams: {playerTeams.map(t => t.name).join(', ')}
                          </span>
                        );
                      })()}
                    </div>
                  </div>
                </div>
                
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => handleManageTeams(player)}
                    className="p-2 text-zinc-400 hover:text-blue-400 hover:bg-zinc-700 rounded-lg transition-colors"
                    title="Manage Teams"
                  >
                    <Users className="w-4 h-4" />
                  </button>
                  <button
                    onClick={() => handleEdit(player)}
                    className="p-2 text-zinc-400 hover:text-yellow-400 hover:bg-zinc-700 rounded-lg transition-colors"
                  >
                    <Edit2 className="w-4 h-4" />
                  </button>
                  <button
                    onClick={() => handleDelete(player.id)}
                    className="p-2 text-zinc-400 hover:text-red-400 hover:bg-zinc-700 rounded-lg transition-colors"
                  >
                    <Trash2 className="w-4 h-4" />
                  </button>
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Player Team Assignment Modal */}
      <PlayerTeamAssignmentModal
        isOpen={showTeamAssignmentModal}
        onClose={() => {
          setShowTeamAssignmentModal(false);
          setSelectedPlayerForTeams(null);
        }}
        player={selectedPlayerForTeams}
        teams={teamManagement.teams}
        onAssignPlayerToTeam={teamManagement.assignPlayerToTeam}
        onRemovePlayerFromTeam={teamManagement.removePlayerFromTeam}
      />
    </div>
  );
};


=== ./src/components/PlayerProfiles/PlayersWithTeamAssignment.tsx ===
import React, { useState, useEffect } from 'react';
import { Plus, Edit2, Trash2, User, Save, X, Camera, Upload } from 'lucide-react';
import { api } from '../../services/api';
import type { Player } from '../../types/api.types';
import { PlayerImage } from './PlayerImage';
import { PlayerDetail } from './PlayerDetail';
// import { PlayerTeamAssignmentModal } from '../TeamManagement/PlayerTeamAssignmentModal';
// import { useTeamManagement, type PlayerWithTeam } from '../../hooks/useTeamManagement';
import { resizeProfileImage, validateImageFile, formatFileSize, getImageDimensions } from '../../utils/imageUtils';

export const PlayersWithTeamAssignment: React.FC = () => {
  // const teamManagement = useTeamManagement();
  
  // Local player state
  const [players, setPlayers] = useState<Player[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedPlayerId, setSelectedPlayerId] = useState<string | null>(null);
  
  // Team assignment state (temporarily disabled)
  // const [showPlayerAssignmentModal, setShowPlayerAssignmentModal] = useState(false);
  // const [selectedPlayerForAssignment, setSelectedPlayerForAssignment] = useState<PlayerWithTeam | null>(null);

  // Add player form state
  const [showAddForm, setShowAddForm] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    position: '',
    height: '',
    weight: '',
    jerseyNumber: '',
    profileImage: null as File | null,
    profileImageUrl: '' as string
  });
  
  // Edit player state
  const [editingPlayer, setEditingPlayer] = useState<string | null>(null);
  const [editForm, setEditForm] = useState({
    name: '',
    position: '',
    height: '',
    weight: '',
    jerseyNumber: '',
    profileImage: null as File | null,
    profileImageUrl: '' as string
  });
  
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const [imageProcessing, setImageProcessing] = useState(false);
  const [originalImageSize, setOriginalImageSize] = useState<string>('');
  const [resizedImageSize, setResizedImageSize] = useState<string>('');

  const positions = ['PG', 'SG', 'SF', 'PF', 'C'];

  useEffect(() => {
    // Initialize player data
    const timer = setTimeout(() => {
      fetchPlayers();
    }, 100);
    
    return () => clearTimeout(timer);
  }, []);

  const fetchPlayers = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await api.players.list();
      
      if (response.success) {
        setPlayers(response.data || []);
      } else {
        setError(response.error?.message || 'Failed to fetch players');
        setPlayers([]);
      }
    } catch (error) {
      console.error('Error fetching players:', error);
      setError(`Failed to fetch players: ${error instanceof Error ? error.message : 'Unknown error'}`);
      setPlayers([]);
    } finally {
      setLoading(false);
    }
  };

  // Upload optimized image to S3
  const uploadOptimizedImage = async (file: File) => {
    try {
      setUploading(true);
      
      console.log(' Uploading optimized image');
      
      const result = await api.upload.playerImage(file, 'temp-player-id');
      
      if (result.success && result.data?.imageUrl) {
        console.log(' Upload successful:', result.data.imageUrl);
        setFormData(prev => ({ ...prev, profileImageUrl: result.data.imageUrl }));
      } else {
        throw new Error(result.error?.message || 'Upload failed');
      }
      
    } catch (error) {
      console.error(' Upload failed:', error);
      alert(`Failed to upload image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setUploading(false);
    }
  };

  // Upload optimized image for edit mode
  const uploadOptimizedImageEdit = async (file: File) => {
    try {
      setUploading(true);
      
      console.log(' Uploading optimized image (edit mode)');
      
      const result = await api.upload.playerImage(file, 'temp-player-id');
      
      if (result.success && result.data?.imageUrl) {
        console.log(' Upload successful (edit mode):', result.data.imageUrl);
        setEditForm(prev => ({ ...prev, profileImageUrl: result.data.imageUrl }));
      } else {
        throw new Error(result.error?.message || 'Upload failed');
      }
      
    } catch (error) {
      console.error(' Upload failed (edit mode):', error);
      alert(`Failed to upload image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setUploading(false);
    }
  };

  // Custom file handler that resizes images before upload
  const handleImageFileSelect = async (file: File, isEditMode: boolean = false) => {
    try {
      setImageProcessing(true);
      
      // Validate file
      const validation = validateImageFile(file, 10); // 10MB max
      if (!validation.isValid) {
        alert(validation.error);
        return;
      }

      // Get original dimensions and size
      const originalDimensions = await getImageDimensions(file);
      const originalSize = formatFileSize(file.size);
      setOriginalImageSize(originalSize);
      
      console.log(` Original image: ${originalDimensions.width}x${originalDimensions.height}, Size: ${originalSize}`);

      // Resize the image
      const resizedFile = await resizeProfileImage(file);
      const resizedDimensions = await getImageDimensions(resizedFile);
      const resizedSize = formatFileSize(resizedFile.size);
      setResizedImageSize(resizedSize);

      console.log(` Resized image: ${resizedDimensions.width}x${resizedDimensions.height}, Size: ${resizedSize}`);
      console.log(` Size reduction: ${((file.size - resizedFile.size) / file.size * 100).toFixed(1)}%`);

      // Create a preview URL for the resized image
      const previewUrl = URL.createObjectURL(resizedFile);
      setPreviewUrl(previewUrl);

      // Store the resized file
      if (isEditMode) {
        setEditForm(prev => ({ ...prev, profileImage: resizedFile }));
      } else {
        setFormData(prev => ({ ...prev, profileImage: resizedFile }));
      }
      
    } catch (error) {
      console.error(' Error processing image:', error);
      alert(`Failed to process image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setImageProcessing(false);
    }
  };

  const handleCreatePlayer = async () => {
    if (!formData.name.trim()) return;

    try {
      console.log(' Starting player creation...');
      console.log(' Current form data:', formData);
      console.log(' Profile image file:', formData.profileImage ? 'Present' : 'None');
      console.log(' Profile image URL:', formData.profileImageUrl || 'EMPTY');
      
      // Check if user has an image but hasn't uploaded it yet
      if (formData.profileImage && !formData.profileImageUrl) {
        alert(' Please click "Upload Optimized Image to Cloud" before saving the player!');
        console.warn(' User has selected an image but hasn\'t uploaded it to S3 yet');
        return;
      }
      
      // Create the player using REST API
      const playerData = {
        name: formData.name,
        position: formData.position || undefined,
        height: formData.height || undefined,
        weight: formData.weight || undefined,
        jerseyNumber: formData.jerseyNumber ? parseInt(formData.jerseyNumber) : undefined,
        profileImageUrl: formData.profileImageUrl || undefined,
        isActive: true
      };
      
      console.log(' Creating player with data:', playerData);
      
      const response = await api.players.create(playerData);

      if (response.success) {
        console.log(' Player created successfully:', response.data);
        // Refresh the players list
        await fetchPlayers();
        // Reset form
        resetForm();
      } else {
        throw new Error(response.error?.message || 'Failed to create player');
      }
      
    } catch (error) {
      console.error(' Error creating player:', error);
      alert(`Failed to create player: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const handleUpdatePlayer = async (playerId: string, updatedData: any) => {
    try {
      console.log('Updating player:', playerId, 'with data:', updatedData);
      
      const response = await api.players.update(playerId, updatedData);
      
      if (response.success) {
        setEditingPlayer(null);
        setPreviewUrl(null);
        await fetchPlayers();
      } else {
        throw new Error(response.error?.message || 'Failed to update player');
      }
      
    } catch (error) {
      console.error('Error updating player:', error);
      alert(`Failed to update player: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const resetForm = () => {
    setFormData({
      name: '',
      position: '',
      height: '',
      weight: '',
      jerseyNumber: '',
      profileImage: null,
      profileImageUrl: ''
    });
    setEditForm({
      name: '',
      position: '',
      height: '',
      weight: '',
      jerseyNumber: '',
      profileImage: null,
      profileImageUrl: ''
    });
    setPreviewUrl(null);
    setShowAddForm(false);
    setEditingPlayer(null);
    setOriginalImageSize('');
    setResizedImageSize('');
  };

  // Get team information for a player (temporarily disabled)
  const getPlayerTeams = (_playerId: string) => {
    // Temporarily disabled until team management is re-enabled
    return [];
  };



  const handleDeletePlayer = async (playerId: string) => {
    if (window.confirm('Are you sure you want to delete this player?')) {
      try {
        const response = await api.players.delete(playerId);
        if (response.success) {
          await fetchPlayers();
        } else {
          throw new Error(response.error?.message || 'Failed to delete player');
        }
      } catch (error) {
        console.error('Error deleting player:', error);
        alert(`Failed to delete player: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-400 mx-auto mb-4"></div>
          <p className="text-zinc-400">Loading players...</p>
        </div>
      </div>
    );
  }

  // If a player is selected, show the player detail view
  if (selectedPlayerId) {
    const selectedPlayer = players.find(p => p.id === selectedPlayerId);
    if (!selectedPlayer) {
      setSelectedPlayerId(null);
      return null;
    }
    return (
      <PlayerDetail 
        player={selectedPlayer}
        onBack={() => setSelectedPlayerId(null)}
      />
    );
  }

  // Show loading state
  if (loading) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-400 mx-auto mb-4"></div>
          <p className="text-zinc-400">Loading players...</p>
        </div>
      </div>
    );
  }

  // Show error state
  if (error) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center max-w-md mx-auto p-6">
          <div className="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
            <X className="w-8 h-8 text-red-400" />
          </div>
          <h3 className="text-xl font-semibold text-white mb-2">Unable to Load Players</h3>
          <p className="text-zinc-400 mb-4">{error}</p>
          <button
            onClick={() => {
              setError(null);
              fetchPlayers();
            }}
            className="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded-lg text-black font-medium transition-colors"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col space-y-6">
      {/* Dashboard Header */}
      <div className="bg-gradient-to-r from-zinc-900 to-zinc-800 rounded-xl p-6 border border-zinc-700">
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
          <div>
            <h2 className="text-3xl font-bold text-yellow-400 flex items-center gap-3 mb-2">
              <User className="w-8 h-8" />
              Player Management
            </h2>
            <p className="text-zinc-300">Manage individual player profiles, photos, and team assignments</p>
            <div className="mt-3 flex items-center gap-6 text-sm text-zinc-400">
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-emerald-400 rounded-full"></div>
                Total Players: {players.length}
              </span>
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-blue-400 rounded-full"></div>
                With Profile Photos: {players.filter(p => p.profileImageUrl).length}
              </span>
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-purple-400 rounded-full"></div>
                Teams: {/* teamManagement.teams.length */}
              </span>
            </div>
          </div>
          <button
            onClick={() => setShowAddForm(true)}
            className="bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 px-6 py-3 rounded-xl font-semibold text-black transition-all transform hover:scale-105 shadow-lg flex items-center gap-2"
          >
            <Plus className="w-5 h-5" />
            Add New Player
          </button>
        </div>
      </div>

      {/* Add Player Form */}
      {showAddForm && (
        <div className="bg-zinc-900 rounded-xl p-6 border border-zinc-700 shadow-2xl">
          <div className="flex items-center justify-between mb-6">
            <h3 className="text-xl font-semibold text-white flex items-center gap-2">
              <Plus className="w-5 h-5 text-yellow-400" />
              Add New Player
            </h3>
            <button
              onClick={resetForm}
              className="p-2 hover:bg-zinc-700 rounded-lg transition-colors"
            >
              <X className="w-5 h-5 text-zinc-400" />
            </button>
          </div>
          
          {/* Profile Image Upload */}
          <div className="mb-6">
            <label className="block text-sm font-medium text-zinc-300 mb-3">Profile Picture</label>
            
            {/* Image Preview */}
            {previewUrl && (
              <div className="mb-4 flex items-center gap-4">
                <div className="w-24 h-24 rounded-full overflow-hidden border-2 border-zinc-600">
                  <img 
                    src={previewUrl} 
                    alt="Preview" 
                    className="w-full h-full object-cover"
                  />
                </div>
                <div className="text-sm">
                  <div className="text-zinc-300"> Image optimized and ready to upload</div>
                  {originalImageSize && resizedImageSize && (
                    <div className="text-zinc-400 mt-1">
                      <div>Original: {originalImageSize}</div>
                      <div>Optimized: {resizedImageSize}</div>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* File Input */}
            <div className="bg-zinc-800 border border-zinc-600 rounded-lg p-6 border-dashed hover:border-yellow-500 transition-colors">
              <div className="text-center">
                <Camera className="w-12 h-12 mx-auto mb-4 text-zinc-400" />
                <p className="text-zinc-300 mb-4">
                  {imageProcessing ? 'Processing image...' : 'Select a profile image'}
                </p>
                <p className="text-sm text-zinc-500 mb-4">
                  Images will be automatically optimized to 400x400px for faster loading
                </p>
                <label className="cursor-pointer">
                  <span className="bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 disabled:from-zinc-600 disabled:to-zinc-700 px-6 py-3 rounded-lg font-semibold text-black transition-all transform hover:scale-105 shadow-lg inline-flex items-center gap-2">
                    {imageProcessing ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-black"></div>
                        Processing...
                      </>
                    ) : (
                      <>
                        <Camera className="w-4 h-4" />
                        Choose Image
                      </>
                    )}
                  </span>
                  <input
                    type="file"
                    accept="image/*"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) {
                        handleImageFileSelect(file);
                      }
                    }}
                    disabled={imageProcessing}
                    className="hidden"
                  />
                </label>
              </div>
            </div>

            {/* Upload status and button */}
            {formData.profileImage && (
              <div className="mt-4 space-y-3">
                {/* Upload Status */}
                {formData.profileImageUrl ? (
                  <div className="bg-emerald-500/10 border border-emerald-500/30 rounded-lg p-3">
                    <div className="flex items-center gap-2 text-emerald-400">
                      <div className="w-2 h-2 bg-emerald-400 rounded-full"></div>
                      <span className="text-sm font-medium"> Image uploaded to cloud successfully!</span>
                    </div>
                    <div className="text-xs text-emerald-300/70 mt-1">
                      Ready to save player profile
                    </div>
                  </div>
                ) : (
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3">
                    <div className="flex items-center gap-2 text-yellow-400">
                      <div className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                      <span className="text-sm font-medium"> Image processed but not uploaded yet</span>
                    </div>
                    <div className="text-xs text-yellow-300/70 mt-1">
                      Click "Upload to Cloud" below before saving
                    </div>
                  </div>
                )}

                {/* Upload Button */}
                {!formData.profileImageUrl && (
                  <button
                    onClick={() => uploadOptimizedImage(formData.profileImage!)}
                    disabled={uploading}
                    className="w-full bg-gradient-to-r from-emerald-600 to-emerald-700 hover:from-emerald-500 hover:to-emerald-600 disabled:from-zinc-600 disabled:to-zinc-700 px-6 py-3 rounded-lg font-semibold text-white transition-all flex items-center justify-center gap-2"
                  >
                    {uploading ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                        Uploading to Cloud...
                      </>
                    ) : (
                      <>
                        <Upload className="w-4 h-4" />
                        Upload Optimized Image to Cloud
                      </>
                    )}
                  </button>
                )}
              </div>
            )}
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
            <div className="lg:col-span-2">
              <input
                type="text"
                placeholder="Player Name *"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20"
              />
            </div>
            <select
              value={formData.position}
              onChange={(e) => setFormData({ ...formData, position: e.target.value })}
              className="bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20"
            >
              <option value="">Position</option>
              {positions.map(pos => (
                <option key={pos} value={pos}>{pos}</option>
              ))}
            </select>
            <input
              type="text"
              placeholder="Height (6'2&quot;)"
              value={formData.height}
              onChange={(e) => setFormData({ ...formData, height: e.target.value })}
              className="bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20"
            />
            <input
              type="text"
              placeholder="Weight (185 lbs)"
              value={formData.weight}
              onChange={(e) => setFormData({ ...formData, weight: e.target.value })}
              className="bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20"
            />
          </div>
          
          <div className="mb-6">
            <input
              type="number"
              placeholder="Jersey Number"
              value={formData.jerseyNumber}
              onChange={(e) => setFormData({ ...formData, jerseyNumber: e.target.value })}
              className="w-32 bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20"
            />
          </div>

          <div className="flex gap-3">
            <button
              onClick={handleCreatePlayer}
              disabled={!formData.name.trim() || uploading}
              className="bg-gradient-to-r from-emerald-600 to-emerald-700 hover:from-emerald-500 hover:to-emerald-600 disabled:from-zinc-600 disabled:to-zinc-700 px-6 py-3 rounded-lg font-semibold text-white transition-all transform hover:scale-105 shadow-lg flex items-center gap-2"
            >
              {uploading ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                  Uploading...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4" />
                  Save Player
                </>
              )}
            </button>
            <button
              onClick={resetForm}
              className="bg-zinc-700 hover:bg-zinc-600 px-6 py-3 rounded-lg font-semibold text-white transition-colors flex items-center gap-2"
            >
              <X className="w-4 h-4" />
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Enhanced Players Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        {players.map(player => {
          const playerTeams = getPlayerTeams(player.id);
          const careerAvgPoints = player.totalGamesPlayed > 0 ? (player.careerPoints / player.totalGamesPlayed).toFixed(1) : '0.0';
          const careerAvgAssists = player.totalGamesPlayed > 0 ? (player.careerAssists / player.totalGamesPlayed).toFixed(1) : '0.0';
          const careerAvgRebounds = player.totalGamesPlayed > 0 ? (player.careerRebounds / player.totalGamesPlayed).toFixed(1) : '0.0';
          
          return (
            <div 
              key={player.id} 
              onClick={() => setSelectedPlayerId(player.id)}
              className="bg-gradient-to-br from-zinc-900 to-zinc-800 rounded-xl border border-zinc-700 hover:border-yellow-500/30 transition-all duration-300 shadow-xl hover:shadow-2xl hover:scale-[1.02] group cursor-pointer">
              {/* Player Image with Gradient Overlay */}
              <div className="relative">
                <div className="w-full aspect-square bg-zinc-800 rounded-t-xl overflow-hidden">
                  <PlayerImage 
                    profileImageUrl={player.profileImageUrl}
                    className="w-full h-full transition-transform duration-300 group-hover:scale-105"
                    alt={player.name}
                  />
                  {/* Gradient overlay for better text visibility */}
                  <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent"></div>
                  
                  {/* Jersey Number Badge */}
                  {player.jerseyNumber && (
                    <div className="absolute top-3 right-3 bg-yellow-500 text-black font-bold text-sm px-2 py-1 rounded-full">
                      #{player.jerseyNumber}
                    </div>
                  )}
                  
                  {/* Position Badge */}
                  {player.position && (
                    <div className="absolute top-3 left-3 bg-black/60 backdrop-blur-sm text-white text-xs px-2 py-1 rounded-full">
                      {player.position}
                    </div>
                  )}
                </div>
              </div>

              {/* Enhanced Player Info */}
              <div className="p-6">
                {/* Header with name and status */}
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <h3 className="text-xl font-bold text-white mb-1 group-hover:text-yellow-400 transition-colors">
                      {player.name}
                    </h3>
                    <div className="flex items-center gap-2 text-sm text-zinc-400">
                      {player.height && (
                        <>
                          <span>{player.height}</span>
                        </>
                      )}
                      {player.weight && (
                        <>
                          {player.height && <span className="text-zinc-600"></span>}
                          <span>{player.weight}</span>
                        </>
                      )}
                    </div>
                  </div>
                </div>

                {/* Quick Stats Display */}
                <div className="mb-4 bg-zinc-800/50 rounded-lg p-3">
                  <div className="grid grid-cols-3 gap-3 text-center">
                    <div>
                      <div className="text-lg font-bold text-emerald-400">{careerAvgPoints}</div>
                      <div className="text-xs text-zinc-400">PPG</div>
                    </div>
                    <div>
                      <div className="text-lg font-bold text-blue-400">{careerAvgAssists}</div>
                      <div className="text-xs text-zinc-400">APG</div>
                    </div>
                    <div>
                      <div className="text-lg font-bold text-purple-400">{careerAvgRebounds}</div>
                      <div className="text-xs text-zinc-400">RPG</div>
                    </div>
                  </div>
                  <div className="mt-2 pt-2 border-t border-zinc-700 flex justify-center">
                    <div className="text-center">
                      <div className="text-sm font-medium text-white">{player.totalGamesPlayed || 0}</div>
                      <div className="text-xs text-zinc-400">Games Played</div>
                    </div>
                  </div>
                </div>

                {/* Team Assignments with enhanced styling */}
                <div className="space-y-2">
                  {playerTeams.length > 0 ? (
                    <div className="text-xs text-zinc-400 mb-2">Team Assignments:</div>
                  ) : (
                    <div className="text-xs text-zinc-400 mb-2">No team assignments</div>
                  )}
                  {/* No team assignments to display */}
                </div>

                {/* Enhanced Action Buttons */}
                <div className="flex gap-2">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setSelectedPlayerId(player.id);
                    }}
                    className="flex-1 bg-gradient-to-r from-yellow-600 to-yellow-700 hover:from-yellow-500 hover:to-yellow-600 text-white text-sm font-medium py-2 px-3 rounded-lg transition-all"
                  >
                    View Details
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setEditingPlayer(player.id);
                      setEditForm({
                        name: player.name,
                        position: player.position || '',
                        height: player.height || '',
                        weight: player.weight || '',
                        jerseyNumber: player.jerseyNumber?.toString() || '',
                        profileImage: null,
                        profileImageUrl: player.profileImageUrl || ''
                      });
                    }}
                    className="bg-zinc-700 hover:bg-zinc-600 text-white p-2 rounded-lg transition-colors"
                  >
                    <Edit2 className="w-4 h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDeletePlayer(player.id);
                    }}
                    className="bg-red-600 hover:bg-red-700 text-white p-2 rounded-lg transition-colors"
                  >
                    <Trash2 className="w-4 h-4" />
                  </button>
                </div>
              </div>
            </div>
          );
        })}
      </div>

      {/* Edit Player Modal */}
      {editingPlayer && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
          <div className="bg-zinc-900 rounded-lg p-6 max-w-2xl w-full border border-zinc-700 max-h-[90vh] overflow-y-auto">
            <h3 className="text-lg font-semibold text-white mb-4 flex items-center justify-between">
              <span>Edit Player</span>
              <button 
                onClick={() => {
                  setEditingPlayer(null);
                  setPreviewUrl(null);
                }}
                className="p-1.5 rounded text-zinc-400 hover:text-white hover:bg-zinc-800 transition-colors"
              >
                <X className="w-4 h-4" />
              </button>
            </h3>
            
            {players.filter(p => p.id === editingPlayer).map(player => (
              <div key={player.id} className="space-y-4">
                {/* Profile Image Upload */}
                <div className="mb-6">
                  <label className="block text-sm font-medium text-zinc-300 mb-2">Profile Picture</label>
                  
                  {/* Current Image Display */}
                  <div className="flex items-center gap-4 mb-4">
                    <div className="w-32 h-32 rounded-full bg-zinc-800 border-2 border-zinc-600 flex items-center justify-center overflow-hidden">
                      <PlayerImage
                        profileImageUrl={editForm.profileImageUrl || player.profileImageUrl}
                        className="w-full h-full object-cover"
                        alt={player.name}
                      />
                    </div>
                    <div className="text-sm text-zinc-400">
                      <p>Current profile picture</p>
                      <p className="text-xs">Upload a new image below to change it</p>
                    </div>
                  </div>

                  {/* Image Preview for Edit Mode */}
                  {previewUrl && editingPlayer === player.id && (
                    <div className="mb-4 flex items-center gap-4">
                      <div className="w-20 h-20 rounded-full overflow-hidden border-2 border-zinc-600">
                        <img 
                          src={previewUrl} 
                          alt="Preview" 
                          className="w-full h-full object-cover"
                        />
                      </div>
                      <div className="text-sm">
                        <div className="text-zinc-300"> New image optimized and ready to upload</div>
                        {originalImageSize && resizedImageSize && (
                          <div className="text-zinc-400 mt-1">
                            <div>Original: {originalImageSize}</div>
                            <div>Optimized: {resizedImageSize}</div>
                          </div>
                        )}
                      </div>
                    </div>
                  )}

                  {/* File Input for Edit Mode */}
                  <div className="bg-zinc-800 border border-zinc-600 rounded-lg p-4 border-dashed hover:border-yellow-500 transition-colors">
                    <div className="text-center">
                      <Camera className="w-6 h-6 mx-auto mb-2 text-zinc-400" />
                      <p className="text-zinc-300 mb-2 text-sm">
                        {imageProcessing ? 'Processing image...' : 'Select a new profile image'}
                      </p>
                      <label className="cursor-pointer">
                        <span className="bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 disabled:from-zinc-600 disabled:to-zinc-700 px-3 py-2 rounded-lg font-semibold text-black transition-all inline-flex items-center gap-2 text-sm">
                          {imageProcessing ? (
                            <>
                              <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-black"></div>
                              Processing...
                            </>
                          ) : (
                            <>
                              <Camera className="w-3 h-3" />
                              Choose New Image
                            </>
                          )}
                        </span>
                        <input
                          type="file"
                          accept="image/*"
                          onChange={(e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                              handleImageFileSelect(file, true);
                            }
                          }}
                          disabled={imageProcessing}
                          className="hidden"
                        />
                      </label>
                    </div>
                  </div>

                  {/* Upload to S3 button for edit mode */}
                  {editForm.profileImage && editingPlayer === player.id && (
                    <div className="mt-4">
                      <button
                        onClick={() => uploadOptimizedImageEdit(editForm.profileImage!)}
                        disabled={uploading}
                        className="w-full bg-gradient-to-r from-emerald-600 to-emerald-700 hover:from-emerald-500 hover:to-emerald-600 disabled:from-zinc-600 disabled:to-zinc-700 px-4 py-2 rounded-lg font-semibold text-white transition-all flex items-center justify-center gap-2 text-sm"
                      >
                        {uploading ? (
                          <>
                            <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-white"></div>
                            Uploading to Cloud...
                          </>
                        ) : (
                          <>
                            <Upload className="w-3 h-3" />
                            Upload Optimized Image
                          </>
                        )}
                      </button>
                    </div>
                  )}
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-zinc-300 mb-1">Name</label>
                    <input
                      type="text"
                      value={editForm.name}
                      onChange={(e) => setEditForm({ ...editForm, name: e.target.value })}
                      className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-zinc-300 mb-1">Position</label>
                    <select
                      value={editForm.position}
                      onChange={(e) => setEditForm({ ...editForm, position: e.target.value })}
                      className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white focus:border-yellow-500 focus:outline-none"
                    >
                      <option value="">Select Position</option>
                      {positions.map(pos => (
                        <option key={pos} value={pos}>{pos}</option>
                      ))}
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-zinc-300 mb-1">Height</label>
                    <input
                      type="text"
                      placeholder="e.g., 6'2&quot;"
                      value={editForm.height}
                      onChange={(e) => setEditForm({ ...editForm, height: e.target.value })}
                      className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-zinc-300 mb-1">Weight</label>
                    <input
                      type="text"
                      placeholder="e.g., 185 lbs"
                      value={editForm.weight}
                      onChange={(e) => setEditForm({ ...editForm, weight: e.target.value })}
                      className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-zinc-300 mb-1">Jersey #</label>
                    <input
                      type="number"
                      value={editForm.jerseyNumber}
                      onChange={(e) => setEditForm({ ...editForm, jerseyNumber: e.target.value })}
                      className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none"
                    />
                  </div>
                </div>
                
                <div className="flex gap-3 mt-6 justify-end">
                  <button
                    onClick={() => {
                      setEditingPlayer(null);
                      setPreviewUrl(null);
                      setEditForm({ name: '', position: '', height: '', weight: '', jerseyNumber: '', profileImage: null, profileImageUrl: '' });
                    }}
                    className="bg-zinc-600 hover:bg-zinc-700 px-4 py-2 rounded-lg font-medium text-white transition-colors flex items-center gap-2"
                  >
                    <X className="w-4 h-4" />
                    Cancel
                  </button>
                  <button
                    onClick={() => {
                      if (!editForm.name.trim()) return;
                      
                      const updatedData = {
                        name: editForm.name,
                        position: editForm.position || undefined,
                        height: editForm.height || undefined,
                        weight: editForm.weight || undefined,
                        jerseyNumber: editForm.jerseyNumber ? parseInt(editForm.jerseyNumber) : undefined,
                        profileImageUrl: editForm.profileImageUrl || undefined,
                      };
                      
                      handleUpdatePlayer(player.id, updatedData);
                    }}
                    disabled={!editForm.name.trim() || uploading}
                    className="bg-emerald-600 hover:bg-emerald-700 disabled:bg-zinc-600 px-4 py-2 rounded-lg font-medium text-white transition-colors flex items-center gap-2"
                  >
                    {uploading ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                        Updating...
                      </>
                    ) : (
                      <>
                        <Save className="w-4 h-4" />
                        Save Changes
                      </>
                    )}
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Player Team Assignment Modal - Temporarily disabled */}
      {/* 
      <PlayerTeamAssignmentModal
        isOpen={showPlayerAssignmentModal}
        onClose={() => setShowPlayerAssignmentModal(false)}
        player={selectedPlayerForAssignment}
        teams={teamManagement.teams}
        onAssignPlayerToTeam={teamManagement.assignPlayerToTeam}
        onRemovePlayerFromTeam={teamManagement.removePlayerFromTeam}
      />
      */}
    </div>
  );
}; 


=== ./src/components/PlayerProfiles/PlayerDetailPage.tsx ===
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { ArrowLeft, User, Trophy, Target, TrendingUp, Calendar, Edit2 } from 'lucide-react';
import { api } from '../../services/api';
import type { Player } from '../../types/api.types';

export const PlayerDetailPage: React.FC = () => {
  const { playerId } = useParams<{ playerId: string }>();
  const navigate = useNavigate();
  const [player, setPlayer] = useState<Player | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [stats, setStats] = useState<any[]>([]);

  useEffect(() => {
    if (playerId) {
      fetchPlayerDetails();
      fetchPlayerStats();
    }
  }, [playerId]);

  const fetchPlayerDetails = async () => {
    try {
      setLoading(true);
      const response = await api.players.getById(playerId!);
      if (response.success) {
        setPlayer(response.data);
      } else {
        setError(response.error?.message || 'Failed to fetch player details');
      }
    } catch (error) {
      console.error('Error fetching player:', error);
      setError(`Failed to fetch player: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const fetchPlayerStats = async () => {
    try {
      const response = await api.stats.getPlayerStats(playerId!);
      if (response.success) {
        setStats(response.data || []);
      }
    } catch (error) {
      console.error('Error fetching player stats:', error);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-zinc-900 text-white flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-yellow-500 border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  if (error || !player) {
    return (
      <div className="min-h-screen bg-zinc-900 text-white p-6">
        <div className="max-w-4xl mx-auto">
          <button
            onClick={() => navigate(-1)}
            className="flex items-center gap-2 text-zinc-400 hover:text-white mb-6"
          >
            <ArrowLeft className="w-4 h-4" />
            Back
          </button>
          <div className="bg-red-900/20 border border-red-500/20 rounded-lg p-6 text-center">
            <p className="text-red-400">{error || 'Player not found'}</p>
          </div>
        </div>
      </div>
    );
  }

  // Calculate career averages
  const gamesPlayed = player.totalGamesPlayed || 0;
  const avgPoints = gamesPlayed > 0 ? ((player.careerPoints || 0) / gamesPlayed).toFixed(1) : '0.0';
  const avgAssists = gamesPlayed > 0 ? ((player.careerAssists || 0) / gamesPlayed).toFixed(1) : '0.0';
  const avgRebounds = gamesPlayed > 0 ? ((player.careerRebounds || 0) / gamesPlayed).toFixed(1) : '0.0';
  const fgPercentage = player.careerFgAttempts ? ((player.careerFgMade || 0) / player.careerFgAttempts * 100).toFixed(1) : '0.0';
  const ftPercentage = player.careerFtAttempts ? ((player.careerFtMade || 0) / player.careerFtAttempts * 100).toFixed(1) : '0.0';

  return (
    <div className="min-h-screen bg-zinc-900 text-white p-6">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="flex justify-between items-center mb-8">
          <button
            onClick={() => navigate(-1)}
            className="flex items-center gap-2 text-zinc-400 hover:text-white"
          >
            <ArrowLeft className="w-4 h-4" />
            Back to Players
          </button>
          <button
            onClick={() => navigate(`/players/${playerId}/edit`)}
            className="flex items-center gap-2 bg-yellow-500 hover:bg-yellow-600 text-black px-4 py-2 rounded-lg font-medium transition-colors"
          >
            <Edit2 className="w-4 h-4" />
            Edit Profile
          </button>
        </div>

        {/* Player Profile Card */}
        <div className="bg-zinc-800 border border-zinc-700 rounded-xl p-8 mb-8">
          <div className="flex flex-col md:flex-row items-center md:items-start gap-8">
            {/* Profile Image */}
            <div className="w-32 h-32 bg-zinc-700 rounded-full overflow-hidden">
              {player.profileImageUrl ? (
                <img 
                  src={player.profileImageUrl} 
                  alt={player.name}
                  className="w-full h-full object-cover"
                  onError={(e) => {
                    e.currentTarget.src = '/default-player.png';
                  }}
                />
              ) : (
                <img 
                  src="/default-player.png" 
                  alt={player.name}
                  className="w-full h-full object-cover"
                />
              )}
            </div>

            {/* Player Info */}
            <div className="flex-1 text-center md:text-left">
              <h1 className="text-3xl font-bold text-white mb-2">{player.name}</h1>
              <div className="flex flex-wrap gap-4 text-zinc-400 mb-4 justify-center md:justify-start">
                {player.position && (
                  <span className="flex items-center gap-1">
                    <Target className="w-4 h-4" />
                    Position: {player.position}
                  </span>
                )}
                {player.jerseyNumber && (
                  <span className="flex items-center gap-1">
                    #{player.jerseyNumber}
                  </span>
                )}
                {player.height && (
                  <span className="flex items-center gap-1">
                    Height: {player.height}
                  </span>
                )}
                {player.weight && (
                  <span className="flex items-center gap-1">
                    Weight: {player.weight}
                  </span>
                )}
              </div>
              <div className="flex items-center gap-2 text-sm text-zinc-500 justify-center md:justify-start">
                <Calendar className="w-4 h-4" />
                <span>Joined: {new Date(player.createdAt || '').toLocaleDateString()}</span>
              </div>
            </div>
          </div>
        </div>

        {/* Career Stats Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
          {/* Career Totals */}
          <div className="bg-zinc-800 border border-zinc-700 rounded-xl p-6">
            <h2 className="text-xl font-semibold text-yellow-400 mb-4 flex items-center gap-2">
              <Trophy className="w-5 h-5" />
              Career Totals
            </h2>
            <div className="grid grid-cols-2 gap-4">
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Games Played</p>
                <p className="text-2xl font-bold text-white">{gamesPlayed}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Total Points</p>
                <p className="text-2xl font-bold text-white">{player.careerPoints || 0}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Total Assists</p>
                <p className="text-2xl font-bold text-white">{player.careerAssists || 0}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Total Rebounds</p>
                <p className="text-2xl font-bold text-white">{player.careerRebounds || 0}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Total Steals</p>
                <p className="text-2xl font-bold text-white">{player.careerSteals || 0}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Total Blocks</p>
                <p className="text-2xl font-bold text-white">{player.careerBlocks || 0}</p>
              </div>
            </div>
          </div>

          {/* Career Averages */}
          <div className="bg-zinc-800 border border-zinc-700 rounded-xl p-6">
            <h2 className="text-xl font-semibold text-yellow-400 mb-4 flex items-center gap-2">
              <TrendingUp className="w-5 h-5" />
              Career Averages
            </h2>
            <div className="grid grid-cols-2 gap-4">
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Points/Game</p>
                <p className="text-2xl font-bold text-white">{avgPoints}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Assists/Game</p>
                <p className="text-2xl font-bold text-white">{avgAssists}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Rebounds/Game</p>
                <p className="text-2xl font-bold text-white">{avgRebounds}</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">Minutes/Game</p>
                <p className="text-2xl font-bold text-white">
                  {gamesPlayed > 0 ? ((player.careerMinutesPlayed || 0) / gamesPlayed).toFixed(1) : '0.0'}
                </p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">FG%</p>
                <p className="text-2xl font-bold text-white">{fgPercentage}%</p>
              </div>
              <div className="bg-zinc-900 rounded-lg p-4">
                <p className="text-zinc-400 text-sm">FT%</p>
                <p className="text-2xl font-bold text-white">{ftPercentage}%</p>
              </div>
            </div>
          </div>
        </div>

        {/* Recent Games */}
        <div className="bg-zinc-800 border border-zinc-700 rounded-xl p-6">
          <h2 className="text-xl font-semibold text-yellow-400 mb-4">Recent Games</h2>
          {stats.length === 0 ? (
            <p className="text-zinc-400 text-center py-8">No game statistics available yet</p>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="text-left text-zinc-400 border-b border-zinc-700">
                    <th className="py-2">Date</th>
                    <th className="py-2">Opponent</th>
                    <th className="py-2 text-center">PTS</th>
                    <th className="py-2 text-center">AST</th>
                    <th className="py-2 text-center">REB</th>
                    <th className="py-2 text-center">STL</th>
                    <th className="py-2 text-center">BLK</th>
                    <th className="py-2 text-center">MIN</th>
                  </tr>
                </thead>
                <tbody>
                  {stats.slice(0, 10).map((stat, index) => (
                    <tr key={index} className="border-b border-zinc-700/50">
                      <td className="py-3">{new Date(stat.gameDate).toLocaleDateString()}</td>
                      <td className="py-3">{stat.opponentName || 'Unknown'}</td>
                      <td className="py-3 text-center font-medium">{stat.points}</td>
                      <td className="py-3 text-center">{stat.assists}</td>
                      <td className="py-3 text-center">{stat.offRebounds + stat.defRebounds}</td>
                      <td className="py-3 text-center">{stat.steals}</td>
                      <td className="py-3 text-center">{stat.blocks}</td>
                      <td className="py-3 text-center">{stat.minutesPlayed}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};


=== ./src/components/PlayerManagement/SubstitutionModal.tsx ===
import React from 'react';
import { X } from 'lucide-react';
import type { Player } from '../../types/game.types';
import { formatTime } from '../../utils/timeFormatters';

interface SubstitutionModalProps {
  isOpen: boolean;
  playerComingIn: Player | null;
  playersOnCourt: Player[];
  onSubstitute: (playerOutId: number) => void;
  onCancel: () => void;
}

export const SubstitutionModal: React.FC<SubstitutionModalProps> = ({
  isOpen,
  playerComingIn,
  playersOnCourt,
  onSubstitute,
  onCancel,
}) => {
  if (!isOpen || !playerComingIn) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-zinc-900 rounded-lg p-6 max-w-md w-full mx-4 border border-zinc-700">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-semibold text-yellow-400">
            Substitution
          </h3>
          <button
            onClick={onCancel}
            className="text-zinc-400 hover:text-white transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>
        
        <div className="mb-4">
          <p className="text-zinc-300 mb-2">
            <span className="text-emerald-400 font-semibold">{playerComingIn.name}</span> is coming in.
          </p>
          <p className="text-zinc-400 text-sm">
            Who should they replace?
          </p>
        </div>
        
        <div className="space-y-2 mb-6">
          {playersOnCourt.map(player => (
            <button
              key={player.id}
              onClick={() => onSubstitute(player.id)}
              className="w-full bg-zinc-800 hover:bg-zinc-700 p-3 rounded-lg text-left flex justify-between items-center transition-colors group"
            >
              <div>
                <span className="text-white font-medium">{player.name}</span>
                <div className="text-sm text-zinc-400">
                  {player.stats.points} pts, {player.stats.fouls} fouls
                </div>
              </div>
              <div className="text-right">
                <div className="text-sm text-zinc-400">
                  {formatTime(player.stats.timeOnCourt)}
                </div>
                <div className={`text-sm ${player.stats.plusMinus >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                  +/- {player.stats.plusMinus > 0 ? '+' : ''}{player.stats.plusMinus}
                </div>
              </div>
            </button>
          ))}
        </div>
        
        <button
          onClick={onCancel}
          className="w-full bg-zinc-700 hover:bg-zinc-600 py-2 rounded-lg transition-colors text-zinc-300"
        >
          Cancel Substitution
        </button>
      </div>
    </div>
  );
}; 


=== ./src/components/PlayerManagement/index.ts ===
export { SubstitutionModal } from './SubstitutionModal'; 


=== ./src/components/GameReview/PlayerCard.tsx ===
import React from 'react';
import { PlayerImage } from '../PlayerProfiles/PlayerImage';

interface PlayerCardProps {
  player: {
    id: string;
    name: string;
    position?: string;
    profileImageUrl?: string;
  };
  isSelected: boolean;
  onSelect: () => void;
}

export const PlayerCard: React.FC<PlayerCardProps> = ({ player, isSelected, onSelect }) => {
  return (
    <div 
      onClick={onSelect}
      className={`p-3 rounded-lg border cursor-pointer transition-all flex items-center gap-3 ${
        isSelected
          ? 'border-yellow-500 bg-yellow-500/10'
          : 'border-zinc-600 bg-zinc-800 hover:border-zinc-500'
      }`}
    >
      {/* Player Image */}
      <div className="w-10 h-10 rounded-full overflow-hidden border border-zinc-600 flex-shrink-0">
        <PlayerImage 
          profileImageUrl={player.profileImageUrl}
          className="w-full h-full object-cover"
          alt={player.name}
        />
      </div>
      
      {/* Player Info */}
      <div>
        <h3 className="font-medium text-white">{player.name}</h3>
        {player.position && (
          <div className="text-xs text-zinc-400 mt-0.5">
            {player.position}
          </div>
        )}
      </div>
      
      {/* Selection Indicator */}
      {isSelected && (
        <div className="ml-auto w-3 h-3 bg-yellow-500 rounded-full"></div>
      )}
    </div>
  );
};


=== ./src/components/GameReview/ExportModal.tsx ===
import React, { useState } from 'react';
import { X, Download, FileText, Database, Eye } from 'lucide-react';
import type { Player } from '../../types/game.types';
import { exportGameSummaryAsCSV, exportGameSummaryAsJSON, generateGameSummary } from '../../utils/exportUtils';

interface ExportModalProps {
  isOpen: boolean;
  teamName: string;
  opponentName: string;
  teamScore: number;
  opponentScore: number;
  players: Player[];
  gameDate?: Date;
  totalDuration?: number;
  onCancel: () => void;
}

type ExportFormat = 'csv' | 'json';

export const ExportModal: React.FC<ExportModalProps> = ({
  isOpen,
  teamName,
  opponentName,
  teamScore,
  opponentScore,
  players,
  gameDate,
  totalDuration,
  onCancel,
}) => {
  const [selectedFormat, setSelectedFormat] = useState<ExportFormat>('csv');
  const [showPreview, setShowPreview] = useState(false);

  if (!isOpen) return null;

  const gameSummary = generateGameSummary(
    teamName,
    opponentName,
    teamScore,
    opponentScore,
    players,
    gameDate,
    totalDuration
  );

  const handleExport = () => {
    if (selectedFormat === 'csv') {
      exportGameSummaryAsCSV(gameSummary);
    } else {
      exportGameSummaryAsJSON(gameSummary);
    }
    onCancel();
  };

  const formatOptions = [
    {
      id: 'csv' as ExportFormat,
      name: 'CSV (Excel)',
      description: 'Compatible with Excel, Google Sheets, and other spreadsheet applications',
      icon: FileText,
      extension: '.csv'
    },
    {
      id: 'json' as ExportFormat,
      name: 'JSON',
      description: 'Structured data format perfect for developers and data analysis',
      icon: Database,
      extension: '.json'
    }
  ];

  const PreviewSection = () => {
    if (!showPreview) return null;

    return (
      <div className="mt-4 p-4 bg-zinc-800 rounded-lg border border-zinc-600">
        <h4 className="text-sm font-medium text-yellow-400 mb-3">Data Preview</h4>
        
        {/* Game Info */}
        <div className="mb-4">
          <h5 className="text-xs font-medium text-emerald-400 mb-2">Game Information</h5>
          <div className="text-xs text-zinc-300 space-y-1">
            <div>Teams: {gameSummary.gameInfo.teamName} vs {gameSummary.gameInfo.opponentName}</div>
            <div>Final Score: {gameSummary.gameInfo.finalScore}</div>
            <div>Date: {gameSummary.gameInfo.gameDate}</div>
            <div>Duration: {gameSummary.gameInfo.totalDuration}</div>
          </div>
        </div>

        {/* Player Stats Sample */}
        <div>
          <h5 className="text-xs font-medium text-cyan-400 mb-2">Player Statistics ({players.length} players)</h5>
          <div className="text-xs text-zinc-300">
            <div className="grid grid-cols-4 gap-2 font-medium text-zinc-400 mb-1">
              <div>Player</div>
              <div>Points</div>
              <div>Rebounds</div>
              <div>Assists</div>
            </div>
            {players.slice(0, 3).map((player, index) => (
              <div key={index} className="grid grid-cols-4 gap-2 py-1">
                <div>{player.name}</div>
                <div>{player.stats.points}</div>
                <div>{player.stats.offRebounds + player.stats.defRebounds}</div>
                <div>{player.stats.assists}</div>
              </div>
            ))}
            {players.length > 3 && (
              <div className="text-zinc-500 text-center py-1">
                ... and {players.length - 3} more players
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-zinc-900 rounded-lg p-6 max-w-lg w-full mx-4 border border-zinc-700 max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-yellow-400 flex items-center gap-2">
            <Download className="w-5 h-5" />
            Export Game Summary
          </h3>
          <button
            onClick={onCancel}
            className="text-zinc-400 hover:text-white transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="space-y-4">
          {/* Format Selection */}
          <div>
            <h4 className="text-sm font-medium text-zinc-300 mb-3">Choose Export Format</h4>
            <div className="space-y-2">
              {formatOptions.map((format) => {
                const Icon = format.icon;
                return (
                  <label
                    key={format.id}
                    className={`flex items-start gap-3 p-3 rounded-lg border cursor-pointer transition-colors ${
                      selectedFormat === format.id
                        ? 'border-yellow-500 bg-yellow-500/10'
                        : 'border-zinc-600 bg-zinc-800 hover:border-zinc-500'
                    }`}
                  >
                    <input
                      type="radio"
                      name="exportFormat"
                      value={format.id}
                      checked={selectedFormat === format.id}
                      onChange={(e) => setSelectedFormat(e.target.value as ExportFormat)}
                      className="mt-1"
                    />
                    <Icon className={`w-5 h-5 mt-0.5 ${selectedFormat === format.id ? 'text-yellow-400' : 'text-zinc-400'}`} />
                    <div className="flex-1">
                      <div className={`font-medium ${selectedFormat === format.id ? 'text-yellow-400' : 'text-white'}`}>
                        {format.name} <span className="text-xs text-zinc-500">{format.extension}</span>
                      </div>
                      <div className="text-xs text-zinc-400 mt-1">
                        {format.description}
                      </div>
                    </div>
                  </label>
                );
              })}
            </div>
          </div>

          {/* Preview Toggle */}
          <div>
            <button
              onClick={() => setShowPreview(!showPreview)}
              className="flex items-center gap-2 text-sm text-zinc-400 hover:text-white transition-colors"
            >
              <Eye className="w-4 h-4" />
              {showPreview ? 'Hide' : 'Show'} Data Preview
            </button>
          </div>

          <PreviewSection />

          {/* File Info */}
          <div className="p-3 bg-zinc-800 rounded-lg border border-zinc-600">
            <div className="text-sm text-zinc-300">
              <div className="font-medium mb-2">Export Details:</div>
              <div className="text-xs space-y-1 text-zinc-400">
                <div> File name: {teamName}_vs_{opponentName}_{new Date().toISOString().split('T')[0]}.{selectedFormat}</div>
                <div> Includes: Game info, all player statistics, team totals</div>
                <div> Format: {formatOptions.find(f => f.id === selectedFormat)?.name}</div>
              </div>
            </div>
          </div>
        </div>

        <div className="flex gap-3 mt-6">
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 bg-zinc-700 hover:bg-zinc-600 rounded-lg transition-colors text-zinc-300"
          >
            Cancel
          </button>
          
          <button
            onClick={handleExport}
            className="flex-1 px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded-lg transition-colors text-white font-medium flex items-center justify-center gap-2"
          >
            <Download className="w-4 h-4" />
            Export {selectedFormat.toUpperCase()}
          </button>
        </div>
      </div>
    </div>
  );
};


=== ./src/components/GameReview/PlayerSelectionModal.tsx ===
import React from 'react';
import { X, Users } from 'lucide-react';
import { PlayerImage } from '../PlayerProfiles/PlayerImage';

interface PlayerSelectionModalProps {
  isOpen: boolean;
  onClose: () => void;
  availablePlayers: any[];
  onSelectPlayer: (playerId: string) => void;
}

export const PlayerSelectionModal: React.FC<PlayerSelectionModalProps> = ({
  isOpen,
  onClose,
  availablePlayers,
  onSelectPlayer,
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-zinc-900 rounded-lg p-6 max-w-md w-full mx-4 border border-zinc-700">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-yellow-400 flex items-center gap-2">
            <Users className="w-5 h-5" />
            Select Player
          </h3>
          <button
            onClick={onClose}
            className="text-zinc-400 hover:text-white transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="space-y-2 max-h-64 overflow-y-auto">
          {availablePlayers.map((player) => (
            <button
              key={player.id}
              onClick={() => {
                onSelectPlayer(player.id);
                onClose();
              }}
              className="w-full text-left p-3 bg-zinc-800 hover:bg-zinc-700 rounded-lg transition-colors flex items-center gap-3"
            >
              {/* Player Image */}
              <div className="w-10 h-10 rounded-full overflow-hidden border border-zinc-600 flex-shrink-0">
                <PlayerImage 
                  profileImageUrl={player.profileImageUrl}
                  className="w-full h-full object-cover"
                  alt={player.name}
                />
              </div>
              
              <div>
                <div className="font-medium text-white">{player.name}</div>
                {player.position && (
                  <div className="text-sm text-zinc-400">{player.position}</div>
                )}
              </div>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}; 


=== ./src/components/GameReview/StatCorrectionModal.tsx ===
import React, { useState } from 'react';
import { X, Plus, Minus, RotateCcw } from 'lucide-react';

interface GamePlayer {
  id: string;
  name: string;
  position?: string;
  profileImageUrl?: string;
  onCourt: boolean;
  stats: {
    points: number;
    fouls: number;
    turnovers: number;
    offRebounds: number;
    defRebounds: number;
    assists: number;
    steals: number;
    blocks: number;
    fgMade: number;
    fgAttempts: number;
    ftMade: number;
    ftAttempts: number;
    plusMinus: number;
    timeOnCourt: number;
  };
  startTime: number | null;
}

interface StatCorrectionModalProps {
  isOpen: boolean;
  player: GamePlayer | null;
  onSave: (playerId: string, newStats: GamePlayer['stats']) => void;
  onCancel: () => void;
}

export const StatCorrectionModal: React.FC<StatCorrectionModalProps> = ({
  isOpen,
  player,
  onSave,
  onCancel,
}) => {
  const [editedStats, setEditedStats] = useState<GamePlayer['stats'] | null>(null);

  // Initialize edited stats when player changes
  React.useEffect(() => {
    if (player) {
      setEditedStats({ ...player.stats });
    }
  }, [player]);

  if (!isOpen || !player || !editedStats) return null;

  const updateStat = (statKey: keyof GamePlayer['stats'], value: number) => {
    setEditedStats(prev => prev ? { ...prev, [statKey]: Math.max(0, value) } : null);
  };

  const incrementStat = (statKey: keyof GamePlayer['stats'], amount: number = 1) => {
    updateStat(statKey, (editedStats[statKey] || 0) + amount);
  };

  const resetStats = () => {
    if (player) {
      setEditedStats({ ...player.stats });
    }
  };

  const handleSave = () => {
    if (editedStats && player) {
      onSave(player.id, editedStats);
    }
  };

  const StatRow: React.FC<{
    label: string;
    statKey: keyof GamePlayer['stats'];
    originalValue: number;
    showDecimals?: boolean;
  }> = ({ label, statKey, originalValue, showDecimals = false }) => {
    const currentValue = editedStats[statKey] || 0;
    const hasChanged = currentValue !== originalValue;

    return (
      <div className="flex items-center justify-between py-2 border-b border-zinc-700 last:border-b-0">
        <div className="flex items-center gap-3">
          <span className="text-sm font-medium text-zinc-300 w-20">{label}</span>
          {hasChanged && (
            <span className="text-xs text-yellow-400">
              ({originalValue}  {showDecimals ? currentValue.toFixed(1) : currentValue})
            </span>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          <button
            onClick={() => incrementStat(statKey, -1)}
            className="p-1 bg-red-600 hover:bg-red-700 rounded transition-colors"
            disabled={currentValue <= 0}
          >
            <Minus className="w-3 h-3" />
          </button>
          
          <input
            type="number"
            value={showDecimals ? currentValue.toFixed(1) : currentValue}
            onChange={(e) => {
              const value = showDecimals ? parseFloat(e.target.value) || 0 : parseInt(e.target.value) || 0;
              updateStat(statKey, value);
            }}
            className="w-16 px-2 py-1 bg-zinc-800 border border-zinc-600 rounded text-center text-sm text-white focus:border-yellow-500 focus:outline-none"
            step={showDecimals ? "0.1" : "1"}
            min="0"
          />
          
          <button
            onClick={() => incrementStat(statKey, 1)}
            className="p-1 bg-emerald-600 hover:bg-emerald-700 rounded transition-colors"
          >
            <Plus className="w-3 h-3" />
          </button>
        </div>
      </div>
    );
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-zinc-900 rounded-lg p-6 max-w-md w-full mx-4 border border-zinc-700 max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-yellow-400">
            Edit Stats: {player.name}
          </h3>
          <button
            onClick={onCancel}
            className="text-zinc-400 hover:text-white transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="space-y-1 mb-6">
          {/* Scoring Stats */}
          <div className="mb-4">
            <h4 className="text-sm font-medium text-emerald-400 mb-2">Scoring</h4>
            <StatRow label="Points" statKey="points" originalValue={player.stats.points} />
            <StatRow label="FG Made" statKey="fgMade" originalValue={player.stats.fgMade} />
            <StatRow label="FG Att" statKey="fgAttempts" originalValue={player.stats.fgAttempts} />
            <StatRow label="FT Made" statKey="ftMade" originalValue={player.stats.ftMade} />
            <StatRow label="FT Att" statKey="ftAttempts" originalValue={player.stats.ftAttempts} />
          </div>

          {/* Positive Stats */}
          <div className="mb-4">
            <h4 className="text-sm font-medium text-cyan-400 mb-2">Positive Stats</h4>
            <StatRow label="Assists" statKey="assists" originalValue={player.stats.assists} />
            <StatRow label="Off Reb" statKey="offRebounds" originalValue={player.stats.offRebounds} />
            <StatRow label="Def Reb" statKey="defRebounds" originalValue={player.stats.defRebounds} />
            <StatRow label="Steals" statKey="steals" originalValue={player.stats.steals} />
            <StatRow label="Blocks" statKey="blocks" originalValue={player.stats.blocks} />
          </div>

          {/* Negative Stats */}
          <div className="mb-4">
            <h4 className="text-sm font-medium text-red-400 mb-2">Negative Stats</h4>
            <StatRow label="Fouls" statKey="fouls" originalValue={player.stats.fouls} />
            <StatRow label="Turnovers" statKey="turnovers" originalValue={player.stats.turnovers} />
          </div>

          {/* Advanced Stats */}
          <div>
            <h4 className="text-sm font-medium text-indigo-400 mb-2">Advanced</h4>
            <StatRow label="+/-" statKey="plusMinus" originalValue={player.stats.plusMinus} />
          </div>
        </div>

        <div className="flex gap-3">
          <button
            onClick={resetStats}
            className="flex items-center gap-2 px-4 py-2 bg-zinc-700 hover:bg-zinc-600 rounded-lg transition-colors text-zinc-300"
          >
            <RotateCcw className="w-4 h-4" />
            Reset
          </button>
          
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 bg-zinc-700 hover:bg-zinc-600 rounded-lg transition-colors text-zinc-300"
          >
            Cancel
          </button>
          
          <button
            onClick={handleSave}
            className="flex-1 px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded-lg transition-colors text-white font-medium"
          >
            Save Changes
          </button>
        </div>
      </div>
    </div>
  );
}; 


=== ./src/components/GameReview/GameSetupForm.tsx ===
import React, { useState, useEffect } from 'react';
import { Play, Users, Settings, Trophy } from 'lucide-react';
import type { GameFormat } from '../../types/game.types';
import { PlayerImage } from '../PlayerProfiles/PlayerImage';
import { useTeamManagement } from '../../hooks/useTeamManagement';

interface GameSetupFormProps {
  onSetupComplete: (teamId: string, teamName: string, opponent: string, format: GameFormat, players: any[]) => void;
}

interface GamePlayer {
  id: string;
  name: string;
  position?: string;
  profileImageUrl?: string;
  onCourt: boolean;
  stats: {
    points: number;
    fouls: number;
    turnovers: number;
    offRebounds: number;
    defRebounds: number;
    assists: number;
    steals: number;
    blocks: number;
    fgMade: number;
    fgAttempts: number;
    ftMade: number;
    ftAttempts: number;
    plusMinus: number;
    timeOnCourt: number;
  };
  startTime: number | null;
}

export const GameSetupForm: React.FC<GameSetupFormProps> = ({ onSetupComplete }) => {
  const [selectedTeamId, setSelectedTeamId] = useState<string>('');
  const [opponentName, setOpponentName] = useState('');
  const [gameFormat, setGameFormat] = useState<GameFormat>('quarters');
  const [selectedPlayerIds, setSelectedPlayerIds] = useState<string[]>([]);
  
  // Use team management hook
  const teamManagement = useTeamManagement();

  // Get available players based on selected team
  const availablePlayers = selectedTeamId 
    ? teamManagement.getTeamPlayers(selectedTeamId)
    : [];

  // Get selected team name
  const selectedTeam = teamManagement.teams.find(team => team.id === selectedTeamId);
  const teamName = selectedTeam?.name || '';

  // Clear selected players when team changes
  useEffect(() => {
    setSelectedPlayerIds([]);
  }, [selectedTeamId]);

  const handlePlayerToggle = (playerId: string) => {
    setSelectedPlayerIds(prev => 
      prev.includes(playerId) 
        ? prev.filter(id => id !== playerId)
        : [...prev, playerId]
    );
  };

  const handleStartGame = () => {
    if (!teamName.trim() || !opponentName.trim() || selectedPlayerIds.length === 0) {
      alert('Please fill in all fields and select at least one player');
      return;
    }

    if (selectedPlayerIds.length > 15) {
      alert('Maximum 15 players allowed per game');
      return;
    }

    // Convert selected players to game format
    const gamePlayers: GamePlayer[] = selectedPlayerIds.map((playerId, index) => {
      const player = availablePlayers.find(p => p.id === playerId);
      if (!player) {
        throw new Error(`Player with ID ${playerId} not found`);
      }
      return {
        id: player.id,
        name: player.name,
        position: player.position,
        profileImageUrl: player.profileImageUrl,
        onCourt: index < 5, // First 5 players start on court
        stats: {
          points: 0,
          fouls: 0,
          turnovers: 0,
          offRebounds: 0,
          defRebounds: 0,
          assists: 0,
          steals: 0,
          blocks: 0,
          fgMade: 0,
          fgAttempts: 0,
          ftMade: 0,
          ftAttempts: 0,
          plusMinus: 0,
          timeOnCourt: 0
        },
        startTime: index < 5 ? 0 : null
      };
    });

    onSetupComplete(selectedTeamId, teamName.trim(), opponentName.trim(), gameFormat, gamePlayers);
  };

  const isValid = selectedTeamId && opponentName.trim() && selectedPlayerIds.length > 0;

  if (teamManagement.loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-400 mx-auto mb-4"></div>
          <p className="text-zinc-400">Loading teams and players...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-zinc-950 text-white flex items-center justify-center p-4">
      <div className="bg-zinc-900 rounded-lg p-8 max-w-4xl w-full border border-zinc-700">
        <h1 className="text-3xl font-bold mb-8 text-center text-yellow-400 flex items-center justify-center gap-3">
          <Settings className="w-8 h-8" />
          Game Setup
        </h1>

        <div className="space-y-8">
          {/* Basic Game Info */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Select Your Team
              </label>
              <select
                value={selectedTeamId}
                onChange={(e) => setSelectedTeamId(e.target.value)}
                className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:outline-none"
              >
                <option value="">Choose a team...</option>
                {teamManagement.teams.map(team => (
                  <option key={team.id} value={team.id}>
                    {team.name} ({teamManagement.getTeamPlayers(team.id).length} players)
                  </option>
                ))}
              </select>
              {teamManagement.teams.length === 0 && (
                <p className="text-xs text-zinc-400 mt-1">
                  No teams found. Create teams in the "My Teams" tab first.
                </p>
              )}
            </div>

            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Opponent Team
              </label>
              <input
                type="text"
                value={opponentName}
                onChange={(e) => setOpponentName(e.target.value)}
                placeholder="Enter opponent name"
                className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Game Format
              </label>
              <select
                value={gameFormat}
                onChange={(e) => setGameFormat(e.target.value as GameFormat)}
                className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:outline-none"
              >
                <option value="quarters">4 Quarters</option>
                <option value="halves">2 Halves</option>
              </select>
            </div>
          </div>

          {/* Player Selection */}
          <div>
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold text-yellow-400 flex items-center gap-2">
                <Users className="w-5 h-5" />
                Select Players ({selectedPlayerIds.length} selected)
              </h2>
              {!selectedTeamId && (
                <p className="text-sm text-zinc-400">
                  Please select a team first to see available players.
                </p>
              )}
              {selectedTeamId && availablePlayers.length === 0 && (
                <p className="text-sm text-zinc-400">
                  No players assigned to this team. Assign players in the "Players" tab.
                </p>
              )}
            </div>

            {selectedTeamId && availablePlayers.length > 0 ? (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-96 overflow-y-auto">
                {availablePlayers.map((player) => (
                  <div
                    key={player.id}
                    onClick={() => handlePlayerToggle(player.id)}
                    className={`p-4 rounded-lg border cursor-pointer transition-all ${
                      selectedPlayerIds.includes(player.id)
                        ? 'border-yellow-500 bg-yellow-500/10'
                        : 'border-zinc-600 bg-zinc-800 hover:border-zinc-500'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        {/* Profile Picture */}
                        <div className="w-10 h-10 rounded-full bg-zinc-700 border border-zinc-600 flex items-center justify-center overflow-hidden flex-shrink-0">
                          <PlayerImage 
                            profileImageUrl={player.profileImageUrl}
                            className="w-full h-full object-cover"
                            alt={player.name}
                          />
                        </div>
                        
                        <div>
                          <h3 className="font-medium text-white">{player.name}</h3>
                          <div className="flex items-center gap-2 text-sm text-zinc-400 mt-1">
                            {player.position && (
                              <span className="bg-zinc-700 px-2 py-0.5 rounded">{player.position}</span>
                            )}
                          </div>
                          <div className="text-xs text-zinc-500 mt-1">
                            {player.teams.length > 0 ? `Member of ${player.teams.length} team(s)` : 'No team assignments'}
                          </div>
                        </div>
                      </div>
                      <div className={`w-5 h-5 rounded-full border-2 flex items-center justify-center ${
                        selectedPlayerIds.includes(player.id)
                          ? 'border-yellow-500 bg-yellow-500'
                          : 'border-zinc-500'
                      }`}>
                        {selectedPlayerIds.includes(player.id) && (
                          <div className="w-2 h-2 bg-black rounded-full"></div>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-8 text-zinc-400">
                {!selectedTeamId ? (
                  <>
                    <Trophy className="w-16 h-16 mx-auto mb-4 text-zinc-600" />
                    <p>Select a team to see available players</p>
                    <p className="text-sm mt-2">Choose your team from the dropdown above</p>
                  </>
                ) : (
                  <>
                    <Users className="w-16 h-16 mx-auto mb-4 text-zinc-600" />
                    <p>No players assigned to this team</p>
                    <p className="text-sm mt-2">Assign players to this team in the "Players" tab</p>
                  </>
                )}
              </div>
            )}
          </div>

          {/* Game Info Summary */}
          {selectedPlayerIds.length > 0 && (
            <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-700">
              <h3 className="font-medium text-white mb-2">Game Summary</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div>
                  <span className="text-zinc-400">Starting 5:</span>
                  <div className="text-yellow-400 font-medium">
                    {selectedPlayerIds.slice(0, 5).map(id => 
                      availablePlayers.find(p => p.id === id)?.name
                    ).join(', ')}
                  </div>
                </div>
                <div>
                  <span className="text-zinc-400">Bench:</span>
                  <div className="text-zinc-300">
                    {selectedPlayerIds.length > 5 ? `${selectedPlayerIds.length - 5} players` : 'None'}
                  </div>
                </div>
                <div>
                  <span className="text-zinc-400">Format:</span>
                  <div className="text-zinc-300">
                    {gameFormat === 'quarters' ? '4 Quarters' : '2 Halves'}
                  </div>
                </div>
                <div>
                  <span className="text-zinc-400">Total Players:</span>
                  <div className="text-emerald-400 font-medium">{selectedPlayerIds.length}</div>
                </div>
              </div>
            </div>
          )}

          {/* Start Game Button */}
          <div className="text-center">
            <button
              onClick={handleStartGame}
              disabled={!isValid}
              className="bg-yellow-500 hover:bg-yellow-600 disabled:bg-zinc-600 disabled:cursor-not-allowed px-8 py-4 rounded-lg font-bold text-black text-lg transition-all flex items-center gap-3 mx-auto"
            >
              <Play className="w-6 h-6" />
              Start Game Review
            </button>
            {!isValid && (
              <p className="text-sm text-zinc-400 mt-2">
                Please select a team, enter opponent name, and choose at least one player
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}; 


=== ./src/components/GameReview/GameReview.tsx ===
import React, { useState, useCallback } from 'react';
import type { GameFormat, PeriodScore, StatType } from '../../types/game.types';

// Components (keeping the original game components)
import { GameClock } from '../GameClock';
import { ScoreBoard } from '../ScoreBoard';
import { StatButtons, BoxScore } from '../StatTracker';
import { GameSetupForm } from './GameSetupForm';
import { SubstitutionModal } from '../PlayerManagement/SubstitutionModal';
import { StatCorrectionModal } from './StatCorrectionModal';
import { ConfirmationModal } from './ConfirmationModal';
import { GameScoreEditModal } from './GameScoreEditModal';
import { ExportModal } from './ExportModal';
import Button from '../ui/Button';

// Hooks
import { useGameClock } from '../../hooks/useGameClock';
import { useGameStats } from '../../hooks/useGameStats';

// Utils
import { calculateTeamFouls } from '../../utils/statCalculations';
import { createPeriodScore, getMaxPeriods, createAutomaticPeriodScores } from '../../utils/gameHelpers';

// API Service
import { api } from '../../services/api';

// Icons
import { Users, BarChart3, Edit3, Download } from 'lucide-react';

interface GameReviewProps {
  // Props can be added here as needed
}

interface GamePlayer {
  id: string;
  name: string;
  position?: string;
  profileImageUrl?: string;
  onCourt: boolean;
  stats: {
    points: number;
    fouls: number;
    turnovers: number;
    offRebounds: number;
    defRebounds: number;
    assists: number;
    steals: number;
    blocks: number;
    fgMade: number;
    fgAttempts: number;
    ftMade: number;
    ftAttempts: number;
    plusMinus: number;
    timeOnCourt: number;
  };
  startTime: number | null;
}

export const GameReview: React.FC<GameReviewProps> = () => {
  // Setup state
  const [isSetup, setIsSetup] = useState(true);
  const [teamName, setTeamName] = useState('');
  const [opponentName, setOpponentName] = useState('');
  const [gameFormat, setGameFormat] = useState<GameFormat>('quarters');
  const [initialPlayers, setInitialPlayers] = useState<GamePlayer[]>([]);
  
  // Game state
  const [currentGame, setCurrentGame] = useState<any>(null);
  const [currentPeriod, setCurrentPeriod] = useState(1);
  const [teamScore, setTeamScore] = useState(0);
  const [opponentScore, setOpponentScore] = useState(0);
  const [teamTimeouts, setTeamTimeouts] = useState(0);
  const [opponentTimeouts, setOpponentTimeouts] = useState(0);
  const [periodScores, setPeriodScores] = useState<PeriodScore[]>([]);
  const [periodStartScore, setPeriodStartScore] = useState({ team: 0, opponent: 0 });

  // Substitution state
  const [isSubstitutionModalOpen, setIsSubstitutionModalOpen] = useState(false);
  const [playerComingIn, setPlayerComingIn] = useState<GamePlayer | null>(null);

  // Stat correction state
  const [isStatCorrectionModalOpen, setIsStatCorrectionModalOpen] = useState(false);
  const [playerToCorrect, setPlayerToCorrect] = useState<GamePlayer | null>(null);

  // Delete confirmation state
  const [isDeleteConfirmModalOpen, setIsDeleteConfirmModalOpen] = useState(false);
  const [playerToDelete, setPlayerToDelete] = useState<GamePlayer | null>(null);

  // Score edit state
  const [isScoreEditModalOpen, setIsScoreEditModalOpen] = useState(false);

  // Export state
  const [isExportModalOpen, setIsExportModalOpen] = useState(false);

  
  // Initialize game stats hook - this manages the actual player state
  const gameStats = useGameStats(initialPlayers);
  
  // Stable callback for game clock to prevent interval recreation
  const handlePlayersUpdate = useCallback((updater: (players: any[]) => any[]) => {
    gameStats.setPlayers((prevPlayers) => {
      // Convert GamePlayer[] to Player[] for the updater function
      const convertedPlayers = prevPlayers.map((player, index) => ({
        ...player,
        id: parseInt(player.id.replace(/\D/g, '')) || index,
      }));
      
      // Apply the updater function
      const updatedPlayers = updater(convertedPlayers);
      
      // Convert back to GamePlayer[]
      return updatedPlayers.map((player, index) => ({
        ...player,
        id: prevPlayers[index]?.id || player.id.toString(),
      }));
    });
  }, [gameStats.setPlayers]);
  
  const gameClock = useGameClock(handlePlayersUpdate);

  // Note: Time tracking is handled by useGameClock hook, no need for duplicate interval here

  const handleSetupComplete = async (teamId: string, teamName: string, opponent: string, format: GameFormat, players: GamePlayer[]) => {
    setTeamName(teamName);
    setOpponentName(opponent);
    setGameFormat(format);
    setInitialPlayers(players);
    
    // Create game record in database using existing team
    try {
      const response = await api.games.create({
        homeTeamId: teamId,
        homeTeamName: teamName,
        awayTeamName: opponent,
        gameFormat: format,
        gameDate: new Date().toISOString(),
        homeTeamScore: 0,
        awayTeamScore: 0,
        isCompleted: false,
        periodScores: []
      });
      
      if (response.success) {
        setCurrentGame(response.data);
        setIsSetup(false);
      } else {
        console.error('Error creating game:', response.error);
      }
    } catch (error) {
      console.error('Error creating game:', error);
    }
  };

  const handleStatUpdate = (statType: StatType, value?: number) => {
    if (!gameStats.selectedPlayerId) return;
    
    gameStats.updatePlayerStat(gameStats.selectedPlayerId, statType, value);
    
    // Handle point scoring
    if (statType === 'points' && value) {
      setTeamScore(prev => prev + value);
      gameStats.updatePlusMinus(value, true);
    }
  };

  const handleOpponentScore = (points: number) => {
    setOpponentScore(prev => prev + points);
    gameStats.updatePlusMinus(points, false);
  };

  const handleEndPeriod = () => {
    const periodScore = createPeriodScore(
      currentPeriod,
      gameFormat,
      teamScore,
      opponentScore,
      periodStartScore.team,
      periodStartScore.opponent
    );
    
    const newPeriodScores = [...periodScores, periodScore];
    setPeriodScores(newPeriodScores);
    setPeriodStartScore({ team: teamScore, opponent: opponentScore });
    
    if (currentPeriod < getMaxPeriods(gameFormat)) {
      setCurrentPeriod(currentPeriod + 1);
    }
    
    gameClock.resetClock();
  };

  const handleSubstitutionRequest = (player: GamePlayer) => {
    setPlayerComingIn(player);
    setIsSubstitutionModalOpen(true);
  };

  const handleSubstitution = (playerOutId: number) => {
    if (!playerComingIn) return;
    
    // Find the actual string ID of the player going out
    const playerOut = gameStats.players.find(p => p.onCourt && 
      (parseInt(p.id.replace(/\D/g, '')) || 0) === playerOutId);
    
    if (!playerOut) {
      console.error('Player to substitute out not found!');
      return;
    }
    
    console.log('Substitution:', {
      playerInId: playerComingIn.id,
      playerInName: playerComingIn.name,
      playerOutId: playerOut.id,
      playerOutName: playerOut.name,
      currentTime: gameClock.gameClock
    });
    
    gameStats.substitutePlayer(playerComingIn.id, playerOut.id, gameClock.gameClock);
    setIsSubstitutionModalOpen(false);
    setPlayerComingIn(null);
  };

  const handleCancelSubstitution = () => {
    setIsSubstitutionModalOpen(false);
    setPlayerComingIn(null);
  };

  const handleStatCorrectionRequest = (player: GamePlayer) => {
    setPlayerToCorrect(player);
    setIsStatCorrectionModalOpen(true);
  };

  const handleStatCorrection = (playerId: string, newStats: GamePlayer['stats']) => {
    const handleTeamScoreChange = (pointsDifference: number) => {
      setTeamScore(prev => prev + pointsDifference);
      console.log(`Team score adjusted by ${pointsDifference} points`);
    };

    gameStats.correctPlayerStats(playerId, newStats, handleTeamScoreChange);
    setIsStatCorrectionModalOpen(false);
    setPlayerToCorrect(null);
  };

  const handleCancelStatCorrection = () => {
    setIsStatCorrectionModalOpen(false);
    setPlayerToCorrect(null);
  };

  const handleDeletePlayerStatsRequest = (player: GamePlayer) => {
    setPlayerToDelete(player);
    setIsDeleteConfirmModalOpen(true);
  };

  const handleDeletePlayerStats = () => {
    if (!playerToDelete) return;

    const handleTeamScoreChange = (pointsDifference: number) => {
      setTeamScore(prev => prev + pointsDifference);
      console.log(`Team score adjusted by ${pointsDifference} points due to stat deletion`);
    };

    gameStats.resetPlayerStats(playerToDelete.id, handleTeamScoreChange);
    setIsDeleteConfirmModalOpen(false);
    setPlayerToDelete(null);
  };

  const handleCancelDeletePlayerStats = () => {
    setIsDeleteConfirmModalOpen(false);
    setPlayerToDelete(null);
  };

  const handleEditScoreRequest = () => {
    setIsScoreEditModalOpen(true);
  };

  const handleScoreEdit = (newTeamScore: number, newOpponentScore: number) => {
    setTeamScore(newTeamScore);
    setOpponentScore(newOpponentScore);
    setIsScoreEditModalOpen(false);
    
    console.log('Score edited:', {
      newTeamScore,
      newOpponentScore,
      previousTeamScore: teamScore,
      previousOpponentScore: opponentScore
    });
  };

  const handleCancelScoreEdit = () => {
    setIsScoreEditModalOpen(false);
  };

  const handleExportRequest = () => {
    setIsExportModalOpen(true);
  };

  const handleCancelExport = () => {
    setIsExportModalOpen(false);
  };

  // Helper function to create play-by-play events from player stats
  const createPlayByPlayEvents = async (gameId: string, players: GamePlayer[], finalHomeScore: number, finalAwayScore: number) => {
    console.log('Creating play-by-play events...', {
      gameId,
      playerCount: players.length,
      finalHomeScore,
      finalAwayScore,
      totalGameTime: gameClock.gameClock
    });

    let eventTime = 0;
    let currentHomeScore = 0;
    const currentAwayScore = 0;
    let eventsCreated = 0;
    
    // Calculate total events and time distribution
    const totalGameTime = Math.max(gameClock.gameClock || 0, 3600); // Minimum 1 hour if no game time
    const totalEvents = players.reduce((total, player) => 
      total + player.stats.fgMade + player.stats.ftMade + player.stats.assists + 
      player.stats.offRebounds + player.stats.defRebounds + player.stats.steals + 
      player.stats.blocks + player.stats.fouls + player.stats.turnovers, 0
    );
    
    const timeIncrement = totalEvents > 0 ? totalGameTime / totalEvents : 60; // 1 minute default
    console.log(`Distributing ${totalEvents} events over ${totalGameTime} seconds (${timeIncrement.toFixed(2)}s per event)`);

    // Helper function to create a single event with error handling
    const createSingleEvent = async (player: GamePlayer, eventType: string, eventDetail: string, points?: number) => {
      try {
        eventTime += timeIncrement;
        const period = Math.min(Math.ceil((eventTime / totalGameTime) * (gameFormat === 'quarters' ? 4 : 2)), gameFormat === 'quarters' ? 4 : 2);
        const periodDuration = totalGameTime / (gameFormat === 'quarters' ? 4 : 2);
        const periodTime = Math.floor(eventTime % periodDuration);
        const minutes = Math.floor(periodTime / 60);
        const seconds = Math.floor(periodTime % 60);
        
        const eventData = {
          gameId,
          playerId: player.id,
          timestamp: new Date().toISOString(),
          gameTime: eventTime,
          period: Math.max(1, period),
          periodTime: `${minutes}:${seconds.toString().padStart(2, '0')}`,
          eventType: eventType,
          eventDetail,
          isHomeTeam: true,
          homeTeamScore: Math.min(currentHomeScore, finalHomeScore),
          awayTeamScore: Math.min(currentAwayScore, finalAwayScore),
          ...(points ? { points } : {})
        };

        const response = await api.stats.createEvent(eventData);
        if (response.success) {
          eventsCreated++;
          
          if (eventsCreated % 10 === 0) {
            console.log(`Created ${eventsCreated}/${totalEvents} events...`);
          }
        } else {
          console.error(`Failed to create ${eventType} event for player ${player.name}:`, response.error);
        }
      } catch (error) {
        console.error(`Failed to create ${eventType} event for player ${player.name}:`, error);
        // Continue with other events
      }
    };

    for (const player of players) {
      console.log(`Processing events for player: ${player.name}`);
      
      // Create field goal events
      for (let i = 0; i < player.stats.fgMade; i++) {
        const isThreePointer = Math.random() > 0.7;
        const points = isThreePointer ? 3 : 2;
        currentHomeScore += points;
        await createSingleEvent(player, 'SCORE', isThreePointer ? '3PT' : '2PT', points);
      }

      // Create free throw events
      for (let i = 0; i < player.stats.ftMade; i++) {
        currentHomeScore += 1;
        await createSingleEvent(player, 'SCORE', 'FT', 1);
      }

      // Create assist events
      for (let i = 0; i < player.stats.assists; i++) {
        await createSingleEvent(player, 'ASSIST', 'Assist');
      }

      // Create rebound events
      for (let i = 0; i < player.stats.offRebounds; i++) {
        await createSingleEvent(player, 'REBOUND', 'Offensive');
      }
      for (let i = 0; i < player.stats.defRebounds; i++) {
        await createSingleEvent(player, 'REBOUND', 'Defensive');
      }

      // Create other events
      const otherEvents = [
        { count: player.stats.steals, type: 'STEAL', detail: 'Steal' },
        { count: player.stats.blocks, type: 'BLOCK', detail: 'Block' },
        { count: player.stats.fouls, type: 'FOUL', detail: 'Personal Foul' },
        { count: player.stats.turnovers, type: 'TURNOVER', detail: 'Turnover' }
      ];

      for (const eventGroup of otherEvents) {
        for (let i = 0; i < eventGroup.count; i++) {
          await createSingleEvent(player, eventGroup.type, eventGroup.detail);
        }
      }
    }

    console.log(`Successfully created ${eventsCreated} play-by-play events`);
  };

  // Helper function to create period statistics
  const createPeriodStatistics = async (gameId: string, periodScores: any[], gameFormat: GameFormat) => {
    console.log('Creating period statistics with data:', periodScores);
    
    for (let i = 0; i < periodScores.length; i++) {
      const period = periodScores[i];
      const periodNumber = i + 1;
      
      // Use cumulative scores (totalTeamScore/totalOpponentScore) if available,
      // otherwise fall back to teamScore/opponentScore
      const homeScore = period.totalTeamScore ?? period.teamScore ?? 0;
      const awayScore = period.totalOpponentScore ?? period.opponentScore ?? 0;
      
      console.log(`Creating PeriodStats for period ${periodNumber}:`, {
        homeScore,
        awayScore,
        periodType: gameFormat === 'quarters' ? 'quarter' : 'half'
      });
      
      try {
        const response = await api.stats.createOrUpdate({
          gameId,
          period: periodNumber,
          periodType: gameFormat === 'quarters' ? 'quarter' : 'half',
          homeTeamScore: homeScore,
          awayTeamScore: awayScore,
          startTime: new Date().toISOString(), // Ideally this would be the actual period start time
          endTime: new Date().toISOString(),   // Ideally this would be the actual period end time
          duration: Math.floor((gameClock.gameClock || 0) / (gameFormat === 'quarters' ? 4 : 2)), // Estimate
          homeTeamStats: {},
          awayTeamStats: {},
        });
        console.log(`PeriodStats created successfully for period ${periodNumber}:`, response);
      } catch (error) {
        console.error(`Failed to create PeriodStats for period ${periodNumber}:`, error);
        throw error;
      }
    }
  };

  const handleFinishGame = async () => {
    if (!currentGame) return;

    console.log('Starting game save process...', {
      gameId: currentGame.id,
      teamScore,
      opponentScore,
      playerCount: gameStats.players.length,
      periodScoresCount: periodScores.length,
      gameFormat
    });

    try {
      // Determine which period scores to use
      let finalPeriodScores = periodScores;
      
      // If no manual period data exists, create automatic period distribution
      if (periodScores.length === 0) {
        console.log('No manual period data found, creating automatic period distribution...');
        finalPeriodScores = createAutomaticPeriodScores(teamScore, opponentScore, gameFormat);
        console.log('Created automatic period scores:', finalPeriodScores);
      }

      // Update game with final scores and completion status
      console.log('Updating game record...');
      const updateResponse = await api.games.update(currentGame.id, {
        homeTeamScore: teamScore,
        awayTeamScore: opponentScore,
        isCompleted: true,
        totalDuration: gameClock.gameClock,
        periodScores: finalPeriodScores
      });
      
      if (updateResponse.success) {
        console.log('Game record updated successfully');
      } else {
        console.error('Error updating game:', updateResponse.error);
      }

      // Validate player data before creating events
      if (!gameStats.players || gameStats.players.length === 0) {
        console.warn('No player data available, skipping play-by-play events');
      } else {
        console.log(`Creating play-by-play events for ${gameStats.players.length} players...`);
        try {
          await createPlayByPlayEvents(currentGame.id, gameStats.players, teamScore, opponentScore);
          console.log('Play-by-play events created successfully');
        } catch (error) {
          console.error('Error creating play-by-play events:', error);
          // Don't throw - continue with other saves
        }
      }

      // Create period statistics
      console.log(`Creating period statistics for ${finalPeriodScores.length} periods...`);
      try {
        await createPeriodStatistics(currentGame.id, finalPeriodScores, gameFormat);
        console.log('Period statistics created successfully');
      } catch (error) {
        console.error('Error creating period statistics:', error);
        // Don't throw - continue with other saves
      }

      // Save individual player stats
      console.log('Saving individual player statistics...');
      for (const player of gameStats.players) {
        try {
          const statResponse = await api.stats.createOrUpdate({
            gameId: currentGame.id,
            playerId: player.id,
            points: player.stats.points,
            assists: player.stats.assists,
            offRebounds: player.stats.offRebounds,
            defRebounds: player.stats.defRebounds,
            steals: player.stats.steals,
            blocks: player.stats.blocks,
            fouls: player.stats.fouls,
            turnovers: player.stats.turnovers,
            fgMade: player.stats.fgMade,
            fgAttempts: player.stats.fgAttempts,
            ftMade: player.stats.ftMade,
            ftAttempts: player.stats.ftAttempts,
            minutesPlayed: Math.floor(player.stats.timeOnCourt / 60),
            plusMinus: player.stats.plusMinus,
            startedOnCourt: player.onCourt
          });
          
          if (!statResponse.success) {
            console.error(`Error saving stats for player ${player.name}:`, statResponse.error);
          }
        } catch (error) {
          console.error(`Error saving stats for player ${player.name}:`, error);
        }

        // Update player career stats
        try {
          const playerResponse = await api.players.getById(player.id);
          if (playerResponse.success) {
            const data = playerResponse.data;
            const totalRebounds = player.stats.offRebounds + player.stats.defRebounds;
            
            const updateResponse = await api.players.update(player.id, {
              totalGamesPlayed: (data.totalGamesPlayed || 0) + 1,
              careerPoints: (data.careerPoints || 0) + player.stats.points,
              careerAssists: (data.careerAssists || 0) + player.stats.assists,
              careerRebounds: (data.careerRebounds || 0) + totalRebounds,
              careerSteals: (data.careerSteals || 0) + player.stats.steals,
              careerBlocks: (data.careerBlocks || 0) + player.stats.blocks,
              careerFouls: (data.careerFouls || 0) + player.stats.fouls,
              careerTurnovers: (data.careerTurnovers || 0) + player.stats.turnovers,
              careerFgMade: (data.careerFgMade || 0) + player.stats.fgMade,
              careerFgAttempts: (data.careerFgAttempts || 0) + player.stats.fgAttempts,
              careerFtMade: (data.careerFtMade || 0) + player.stats.ftMade,
              careerFtAttempts: (data.careerFtAttempts || 0) + player.stats.ftAttempts,
              careerMinutesPlayed: (data.careerMinutesPlayed || 0) + Math.floor(player.stats.timeOnCourt / 60)
            });
            
            if (!updateResponse.success) {
              console.error(`Error updating career stats for player ${player.name}:`, updateResponse.error);
            }
          }
        } catch (error) {
          console.error(`Error updating career stats for player ${player.name}:`, error);
        }
      }

      console.log('Game save process completed successfully!');
      alert('Game completed and saved successfully! All statistics, play-by-play events, and period data have been recorded.');
      
      // Reset for new game
      setIsSetup(true);
      setCurrentGame(null);
      setTeamScore(0);
      setOpponentScore(0);
      setCurrentPeriod(1);
      setPeriodScores([]);
      setPeriodStartScore({ team: 0, opponent: 0 });
      gameClock.resetClock();
      
    } catch (error) {
      console.error('Critical error during game save:', error);
      alert(`Error saving game: ${error instanceof Error ? error.message : 'Unknown error'}. Please check the console for details and try again.`);
    }
  };

  // Convert GamePlayer to Player format for legacy components
  const convertToLegacyPlayers = (gamePlayers: GamePlayer[]) => {
    return gamePlayers.map((player: GamePlayer, index: number) => ({
      ...player,
      id: parseInt(player.id.replace(/\D/g, '')) || index, // Convert string ID to number
    }));
  };

  const teamFouls = calculateTeamFouls(convertToLegacyPlayers(gameStats.players));

  if (isSetup) {
    return <GameSetupForm onSetupComplete={handleSetupComplete} />;
  }

  return (
    <div className="h-full flex flex-col space-y-6">
      {/* Centered Scoreboard */}
      <div className="bg-gradient-to-r from-zinc-900 to-zinc-800 rounded-xl p-6 border border-zinc-700">
        <div className="flex justify-center">
          <div className="relative text-center bg-gradient-to-r from-zinc-800 to-zinc-700 rounded-2xl px-12 py-8 border-2 border-yellow-400/30 shadow-2xl group">
            <div className="text-6xl font-black text-yellow-400 tracking-wider flex items-center justify-center gap-6">
              <span className="text-white text-3xl font-bold uppercase">{teamName}</span>
              <span className="text-emerald-400">{teamScore}</span>
              <span className="text-zinc-400 text-4xl">-</span>
              <span className="text-red-400">{opponentScore}</span>
              <span className="text-white text-3xl font-bold uppercase">{opponentName}</span>
            </div>
            <div className="mt-4 flex items-center justify-center gap-6 text-sm text-zinc-400">
              <span className="flex items-center gap-2">
                <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                {gameFormat === 'quarters' ? 'Quarter' : 'Half'} {currentPeriod}
              </span>
              <span></span>
              <span>Active: {gameStats.players.filter(p => p.onCourt).length}/5</span>
            </div>
            
            {/* Edit Score Button */}
            <Button variant="secondary" size="small" className="p-2"
              onClick={handleEditScoreRequest}
              title="Edit Score"
            >
              <Edit3 className="w-4 h-4 text-zinc-400 hover:text-yellow-400" />
            </Button>
          </div>
        </div>
      </div>

      {/* Main Dashboard Grid */}
      <div className="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-6 min-h-0">
        
        {/* Left Column - Scoreboard & Game Clock */}
        <div className="flex flex-col space-y-4 min-h-0">
          
          {/* Game Clock Card */}
          <div className="bg-zinc-900 rounded-xl border border-zinc-700 p-4">
            <GameClock
              gameClock={gameClock.gameClock}
              isClockRunning={gameClock.isClockRunning}
              currentPeriod={currentPeriod}
              gameFormat={gameFormat}
              onClockToggle={gameClock.toggleClock}
              onPeriodChange={setCurrentPeriod}
              onEndPeriod={handleEndPeriod}
            />
          </div>
          
          {/* ScoreBoard Card */}
          <div className="bg-zinc-900 rounded-xl border border-zinc-700 p-4">
            <ScoreBoard
              teamName={teamName}
              opponentName={opponentName}
              teamScore={teamScore}
              opponentScore={opponentScore}
              teamFouls={teamFouls}
              teamTimeouts={teamTimeouts}
              opponentTimeouts={opponentTimeouts}
              onOpponentScore={handleOpponentScore}
              onTeamTimeout={() => setTeamTimeouts(prev => prev + 1)}
              onOpponentTimeout={() => setOpponentTimeouts(prev => prev + 1)}
            />
          </div>
          
          {/* Stats Buttons Card */}
          <div className="bg-zinc-900 rounded-xl border border-zinc-700 p-4 flex-1">
            <StatButtons
              selectedPlayerName={gameStats.selectedPlayerName}
              onStatUpdate={handleStatUpdate}
              isGameStarted={gameClock.gameClock > 0 || gameClock.isClockRunning}
            />
          </div>
        </div>
      </div>

      {/* Bottom Section - Player Selection */}
      <div className="max-w-4xl mx-auto">
        
        {/* Player Management */}
        <div className="bg-zinc-900 rounded-xl border border-zinc-700 p-6">
          <h3 className="text-lg font-semibold text-yellow-400 mb-4 flex items-center gap-2">
            <Users className="w-5 h-5" />
            Player Management
          </h3>
          
          {/* On Court Players */}
          <div className="mb-6">
            <h4 className="text-md font-medium text-emerald-400 mb-3">On Court ({gameStats.players.filter(p => p.onCourt).length}/5)</h4>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-3">
              {gameStats.players.filter(p => p.onCourt).map((player) => (
                <div key={player.id} className="relative group">
                  <Button
                    onClick={() => gameStats.setSelectedPlayerId(player.id)}
                    className={`w-full p-3 rounded-lg text-left transition-all ${
                      gameStats.selectedPlayerId === player.id
                        ? 'bg-gradient-to-r from-yellow-500 to-yellow-600 text-black shadow-lg border-2 border-yellow-400'
                        : 'bg-gradient-to-r from-emerald-600 to-emerald-700 text-white hover:from-emerald-500 hover:to-emerald-600'
                    }`}
                  >
                    <div className="font-medium text-sm">{player.name}</div>
                    <div className="text-xs opacity-75 mt-1">
                      {player.stats.points}pts  {player.stats.assists}ast  {player.stats.fouls}f
                    </div>
                  </Button>
                  <Button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleStatCorrectionRequest(player);
                    }}
                    className="absolute top-1 right-1 p-1.5 bg-zinc-800 hover:bg-zinc-700 rounded opacity-0 group-hover:opacity-100 transition-opacity"
                    title="Edit Stats"
                  >
                    <Edit3 className="w-3 h-3 text-zinc-400 hover:text-white" />
                  </Button>
                </div>
              ))}
            </div>
          </div>

          {/* Bench Players */}
          <div>
            <h4 className="text-md font-medium text-zinc-400 mb-3">Bench ({gameStats.players.filter(p => !p.onCourt).length})</h4>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
              {gameStats.players.filter(p => !p.onCourt).map((player) => (
                <div
                  key={player.id}
                  className="p-3 rounded-lg bg-zinc-800 border border-zinc-600 text-zinc-300 flex justify-between items-center group relative"
                >
                  <div className="flex-1">
                    <div className="font-medium text-sm">{player.name}</div>
                    <div className="text-xs opacity-75 mt-1">
                      {player.stats.points}pts  {player.stats.assists}ast  {player.stats.fouls}f
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      onClick={() => handleStatCorrectionRequest(player)}
                      className="p-1.5 bg-zinc-700 hover:bg-zinc-600 rounded opacity-0 group-hover:opacity-100 transition-opacity"
                      title="Edit Stats"
                    >
                      <Edit3 className="w-3 h-3 text-zinc-400 hover:text-white" />
                    </Button>
                    <Button
                      onClick={() => handleSubstitutionRequest(player)}
                      className="bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded text-xs transition-colors"
                    >
                      Sub In
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Box Score - Full Width */}
      <div className="bg-zinc-900 rounded-xl border border-zinc-700 p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-yellow-400 flex items-center gap-2">
            <BarChart3 className="w-5 h-5" />
            Live Box Score
          </h3>
          
          <Button
            onClick={handleExportRequest}
            className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors text-white font-medium"
          >
            <Download className="w-4 h-4" />
            Export Data
          </Button>
        </div>
        <div className="overflow-x-auto">
          <BoxScore 
            players={convertToLegacyPlayers(gameStats.players)} 
            teamName={teamName}
            onEditPlayerStats={(player) => {
              // Convert legacy player back to GamePlayer format
              const gamePlayer = gameStats.players.find(p => p.id === player.id.toString() || parseInt(p.id.replace(/\D/g, '')) === player.id);
              if (gamePlayer) {
                handleStatCorrectionRequest(gamePlayer);
              }
            }}
            onDeletePlayerStats={(player) => {
              // Convert legacy player back to GamePlayer format
              const gamePlayer = gameStats.players.find(p => p.id === player.id.toString() || parseInt(p.id.replace(/\D/g, '')) === player.id);
              if (gamePlayer) {
                handleDeletePlayerStatsRequest(gamePlayer);
              }
            }}
          />
        </div>
      </div>

      {/* Finish Game Button */}
      <div className="text-center pt-4 border-t border-zinc-700">
        <Button
          onClick={handleFinishGame}
          className="bg-gradient-to-r from-emerald-600 to-emerald-700 hover:from-emerald-500 hover:to-emerald-600 px-12 py-4 rounded-xl font-bold text-white transition-all transform hover:scale-105 shadow-lg text-lg"
        >
           Finish & Save Game
        </Button>
      </div>

      {/* Substitution Modal */}
      <SubstitutionModal
        isOpen={isSubstitutionModalOpen}
        playerComingIn={playerComingIn ? convertToLegacyPlayers([playerComingIn])[0] : null}
        playersOnCourt={convertToLegacyPlayers(gameStats.players.filter(p => p.onCourt))}
        onSubstitute={handleSubstitution}
        onCancel={handleCancelSubstitution}
      />

      {/* Stat Correction Modal */}
      <StatCorrectionModal
        isOpen={isStatCorrectionModalOpen}
        player={playerToCorrect}
        onSave={handleStatCorrection}
        onCancel={handleCancelStatCorrection}
      />

      {/* Delete Confirmation Modal */}
      <ConfirmationModal
        isOpen={isDeleteConfirmModalOpen}
        title="Delete Player Stats"
        message={`Are you sure you want to delete all stats for ${playerToDelete?.name}? This action cannot be undone. The player's time on court will be preserved.`}
        confirmText="Delete Stats"
        cancelText="Cancel"
        onConfirm={handleDeletePlayerStats}
        onCancel={handleCancelDeletePlayerStats}
        type="danger"
      />

      {/* Game Score Edit Modal */}
      <GameScoreEditModal
        isOpen={isScoreEditModalOpen}
        teamName={teamName}
        opponentName={opponentName}
        currentTeamScore={teamScore}
        currentOpponentScore={opponentScore}
        onSave={handleScoreEdit}
        onCancel={handleCancelScoreEdit}
      />

      {/* Export Modal */}
      <ExportModal
        isOpen={isExportModalOpen}
        teamName={teamName}
        opponentName={opponentName}
        teamScore={teamScore}
        opponentScore={opponentScore}
        players={convertToLegacyPlayers(gameStats.players)}
        gameDate={currentGame?.gameDate ? new Date(currentGame.gameDate) : new Date()}
        totalDuration={gameClock.gameClock}
        onCancel={handleCancelExport}
      />

    </div>
  );
};


=== ./src/components/GameReview/GameScoreEditModal.tsx ===
import React, { useState, useEffect } from 'react';
import { X, Save, RotateCcw, Target } from 'lucide-react';

interface GameScoreEditModalProps {
  isOpen: boolean;
  teamName: string;
  opponentName: string;
  currentTeamScore: number;
  currentOpponentScore: number;
  onSave: (teamScore: number, opponentScore: number) => void;
  onCancel: () => void;
}

export const GameScoreEditModal: React.FC<GameScoreEditModalProps> = ({
  isOpen,
  teamName,
  opponentName,
  currentTeamScore,
  currentOpponentScore,
  onSave,
  onCancel,
}) => {
  const [teamScore, setTeamScore] = useState(currentTeamScore);
  const [opponentScore, setOpponentScore] = useState(currentOpponentScore);

  // Update local state when props change
  useEffect(() => {
    setTeamScore(currentTeamScore);
    setOpponentScore(currentOpponentScore);
  }, [currentTeamScore, currentOpponentScore, isOpen]);

  if (!isOpen) return null;

  const handleSave = () => {
    onSave(teamScore, opponentScore);
  };

  const handleReset = () => {
    setTeamScore(currentTeamScore);
    setOpponentScore(currentOpponentScore);
  };

  const adjustScore = (team: 'home' | 'away', amount: number) => {
    if (team === 'home') {
      setTeamScore(Math.max(0, teamScore + amount));
    } else {
      setOpponentScore(Math.max(0, opponentScore + amount));
    }
  };

  const hasChanges = teamScore !== currentTeamScore || opponentScore !== currentOpponentScore;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-zinc-900 rounded-lg p-6 max-w-md w-full mx-4 border border-zinc-700">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-yellow-400 flex items-center gap-2">
            <Target className="w-5 h-5" />
            Edit Game Score
          </h3>
          <button
            onClick={onCancel}
            className="text-zinc-400 hover:text-white transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="space-y-6">
          {/* Team Score Section */}
          <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-600">
            <div className="flex items-center justify-between mb-3">
              <h4 className="text-emerald-400 font-medium">{teamName}</h4>
              {teamScore !== currentTeamScore && (
                <span className="text-xs text-yellow-400">
                  (was {currentTeamScore})
                </span>
              )}
            </div>
            
            <div className="flex items-center gap-3">
              <button
                onClick={() => adjustScore('home', -1)}
                className="p-2 bg-red-600 hover:bg-red-700 rounded transition-colors"
                disabled={teamScore <= 0}
              >
                <span className="text-white font-bold">-1</span>
              </button>
              
              <input
                type="number"
                value={teamScore}
                onChange={(e) => setTeamScore(Math.max(0, parseInt(e.target.value) || 0))}
                className="flex-1 px-3 py-2 bg-zinc-700 border border-zinc-600 rounded text-center text-xl font-bold text-white focus:border-yellow-500 focus:outline-none"
                min="0"
              />
              
              <button
                onClick={() => adjustScore('home', 1)}
                className="p-2 bg-emerald-600 hover:bg-emerald-700 rounded transition-colors"
              >
                <span className="text-white font-bold">+1</span>
              </button>
            </div>

            <div className="flex gap-2 mt-2">
              <button
                onClick={() => adjustScore('home', 2)}
                className="flex-1 px-2 py-1 bg-emerald-600 hover:bg-emerald-700 rounded text-xs transition-colors"
              >
                +2
              </button>
              <button
                onClick={() => adjustScore('home', 3)}
                className="flex-1 px-2 py-1 bg-emerald-600 hover:bg-emerald-700 rounded text-xs transition-colors"
              >
                +3
              </button>
            </div>
          </div>

          {/* Opponent Score Section */}
          <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-600">
            <div className="flex items-center justify-between mb-3">
              <h4 className="text-red-400 font-medium">{opponentName}</h4>
              {opponentScore !== currentOpponentScore && (
                <span className="text-xs text-yellow-400">
                  (was {currentOpponentScore})
                </span>
              )}
            </div>
            
            <div className="flex items-center gap-3">
              <button
                onClick={() => adjustScore('away', -1)}
                className="p-2 bg-red-600 hover:bg-red-700 rounded transition-colors"
                disabled={opponentScore <= 0}
              >
                <span className="text-white font-bold">-1</span>
              </button>
              
              <input
                type="number"
                value={opponentScore}
                onChange={(e) => setOpponentScore(Math.max(0, parseInt(e.target.value) || 0))}
                className="flex-1 px-3 py-2 bg-zinc-700 border border-zinc-600 rounded text-center text-xl font-bold text-white focus:border-yellow-500 focus:outline-none"
                min="0"
              />
              
              <button
                onClick={() => adjustScore('away', 1)}
                className="p-2 bg-emerald-600 hover:bg-emerald-700 rounded transition-colors"
              >
                <span className="text-white font-bold">+1</span>
              </button>
            </div>

            <div className="flex gap-2 mt-2">
              <button
                onClick={() => adjustScore('away', 2)}
                className="flex-1 px-2 py-1 bg-emerald-600 hover:bg-emerald-700 rounded text-xs transition-colors"
              >
                +2
              </button>
              <button
                onClick={() => adjustScore('away', 3)}
                className="flex-1 px-2 py-1 bg-emerald-600 hover:bg-emerald-700 rounded text-xs transition-colors"
              >
                +3
              </button>
            </div>
          </div>

          {/* Score Summary */}
          <div className="bg-gradient-to-r from-zinc-800 to-zinc-700 rounded-lg p-4 border border-yellow-500/20">
            <div className="text-center">
              <div className="text-2xl font-bold text-yellow-400 mb-1">
                {teamScore} - {opponentScore}
              </div>
              <div className="text-sm text-zinc-400">
                {hasChanges ? 'Modified Score' : 'Current Score'}
              </div>
            </div>
          </div>
        </div>

        <div className="flex gap-3 mt-6">
          <button
            onClick={handleReset}
            className="flex items-center gap-2 px-4 py-2 bg-zinc-700 hover:bg-zinc-600 rounded-lg transition-colors text-zinc-300"
            disabled={!hasChanges}
          >
            <RotateCcw className="w-4 h-4" />
            Reset
          </button>
          
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 bg-zinc-700 hover:bg-zinc-600 rounded-lg transition-colors text-zinc-300"
          >
            Cancel
          </button>
          
          <button
            onClick={handleSave}
            className="flex-1 px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded-lg transition-colors text-white font-medium flex items-center justify-center gap-2"
          >
            <Save className="w-4 h-4" />
            Save Changes
          </button>
        </div>
      </div>
    </div>
  );
};


=== ./src/components/GameReview/ConfirmationModal.tsx ===
import React from 'react';
import { X, AlertTriangle } from 'lucide-react';

interface ConfirmationModalProps {
  isOpen: boolean;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel: () => void;
  type?: 'danger' | 'warning' | 'info';
}

export const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isOpen,
  title,
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  onConfirm,
  onCancel,
  type = 'warning'
}) => {
  if (!isOpen) return null;

  const typeStyles = {
    danger: {
      icon: 'text-red-400',
      button: 'bg-red-600 hover:bg-red-700',
      border: 'border-red-500/20'
    },
    warning: {
      icon: 'text-yellow-400',
      button: 'bg-yellow-600 hover:bg-yellow-700',
      border: 'border-yellow-500/20'
    },
    info: {
      icon: 'text-blue-400',
      button: 'bg-blue-600 hover:bg-blue-700',
      border: 'border-blue-500/20'
    }
  };

  const currentStyles = typeStyles[type];

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className={`bg-zinc-900 rounded-lg p-6 max-w-md w-full mx-4 border border-zinc-700 ${currentStyles.border}`}>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <AlertTriangle className={`w-6 h-6 ${currentStyles.icon}`} />
            <h3 className="text-lg font-semibold text-white">
              {title}
            </h3>
          </div>
          <button
            onClick={onCancel}
            className="text-zinc-400 hover:text-white transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="mb-6">
          <p className="text-zinc-300 leading-relaxed">
            {message}
          </p>
        </div>

        <div className="flex gap-3">
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 bg-zinc-700 hover:bg-zinc-600 rounded-lg transition-colors text-zinc-300"
          >
            {cancelText}
          </button>
          
          <button
            onClick={onConfirm}
            className={`flex-1 px-4 py-2 rounded-lg transition-colors text-white font-medium ${currentStyles.button}`}
          >
            {confirmText}
          </button>
        </div>
      </div>
    </div>
  );
};


=== ./src/components/StatTracker/BoxScoreWithNavigation.tsx ===
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Award, Trash2, Edit3 } from 'lucide-react';
import type { Player } from '../../types/game.types';
import { calculateFGPercentage, calculateFTPercentage, calculateTotalRebounds } from '../../utils/statCalculations';
import { formatTime } from '../../utils/timeFormatters';

interface BoxScoreWithNavigationProps {
  players: Player[];
  teamName: string;
  onEditPlayerStats?: (player: Player) => void;
  onDeletePlayerStats?: (player: Player) => void;
}

export const BoxScoreWithNavigation: React.FC<BoxScoreWithNavigationProps> = ({ 
  players, 
  teamName, 
  onEditPlayerStats, 
  onDeletePlayerStats 
}) => {
  const navigate = useNavigate();

  const handlePlayerClick = (playerId: string | number) => {
    // Convert number ID to string if needed
    const id = typeof playerId === 'number' ? playerId.toString() : playerId;
    navigate(`/players/${id}`);
  };

  return (
    <div className="mt-6 bg-zinc-900 rounded-lg p-4 border border-zinc-700">
      <h2 className="text-xl font-semibold mb-4 flex items-center gap-2 text-yellow-400">
        <Award className="w-5 h-5" />
        {teamName} Box Score
      </h2>
      
      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b border-zinc-600">
              <th className="text-left py-2 text-zinc-300">Player</th>
              <th className="text-center px-2 text-zinc-300">MIN</th>
              <th className="text-center px-2 text-zinc-300">PTS</th>
              <th className="text-center px-2 text-zinc-300">FG</th>
              <th className="text-center px-2 text-zinc-300">FG%</th>
              <th className="text-center px-2 text-zinc-300">FT</th>
              <th className="text-center px-2 text-zinc-300">FT%</th>
              <th className="text-center px-2 text-zinc-300">REB</th>
              <th className="text-center px-2 text-zinc-300">AST</th>
              <th className="text-center px-2 text-zinc-300">STL</th>
              <th className="text-center px-2 text-zinc-300">BLK</th>
              <th className="text-center px-2 text-zinc-300">TO</th>
              <th className="text-center px-2 text-zinc-300">PF</th>
              <th className="text-center px-2 text-zinc-300">+/-</th>
              {(onEditPlayerStats || onDeletePlayerStats) && (
                <th className="text-center px-2 text-zinc-300">Actions</th>
              )}
            </tr>
          </thead>
          <tbody>
            {players.map(player => (
              <tr key={player.id} className="border-b border-zinc-700 hover:bg-zinc-800">
                <td className="py-2 text-white font-medium">
                  <span 
                    className="hover:text-yellow-400 cursor-pointer transition-colors"
                    onClick={() => handlePlayerClick(player.id)}
                  >
                    {player.name}
                  </span>
                  {player.onCourt && (
                    <span className="ml-2 text-xs bg-emerald-500 text-black px-2 py-0.5 rounded-full">On Court</span>
                  )}
                </td>
                <td className="text-center text-zinc-300">{formatTime(player.stats.timeOnCourt)}</td>
                <td className="text-center font-bold text-yellow-400">{player.stats.points}</td>
                <td className="text-center text-zinc-300">
                  {player.stats.fgMade}-{player.stats.fgAttempts}
                </td>
                <td className="text-center text-zinc-300">{calculateFGPercentage(player)}</td>
                <td className="text-center text-zinc-300">
                  {player.stats.ftMade}-{player.stats.ftAttempts}
                </td>
                <td className="text-center text-zinc-300">{calculateFTPercentage(player)}</td>
                <td className="text-center text-zinc-300">{calculateTotalRebounds(player)}</td>
                <td className="text-center text-zinc-300">{player.stats.assists}</td>
                <td className="text-center text-zinc-300">{player.stats.steals}</td>
                <td className="text-center text-zinc-300">{player.stats.blocks}</td>
                <td className="text-center text-zinc-300">{player.stats.turnovers}</td>
                <td className="text-center text-zinc-300">{player.stats.fouls}</td>
                <td className={`text-center font-medium ${player.stats.plusMinus > 0 ? 'text-emerald-400' : player.stats.plusMinus < 0 ? 'text-red-400' : 'text-zinc-300'}`}>
                  {player.stats.plusMinus > 0 ? '+' : ''}{player.stats.plusMinus}
                </td>
                {(onEditPlayerStats || onDeletePlayerStats) && (
                  <td className="text-center">
                    <div className="flex justify-center gap-1">
                      {onEditPlayerStats && (
                        <button
                          onClick={() => onEditPlayerStats(player)}
                          className="p-1.5 text-zinc-400 hover:text-yellow-400 hover:bg-zinc-700 rounded transition-colors"
                          title="Edit Stats"
                        >
                          <Edit3 className="w-3 h-3" />
                        </button>
                      )}
                      {onDeletePlayerStats && (
                        <button
                          onClick={() => onDeletePlayerStats(player)}
                          className="p-1.5 text-zinc-400 hover:text-red-400 hover:bg-zinc-700 rounded transition-colors"
                          title="Delete Stats"
                        >
                          <Trash2 className="w-3 h-3" />
                        </button>
                      )}
                    </div>
                  </td>
                )}
              </tr>
            ))}
          </tbody>
          
          {/* Team Totals */}
          <tfoot>
            <tr className="border-t-2 border-zinc-600 font-bold">
              <td className="py-2 text-yellow-400">TEAM TOTALS</td>
              <td className="text-center text-zinc-300">-</td>
              <td className="text-center text-yellow-400">
                {players.reduce((sum, p) => sum + p.stats.points, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.fgMade, 0)}-
                {players.reduce((sum, p) => sum + p.stats.fgAttempts, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {(() => {
                  const totalMade = players.reduce((sum, p) => sum + p.stats.fgMade, 0);
                  const totalAttempts = players.reduce((sum, p) => sum + p.stats.fgAttempts, 0);
                  return totalAttempts > 0 ? `${((totalMade / totalAttempts) * 100).toFixed(1)}%` : '0.0%';
                })()}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.ftMade, 0)}-
                {players.reduce((sum, p) => sum + p.stats.ftAttempts, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {(() => {
                  const totalMade = players.reduce((sum, p) => sum + p.stats.ftMade, 0);
                  const totalAttempts = players.reduce((sum, p) => sum + p.stats.ftAttempts, 0);
                  return totalAttempts > 0 ? `${((totalMade / totalAttempts) * 100).toFixed(1)}%` : '0.0%';
                })()}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.offRebounds + p.stats.defRebounds, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.assists, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.steals, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.blocks, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.turnovers, 0)}
              </td>
              <td className="text-center text-zinc-300">
                {players.reduce((sum, p) => sum + p.stats.fouls, 0)}
              </td>
              <td className="text-center text-zinc-300">-</td>
              {(onEditPlayerStats || onDeletePlayerStats) && <td></td>}
            </tr>
          </tfoot>
        </table>
      </div>
    </div>
  );
};


=== ./src/components/StatTracker/StatButtons.tsx ===
import React from 'react';
import type { StatType } from '../../types/game.types';
import Button from '../ui/Button';

interface StatButtonsProps {
  selectedPlayerName: string | null;
  onStatUpdate: (statType: StatType, value?: number) => void;
  isGameStarted?: boolean;
}

export const StatButtons: React.FC<StatButtonsProps> = ({
  selectedPlayerName,
  onStatUpdate,
  isGameStarted = false,
}) => {
  const isDisabled = !selectedPlayerName || !isGameStarted;

  return (
    <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-600">
      <h3 className="text-lg font-semibold mb-3 text-yellow-400">
        {!isGameStarted ? 'Start the game clock to record stats' : 
         selectedPlayerName ? `Recording for: ${selectedPlayerName}` : 'Select a player first'}
      </h3>
      
      {/* Scoring Buttons */}
      <div className="grid grid-cols-3 gap-2 mb-4">
        <Button variant="success" className="p-2 text-sm debug-red !bg-red-500"
          onClick={() => {
            onStatUpdate('points', 1);
            onStatUpdate('ftMade');
          }}
          disabled={isDisabled}
        >
          1 PT (FT Made)
        </Button>
        <Button variant="success" className="p-2 text-sm"
          onClick={() => {
            onStatUpdate('points', 2);
            onStatUpdate('fgMade');
          }}
          disabled={isDisabled}
        >
          2 PTS
        </Button>
        <Button variant="success" className="p-2 text-sm"
          onClick={() => {
            onStatUpdate('points', 3);
            onStatUpdate('fgMade');
          }}
          disabled={isDisabled}
        >
          3 PTS
        </Button>
      </div>
      
      {/* Miss Buttons */}
      <div className="grid grid-cols-3 gap-2 mb-4">
        <Button variant="secondary" className="p-2 text-sm"
          onClick={() => onStatUpdate('fgMissed')}
          disabled={isDisabled}
        >
          FG Miss
        </Button>
        <Button variant="secondary" className="p-2 text-sm"
          onClick={() => onStatUpdate('ftMissed')}
          disabled={isDisabled}
        >
          FT Miss
        </Button>
        <Button variant="primary" className="px-6 py-3 text-sm font-bold"
          onClick={() => onStatUpdate('turnovers')}
          disabled={isDisabled}
        >
          Turnover
        </Button>
      </div>
      
      {/* Positive Stats */}
      <div className="grid grid-cols-3 gap-2">
        <Button variant="info" className="p-2 text-sm"
          onClick={() => onStatUpdate('assists')}
          disabled={isDisabled}
        >
          Assist
        </Button>
        <Button variant="info" className="p-2 text-sm"
          onClick={() => onStatUpdate('offRebounds')}
          disabled={isDisabled}
        >
          Off Reb
        </Button>
        <Button variant="info" className="p-2 text-sm"
          onClick={() => onStatUpdate('defRebounds')}
          disabled={isDisabled}
        >
          Def Reb
        </Button>
        <Button variant="indigo" className="p-2 text-sm"
          onClick={() => onStatUpdate('steals')}
          disabled={isDisabled}
        >
          Steal
        </Button>
        <Button variant="indigo" className="p-2 text-sm"
          onClick={() => onStatUpdate('blocks')}
          disabled={isDisabled}
        >
          Block
        </Button>
        <Button variant="warning" className="p-2 text-sm"
          onClick={() => onStatUpdate('fouls')}
          disabled={isDisabled}
        >
          Foul
        </Button>
      </div>
    </div>
  );
}; 


=== ./src/components/StatTracker/index.ts ===
export { StatButtons } from './StatButtons';
export { BoxScore } from './BoxScore'; 


=== ./src/components/StatTracker/BoxScore.tsx ===
import React from 'react';
import { Award, Trash2, Edit3 } from 'lucide-react';
import type { Player } from '../../types/game.types';
import { calculateFGPercentage, calculateFTPercentage, calculateTotalRebounds } from '../../utils/statCalculations';
import { formatTime } from '../../utils/timeFormatters';

interface BoxScoreProps {
  players: Player[];
  teamName: string;
  onEditPlayerStats?: (player: Player) => void;
  onDeletePlayerStats?: (player: Player) => void;
}

export const BoxScore: React.FC<BoxScoreProps> = ({ players, teamName, onEditPlayerStats, onDeletePlayerStats }) => {
  return (
    <div className="mt-6 bg-zinc-900 rounded-lg p-4 border border-zinc-700">
      <h2 className="text-xl font-semibold mb-4 flex items-center gap-2 text-yellow-400">
        <Award className="w-5 h-5" />
        {teamName} Box Score
      </h2>
      
      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b border-zinc-600">
              <th className="text-left py-2 text-zinc-300">Player</th>
              <th className="text-center px-2 text-zinc-300">MIN</th>
              <th className="text-center px-2 text-zinc-300">PTS</th>
              <th className="text-center px-2 text-zinc-300">FG</th>
              <th className="text-center px-2 text-zinc-300">FG%</th>
              <th className="text-center px-2 text-zinc-300">FT</th>
              <th className="text-center px-2 text-zinc-300">FT%</th>
              <th className="text-center px-2 text-zinc-300">REB</th>
              <th className="text-center px-2 text-zinc-300">AST</th>
              <th className="text-center px-2 text-zinc-300">STL</th>
              <th className="text-center px-2 text-zinc-300">BLK</th>
              <th className="text-center px-2 text-zinc-300">TO</th>
              <th className="text-center px-2 text-zinc-300">PF</th>
              <th className="text-center px-2 text-zinc-300">+/-</th>
              {(onEditPlayerStats || onDeletePlayerStats) && (
                <th className="text-center px-2 text-zinc-300">Actions</th>
              )}
            </tr>
          </thead>
          <tbody>
            {players.map(player => (
              <tr key={player.id} className="border-b border-zinc-700 hover:bg-zinc-800">
                <td className="py-2 text-white font-medium">
                  {player.name}
                  {player.onCourt && (
                    <span className="ml-2 text-xs bg-emerald-600 px-1 rounded">ON</span>
                  )}
                </td>
                <td className="text-center text-zinc-300">{formatTime(player.stats.timeOnCourt)}</td>
                <td className="text-center font-semibold text-yellow-400">{player.stats.points}</td>
                <td className="text-center text-zinc-300">{player.stats.fgMade}/{player.stats.fgAttempts}</td>
                <td className="text-center text-zinc-300">{calculateFGPercentage(player.stats.fgMade, player.stats.fgAttempts)}%</td>
                <td className="text-center text-zinc-300">{player.stats.ftMade}/{player.stats.ftAttempts}</td>
                <td className="text-center text-zinc-300">{calculateFTPercentage(player.stats.ftMade, player.stats.ftAttempts)}%</td>
                <td className="text-center text-zinc-300">{calculateTotalRebounds(player.stats.offRebounds, player.stats.defRebounds)}</td>
                <td className="text-center text-zinc-300">{player.stats.assists}</td>
                <td className="text-center text-zinc-300">{player.stats.steals}</td>
                <td className="text-center text-zinc-300">{player.stats.blocks}</td>
                <td className="text-center text-zinc-300">{player.stats.turnovers}</td>
                <td className="text-center text-zinc-300">{player.stats.fouls}</td>
                <td className={`text-center font-semibold ${player.stats.plusMinus >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                  {player.stats.plusMinus > 0 ? '+' : ''}{player.stats.plusMinus}
                </td>
                {(onEditPlayerStats || onDeletePlayerStats) && (
                  <td className="text-center">
                    <div className="flex items-center justify-center gap-2">
                      {onEditPlayerStats && (
                        <button
                          onClick={() => onEditPlayerStats(player)}
                          className="p-1.5 bg-blue-600 hover:bg-blue-700 rounded transition-colors"
                          title="Edit Player Stats"
                        >
                          <Edit3 className="w-3 h-3 text-white" />
                        </button>
                      )}
                      {onDeletePlayerStats && (
                        <button
                          onClick={() => onDeletePlayerStats(player)}
                          className="p-1.5 bg-red-600 hover:bg-red-700 rounded transition-colors"
                          title="Delete Player Stats"
                        >
                          <Trash2 className="w-3 h-3 text-white" />
                        </button>
                      )}
                    </div>
                  </td>
                )}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      
      {/* Team Totals */}
      <div className="mt-4 pt-4 border-t border-zinc-700">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
          <div className="text-center">
            <div className="text-zinc-400">Total Points</div>
            <div className="text-xl font-bold text-yellow-400">
              {players.reduce((sum, p) => sum + p.stats.points, 0)}
            </div>
          </div>
          <div className="text-center">
            <div className="text-zinc-400">Total Fouls</div>
            <div className="text-xl font-bold text-amber-400">
              {players.reduce((sum, p) => sum + p.stats.fouls, 0)}
            </div>
          </div>
          <div className="text-center">
            <div className="text-zinc-400">Total Assists</div>
            <div className="text-xl font-bold text-cyan-400">
              {players.reduce((sum, p) => sum + p.stats.assists, 0)}
            </div>
          </div>
          <div className="text-center">
            <div className="text-zinc-400">Total Rebounds</div>
            <div className="text-xl font-bold text-purple-400">
              {players.reduce((sum, p) => sum + calculateTotalRebounds(p.stats.offRebounds, p.stats.defRebounds), 0)}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}; 


=== ./src/components/TeamManagement/PlayerTeamAssignmentModal.tsx ===
import React, { useState, useEffect } from 'react';
import { X, Users, Check, User } from 'lucide-react';
import type { Team, PlayerWithTeam } from '../../hooks/useTeamManagement';

interface PlayerTeamAssignmentModalProps {
  isOpen: boolean;
  onClose: () => void;
  player: PlayerWithTeam | null;
  teams: Team[];
  onAssignPlayerToTeam: (playerId: string, teamId: string) => Promise<boolean>;
  onRemovePlayerFromTeam: (playerId: string, teamId: string) => Promise<boolean>;
}

export const PlayerTeamAssignmentModal: React.FC<PlayerTeamAssignmentModalProps> = ({
  isOpen,
  onClose,
  player,
  teams,
  onAssignPlayerToTeam,
  onRemovePlayerFromTeam
}) => {
  const [selectedTeamIds, setSelectedTeamIds] = useState<Set<string>>(new Set());
  const [processing, setProcessing] = useState(false);
  const [originalTeamIds, setOriginalTeamIds] = useState<Set<string>>(new Set());
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  // Initialize selected teams when player changes
  useEffect(() => {
    if (player) {
      const playerTeamIds = new Set(player.teams.map(team => team.id));
      setSelectedTeamIds(playerTeamIds);
      setOriginalTeamIds(playerTeamIds);
      setError(null);
      setSuccess(null);
    }
  }, [player]);

  const handleTeamToggle = (teamId: string) => {
    if (processing) return;

    setSelectedTeamIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(teamId)) {
        newSet.delete(teamId);
      } else {
        newSet.add(teamId);
      }
      return newSet;
    });
  };

  const handleSave = async () => {
    if (!player || processing) return;

    setProcessing(true);
    setError(null);
    setSuccess(null);
    
    try {
      // Find teams to add and remove
      const teamsToAdd = Array.from(selectedTeamIds).filter(id => !originalTeamIds.has(id));
      const teamsToRemove = Array.from(originalTeamIds).filter(id => !selectedTeamIds.has(id));

      let hasErrors = false;

      // Process additions
      for (const teamId of teamsToAdd) {
        const success = await onAssignPlayerToTeam(player.id, teamId);
        if (!success) {
          hasErrors = true;
          const teamName = teams.find(t => t.id === teamId)?.name || 'Unknown team';
          setError(`Failed to add player to ${teamName}`);
        }
      }

      // Process removals
      for (const teamId of teamsToRemove) {
        const success = await onRemovePlayerFromTeam(player.id, teamId);
        if (!success) {
          hasErrors = true;
          const teamName = teams.find(t => t.id === teamId)?.name || 'Unknown team';
          setError(`Failed to remove player from ${teamName}`);
        }
      }

      if (!hasErrors) {
        setSuccess('Team assignments updated successfully!');
        setTimeout(() => {
          onClose();
        }, 1000);
      }
    } catch (error) {
      console.error('Error updating player team assignments:', error);
      setError('An unexpected error occurred while updating team assignments');
    } finally {
      setProcessing(false);
    }
  };

  const handleClose = () => {
    if (!processing) {
      setSelectedTeamIds(originalTeamIds);
      setError(null);
      setSuccess(null);
      onClose();
    }
  };

  const hasChanges = !Array.from(selectedTeamIds).every(id => originalTeamIds.has(id)) ||
                     !Array.from(originalTeamIds).every(id => selectedTeamIds.has(id));

  if (!isOpen || !player) return null;

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
      <div className="bg-zinc-900 rounded-xl border border-zinc-700 w-full max-w-lg shadow-2xl">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-zinc-700">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-blue-500/10 rounded-lg">
              <User className="w-5 h-5 text-blue-400" />
            </div>
            <div>
              <h2 className="text-xl font-semibold text-white">Assign Teams</h2>
              <p className="text-sm text-zinc-400">{player.name}</p>
            </div>
          </div>
          <button
            onClick={handleClose}
            disabled={processing}
            className="p-2 hover:bg-zinc-700 rounded-lg transition-colors disabled:opacity-50"
          >
            <X className="w-5 h-5 text-zinc-400" />
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          {/* Error/Success Messages */}
          {error && (
            <div className="mb-4 p-3 bg-red-500/10 border border-red-500/30 rounded-lg">
              <p className="text-sm text-red-400">{error}</p>
            </div>
          )}
          {success && (
            <div className="mb-4 p-3 bg-emerald-500/10 border border-emerald-500/30 rounded-lg">
              <p className="text-sm text-emerald-400">{success}</p>
            </div>
          )}
          
          <div className="mb-4">
            <h3 className="text-sm font-medium text-zinc-300 mb-3">
              Select teams for this player:
            </h3>
          </div>

          {/* Teams List */}
          <div className="space-y-2 max-h-80 overflow-y-auto">
            {teams.length === 0 ? (
              <div className="text-center py-8">
                <Users className="w-12 h-12 mx-auto mb-4 text-zinc-600" />
                <p className="text-zinc-400">No teams available</p>
                <p className="text-sm text-zinc-500">Create a team first to assign players</p>
              </div>
            ) : (
              teams.map(team => {
                const isSelected = selectedTeamIds.has(team.id);
                return (
                  <label
                    key={team.id}
                    className={`
                      flex items-center gap-3 p-4 rounded-lg border cursor-pointer transition-all
                      ${isSelected 
                        ? 'bg-yellow-500/10 border-yellow-500/30 hover:bg-yellow-500/15' 
                        : 'bg-zinc-800 border-zinc-700 hover:bg-zinc-700/50'
                      }
                      ${processing ? 'opacity-50 cursor-not-allowed' : ''}
                    `}
                  >
                    <input
                      type="checkbox"
                      checked={isSelected}
                      onChange={() => handleTeamToggle(team.id)}
                      disabled={processing}
                      className="sr-only"
                    />
                    
                    {/* Custom Checkbox */}
                    <div className={`
                      w-5 h-5 rounded border-2 flex items-center justify-center transition-all
                      ${isSelected 
                        ? 'bg-yellow-500 border-yellow-500' 
                        : 'bg-transparent border-zinc-600'
                      }
                    `}>
                      {isSelected && <Check className="w-3 h-3 text-black" />}
                    </div>

                    {/* Team Info */}
                    <div className="flex-1">
                      <div className="flex items-center justify-between">
                        <div>
                          <h4 className="font-medium text-white">{team.name}</h4>
                          {team.description && (
                            <p className="text-sm text-zinc-400 mt-1">{team.description}</p>
                          )}
                        </div>
                        <div className="text-right">
                          <p className="text-sm text-zinc-400">{team.playerCount || 0} players</p>
                          <div className={`
                            text-xs px-2 py-1 rounded-full mt-1
                            ${team.isActive 
                              ? 'bg-emerald-500/10 text-emerald-400' 
                              : 'bg-red-500/10 text-red-400'
                            }
                          `}>
                            {team.isActive ? 'Active' : 'Inactive'}
                          </div>
                        </div>
                      </div>
                    </div>
                  </label>
                );
              })
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex gap-3 pt-6 border-t border-zinc-700 mt-6">
            <button
              onClick={handleClose}
              disabled={processing}
              className="flex-1 px-4 py-3 bg-zinc-700 hover:bg-zinc-600 text-white rounded-lg font-medium transition-colors disabled:opacity-50"
            >
              Cancel
            </button>
            <button
              onClick={handleSave}
              disabled={!hasChanges || processing || teams.length === 0}
              className="flex-1 px-4 py-3 bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 disabled:from-zinc-600 disabled:to-zinc-700 text-black font-medium rounded-lg transition-all flex items-center justify-center gap-2"
            >
              {processing ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-black"></div>
                  Updating...
                </>
              ) : (
                <>
                  <Check className="w-4 h-4" />
                  Save Changes
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}; 


=== ./src/components/TeamManagement/TeamCard.tsx ===
import React, { useState } from 'react';
import { Users, Calendar, Edit3, Trash2, MoreVertical } from 'lucide-react';
import type { Team } from '../../hooks/useTeamManagement';
import { api } from '../../services/api';

interface TeamCardProps {
  team: Team;
  onSelect: (teamId: string) => void;
  onEdit: (team: Team) => void;
  onDelete: (teamId: string) => void;
  isSelected?: boolean;
}

export const TeamCard: React.FC<TeamCardProps> = ({
  team,
  onSelect,
  onEdit,
  onDelete,
  isSelected = false
}) => {
  const [showMenu, setShowMenu] = useState(false);
  const [logoLoading, setLogoLoading] = useState(true);
  const [logoError, setLogoError] = useState(false);

  const handleCardClick = () => {
    onSelect(team.id);
  };

  const handleEdit = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowMenu(false);
    onEdit(team);
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowMenu(false);
    if (window.confirm(`Are you sure you want to delete "${team.name}"? This will remove all player associations.`)) {
      onDelete(team.id);
    }
  };

  const handleMenuToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowMenu(!showMenu);
  };

  return (
    <div 
      onClick={handleCardClick}
      className={`
        relative bg-gradient-to-br from-zinc-800 to-zinc-900 rounded-xl p-6 cursor-pointer 
        transition-all duration-200 hover:scale-105 hover:shadow-2xl border
        ${isSelected 
          ? 'border-yellow-500 shadow-lg shadow-yellow-500/20 ring-2 ring-yellow-500/30' 
          : 'border-zinc-700 hover:border-zinc-600'
        }
      `}
    >
      {/* Menu Button */}
      <div className="absolute top-4 right-4">
        <div className="relative">
          <button
            onClick={handleMenuToggle}
            className="p-2 hover:bg-zinc-700 rounded-lg transition-colors"
          >
            <MoreVertical className="w-4 h-4 text-zinc-400" />
          </button>

          {/* Dropdown Menu */}
          {showMenu && (
            <>
              <div 
                className="fixed inset-0 z-10" 
                onClick={() => setShowMenu(false)}
              />
              <div className="absolute right-0 top-10 z-20 bg-zinc-800 border border-zinc-600 rounded-lg shadow-xl min-w-[120px]">
                <button
                  onClick={handleEdit}
                  className="w-full flex items-center gap-2 px-3 py-2 text-sm text-zinc-300 hover:bg-zinc-700 rounded-t-lg transition-colors"
                >
                  <Edit3 className="w-4 h-4" />
                  Edit
                </button>
                <button
                  onClick={handleDelete}
                  className="w-full flex items-center gap-2 px-3 py-2 text-sm text-red-400 hover:bg-zinc-700 rounded-b-lg transition-colors"
                >
                  <Trash2 className="w-4 h-4" />
                  Delete
                </button>
              </div>
            </>
          )}
        </div>
      </div>

      {/* Team Info */}
      <div className="space-y-4">
        {/* Team Logo & Name */}
        <div className="flex items-center gap-3">
          {/* Team Logo */}
          <div className="w-12 h-12 rounded-lg overflow-hidden bg-zinc-700 flex items-center justify-center flex-shrink-0 border border-zinc-600 relative">
            {api.getMockImageUrl(team.logoUrl) && !logoError ? (
              <>
                {logoLoading && (
                  <div className="w-full h-full animate-pulse bg-zinc-600/50 flex items-center justify-center absolute inset-0">
                    <Users className="w-4 h-4 text-zinc-500/50" />
                  </div>
                )}
                <img
                  src={api.getMockImageUrl(team.logoUrl)!}
                  alt={`${team.name} logo`}
                  className={`w-full h-full object-cover ${logoLoading ? 'opacity-0' : 'opacity-100'}`}
                  onLoad={() => setLogoLoading(false)}
                  onError={() => {
                    setLogoLoading(false);
                    setLogoError(true);
                  }}
                />
              </>
            ) : (
              <Users className="w-6 h-6 text-zinc-400" />
            )}
          </div>
          
          {/* Team Name & Description */}
          <div className="flex-1 min-w-0">
            <h3 className="text-xl font-bold text-white mb-1 truncate">{team.name}</h3>
            {team.description && (
              <p className="text-sm text-zinc-400 line-clamp-2">{team.description}</p>
            )}
          </div>
        </div>

        {/* Stats */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="p-2 bg-yellow-500/10 rounded-lg">
              <Users className="w-5 h-5 text-yellow-400" />
            </div>
            <div>
              <p className="text-2xl font-bold text-white">{team.playerCount || 0}</p>
              <p className="text-xs text-zinc-400">Players</p>
            </div>
          </div>

          <div className="text-right">
            <div className="text-xs text-zinc-400">
              {team.playerCount || 0} member{(team.playerCount || 0) !== 1 ? 's' : ''}
            </div>
          </div>
        </div>

        {/* Created Date */}
        {team.createdAt && (
          <div className="flex items-center gap-2 text-xs text-zinc-500">
            <Calendar className="w-3 h-3" />
            Created {new Date(team.createdAt).toLocaleDateString()}
          </div>
        )}
      </div>

      {/* Selection Indicator */}
      {isSelected && (
        <div className="absolute inset-0 rounded-xl border-2 border-yellow-500 pointer-events-none" />
      )}
    </div>
  );
}; 


=== ./src/components/TeamManagement/TeamCreationModal.tsx ===
import React, { useState } from 'react';
import { X, Users, Check, Camera, Upload } from 'lucide-react';
import { api } from '../../services/api';
import { resizeProfileImage, validateImageFile, formatFileSize, getImageDimensions } from '../../utils/imageUtils';

interface TeamCreationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreateTeam: (name: string, description?: string, logoUrl?: string) => Promise<boolean>;
  loading?: boolean;
}

export const TeamCreationModal: React.FC<TeamCreationModalProps> = ({
  isOpen,
  onClose,
  onCreateTeam,
  loading: _loading = false
}) => {
  const [teamName, setTeamName] = useState('');
  const [description, setDescription] = useState('');
  const [creating, setCreating] = useState(false);
  
  // Logo upload state
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoUrl, setLogoUrl] = useState('');
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const [imageProcessing, setImageProcessing] = useState(false);
  const [originalImageSize, setOriginalImageSize] = useState<string>('');
  const [resizedImageSize, setResizedImageSize] = useState<string>('');

  // Upload optimized logo to S3
  const uploadOptimizedLogo = async (file: File) => {
    try {
      setUploading(true);
      
      console.log(' Uploading optimized team logo');
      
      const result = await api.upload.teamLogo(file, 'temp-team-id');
      
      if (result.success && result.data?.logoUrl) {
        console.log(' Upload successful:', result.data.logoUrl);
        setLogoUrl(result.data.logoUrl);
      } else {
        throw new Error(result.error?.message || 'Upload failed');
      }
      
    } catch (error) {
      console.error(' Upload failed:', error);
      alert(`Failed to upload logo: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setUploading(false);
    }
  };

  // Custom file handler that resizes images before upload
  const handleImageFileSelect = async (file: File) => {
    try {
      setImageProcessing(true);
      
      // Validate file
      const validation = validateImageFile(file, 10); // 10MB max
      if (!validation.isValid) {
        alert(validation.error);
        return;
      }

      // Get original dimensions and size
      const originalDimensions = await getImageDimensions(file);
      const originalSize = formatFileSize(file.size);
      setOriginalImageSize(originalSize);
      
      console.log(` Original logo: ${originalDimensions.width}x${originalDimensions.height}, Size: ${originalSize}`);

      // Resize the image
      const resizedFile = await resizeProfileImage(file);
      const resizedDimensions = await getImageDimensions(resizedFile);
      const resizedSize = formatFileSize(resizedFile.size);
      setResizedImageSize(resizedSize);

      console.log(` Resized logo: ${resizedDimensions.width}x${resizedDimensions.height}, Size: ${resizedSize}`);

      // Create a preview URL for the resized image
      const previewUrl = URL.createObjectURL(resizedFile);
      setPreviewUrl(previewUrl);

      // Store the resized file
      setLogoFile(resizedFile);
      
    } catch (error) {
      console.error(' Error processing logo:', error);
      alert(`Failed to process logo: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setImageProcessing(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!teamName.trim()) return;

    // Check if user has a logo but hasn't uploaded it yet
    if (logoFile && !logoUrl) {
      alert(' Please click "Upload Logo to Cloud" before creating the team!');
      console.warn(' User has selected a logo but hasn\'t uploaded it to S3 yet');
      return;
    }

    setCreating(true);
    try {
      const success = await onCreateTeam(teamName.trim(), description.trim() || undefined, logoUrl || undefined);
      if (success) {
        resetForm();
        onClose();
      }
    } catch (error) {
      console.error('Error creating team:', error);
    } finally {
      setCreating(false);
    }
  };

  const resetForm = () => {
    setTeamName('');
    setDescription('');
    setLogoFile(null);
    setLogoUrl('');
    setPreviewUrl(null);
    setOriginalImageSize('');
    setResizedImageSize('');
  };

  const handleClose = () => {
    if (!creating) {
      resetForm();
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
      <div className="bg-zinc-900 rounded-xl border border-zinc-700 w-full max-w-md shadow-2xl">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-zinc-700">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-yellow-500/10 rounded-lg">
              <Users className="w-5 h-5 text-yellow-400" />
            </div>
            <h2 className="text-xl font-semibold text-white">Create New Team</h2>
          </div>
          <button
            onClick={handleClose}
            disabled={creating}
            className="p-2 hover:bg-zinc-700 rounded-lg transition-colors disabled:opacity-50"
          >
            <X className="w-5 h-5 text-zinc-400" />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-4">
          <div>
            <label className="block text-sm font-medium text-zinc-300 mb-2">
              Team Name *
            </label>
            <input
              type="text"
              value={teamName}
              onChange={(e) => setTeamName(e.target.value)}
              placeholder="e.g., Comets White, Lakers JV, Warriors U16"
              className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20"
              disabled={creating}
              maxLength={50}
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-zinc-300 mb-2">
              Description (optional)
            </label>
            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Brief description about this team..."
              className="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:border-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/20 resize-none"
              disabled={creating}
              rows={3}
              maxLength={200}
            />
          </div>

          {/* Team Logo Upload */}
          <div>
            <label className="block text-sm font-medium text-zinc-300 mb-3">Team Logo (optional)</label>
            
            {/* Image Preview */}
            {previewUrl && (
              <div className="mb-4 flex items-center gap-4">
                <div className="w-24 h-24 rounded-lg overflow-hidden border-2 border-zinc-600">
                  <img 
                    src={previewUrl} 
                    alt="Logo preview" 
                    className="w-full h-full object-cover"
                  />
                </div>
                <div className="text-sm">
                  <div className="text-zinc-300"> Logo optimized and ready to upload</div>
                  {originalImageSize && resizedImageSize && (
                    <div className="text-zinc-400 mt-1">
                      <div>Original: {originalImageSize}</div>
                      <div>Optimized: {resizedImageSize}</div>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* File Input */}
            <div className="bg-zinc-800 border border-zinc-600 rounded-lg p-6 border-dashed hover:border-yellow-500 transition-colors">
              <div className="text-center">
                <Camera className="w-12 h-12 mx-auto mb-4 text-zinc-400" />
                <p className="text-zinc-300 mb-4">
                  {imageProcessing ? 'Processing logo...' : 'Select a team logo'}
                </p>
                <p className="text-sm text-zinc-500 mb-4">
                  Images will be automatically optimized to 400x400px for faster loading
                </p>
                <label className="cursor-pointer">
                  <span className="bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 disabled:from-zinc-600 disabled:to-zinc-700 px-6 py-3 rounded-lg font-semibold text-black transition-all transform hover:scale-105 shadow-lg inline-flex items-center gap-2">
                    {imageProcessing ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-black"></div>
                        Processing...
                      </>
                    ) : (
                      <>
                        <Camera className="w-4 h-4" />
                        Choose Logo
                      </>
                    )}
                  </span>
                  <input
                    type="file"
                    accept="image/*"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) {
                        handleImageFileSelect(file);
                      }
                    }}
                    disabled={imageProcessing || creating}
                    className="hidden"
                  />
                </label>
              </div>
            </div>

            {/* Upload status and button */}
            {logoFile && (
              <div className="mt-4 space-y-3">
                {/* Upload Status */}
                {logoUrl ? (
                  <div className="bg-emerald-500/10 border border-emerald-500/30 rounded-lg p-3">
                    <div className="flex items-center gap-2 text-emerald-400">
                      <div className="w-2 h-2 bg-emerald-400 rounded-full"></div>
                      <span className="text-sm font-medium"> Logo uploaded to cloud successfully!</span>
                    </div>
                    <div className="text-xs text-emerald-300/70 mt-1">
                      Ready to create team
                    </div>
                  </div>
                ) : (
                  <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3">
                    <div className="flex items-center gap-2 text-yellow-400">
                      <div className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                      <span className="text-sm font-medium"> Logo processed but not uploaded yet</span>
                    </div>
                    <div className="text-xs text-yellow-300/70 mt-1">
                      Click "Upload to Cloud" below before creating team
                    </div>
                  </div>
                )}

                {/* Upload Button */}
                {!logoUrl && (
                  <button
                    type="button"
                    onClick={() => uploadOptimizedLogo(logoFile!)}
                    disabled={uploading || creating}
                    className="w-full bg-gradient-to-r from-emerald-600 to-emerald-700 hover:from-emerald-500 hover:to-emerald-600 disabled:from-zinc-600 disabled:to-zinc-700 px-6 py-3 rounded-lg font-semibold text-white transition-all flex items-center justify-center gap-2"
                  >
                    {uploading ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                        Uploading to Cloud...
                      </>
                    ) : (
                      <>
                        <Upload className="w-4 h-4" />
                        Upload Logo to Cloud
                      </>
                    )}
                  </button>
                )}
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex gap-3 pt-4">
            <button
              type="button"
              onClick={handleClose}
              disabled={creating || uploading}
              className="flex-1 px-4 py-3 bg-zinc-700 hover:bg-zinc-600 text-white rounded-lg font-medium transition-colors disabled:opacity-50"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={!teamName.trim() || creating || uploading}
              className="flex-1 px-4 py-3 bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 disabled:from-zinc-600 disabled:to-zinc-700 text-black font-medium rounded-lg transition-all flex items-center justify-center gap-2"
            >
              {creating || uploading ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-black"></div>
                  {creating ? 'Creating...' : 'Uploading...'}
                </>
              ) : (
                <>
                  <Check className="w-4 h-4" />
                  Create Team
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}; 


=== ./src/components/TeamManagement/index.ts ===
export { TeamCreationModal } from './TeamCreationModal';
export { TeamCard } from './TeamCard';
export { PlayerTeamAssignmentModal } from './PlayerTeamAssignmentModal'; 


=== ./src/vite-env.d.ts ===
/// <reference types="vite/client" />



=== ./src/hooks/useGameStats.ts ===
import { useState, useCallback, useEffect } from 'react';
import type { StatType, GameFormat } from '../types/game.types';

interface GamePlayer {
  id: string;
  name: string;
  position?: string;
  profileImageUrl?: string;
  onCourt: boolean;
  stats: {
    points: number;
    fouls: number;
    turnovers: number;
    offRebounds: number;
    defRebounds: number;
    assists: number;
    steals: number;
    blocks: number;
    fgMade: number;
    fgAttempts: number;
    ftMade: number;
    ftAttempts: number;
    plusMinus: number;
    timeOnCourt: number;
  };
  startTime: number | null;
}

interface UseGameStatsResult {
  players: GamePlayer[];
  selectedPlayerId: string | null;
  selectedPlayerName: string | null;
  currentPeriod: number;
  periodStartTime: number;
  setSelectedPlayerId: (id: string | null) => void;
  updatePlayerName: (playerId: string, newName: string) => void;
  updatePlayerStat: (playerId: string, statType: StatType, value?: number) => void;
  updatePlusMinus: (points: number, isTeamScore: boolean) => void;
  substitutePlayer: (playerInId: string, playerOutId: string, currentTime: number) => void;
  setPlayers: React.Dispatch<React.SetStateAction<GamePlayer[]>>;
  updateTimeOnCourt: (currentGameTime: number) => void;
  correctPlayerStats: (playerId: string, newStats: GamePlayer['stats'], onTeamScoreChange?: (pointsDifference: number) => void) => void;
  resetPlayerStats: (playerId: string, onTeamScoreChange?: (pointsDifference: number) => void) => void;
  recordGameEvent: (eventType: string, eventDetail: string, points?: number, playerId?: string) => void;
  endPeriod: (homeScore: number, awayScore: number, gameTime: number) => void;
  startNewPeriod: () => void;
}

interface UseGameStatsProps {
  initialPlayers: GamePlayer[];
  gameId?: string;
  gameFormat?: GameFormat;
  teamId?: string;
}

// Legacy overload for backward compatibility
export function useGameStats(initialPlayers: GamePlayer[]): UseGameStatsResult;
// New overload with additional parameters
export function useGameStats(props: UseGameStatsProps): UseGameStatsResult;
// Implementation
export function useGameStats(
  initialPlayersOrProps: GamePlayer[] | UseGameStatsProps
): UseGameStatsResult {
  // Handle both old and new calling patterns
  const isLegacyCall = Array.isArray(initialPlayersOrProps);
  const { 
    initialPlayers, 
    gameId, 
    gameFormat = 'quarters', 
    teamId
  } = isLegacyCall 
    ? { initialPlayers: initialPlayersOrProps as GamePlayer[], gameId: undefined, gameFormat: 'quarters' as GameFormat, teamId: undefined }
    : initialPlayersOrProps as UseGameStatsProps;
  const [players, setPlayers] = useState<GamePlayer[]>(initialPlayers || []);
  const [selectedPlayerId, setSelectedPlayerId] = useState<string | null>(null);
  const [lastUpdateTime, setLastUpdateTime] = useState<number>(0);
  const [currentPeriod, setCurrentPeriod] = useState<number>(1);
  const [periodStartTime, setPeriodStartTime] = useState<number>(0);

  // Update players when initialPlayers changes
  useEffect(() => {
    setPlayers(initialPlayers || []);
  }, [initialPlayers]);

  const selectedPlayerName = players.find(p => p.id === selectedPlayerId)?.name || null;

  const updateTimeOnCourt = useCallback((currentGameTime: number) => {
    const timeDelta = currentGameTime - lastUpdateTime;
    
    if (timeDelta > 0) {
      setPlayers(prevPlayers =>
        prevPlayers.map(player => {
          if (player.onCourt && player.startTime !== null) {
            return {
              ...player,
              stats: {
                ...player.stats,
                timeOnCourt: player.stats.timeOnCourt + timeDelta
              }
            };
          }
          return player;
        })
      );
    }
    
    setLastUpdateTime(currentGameTime);
  }, [lastUpdateTime]);

  const updatePlayerName = useCallback((playerId: string, newName: string) => {
    setPlayers(prevPlayers =>
      prevPlayers.map(player =>
        player.id === playerId
          ? { ...player, name: newName }
          : player
      )
    );
  }, []);

  const updatePlayerStat = useCallback((playerId: string, statType: StatType, value = 1) => {
    setPlayers(prevPlayers => 
      prevPlayers.map(player => {
        if (player.id === playerId) {
          const newStats = { ...player.stats };
          
          switch (statType) {
            case 'points':
              newStats.points += value;
              break;
            case 'fgMade':
              newStats.fgMade += 1;
              newStats.fgAttempts += 1;
              break;
            case 'fgMissed':
              newStats.fgAttempts += 1;
              break;
            case 'ftMade':
              newStats.ftMade += 1;
              newStats.ftAttempts += 1;
              break;
            case 'ftMissed':
              newStats.ftAttempts += 1;
              break;
            case 'fouls':
              newStats.fouls += 1;
              break;
            case 'turnovers':
              newStats.turnovers += 1;
              break;
            case 'offRebounds':
              newStats.offRebounds += 1;
              break;
            case 'defRebounds':
              newStats.defRebounds += 1;
              break;
            case 'assists':
              newStats.assists += 1;
              break;
            case 'steals':
              newStats.steals += 1;
              break;
            case 'blocks':
              newStats.blocks += 1;
              break;
          }
          
          return { ...player, stats: newStats };
        }
        return player;
      })
    );
  }, []);

  const updatePlusMinus = useCallback((points: number, isTeamScore: boolean) => {
    const plusMinusChange = isTeamScore ? points : -points;
    setPlayers(prevPlayers => 
      prevPlayers.map(player => {
        if (player.onCourt) {
          return {
            ...player,
            stats: {
              ...player.stats,
              plusMinus: player.stats.plusMinus + plusMinusChange
            }
          };
        }
        return player;
      })
    );
  }, []);

  const substitutePlayer = useCallback((playerInId: string, playerOutId: string, currentTime: number) => {
    // First, update all on-court players' time to ensure accurate tracking
    updateTimeOnCourt(currentTime);
    
    setPlayers(prevPlayers => {
      console.log('Before substitution:', {
        onCourtCount: prevPlayers.filter(p => p.onCourt).length,
        onCourtPlayers: prevPlayers.filter(p => p.onCourt).map(p => ({ id: p.id, name: p.name })),
        playerInId,
        playerOutId
      });
      
      const updatedPlayers = prevPlayers.map(player => {
        if (player.id === playerOutId) {
          console.log('Setting player OUT:', player.name, player.id);
          // Player going out: set onCourt to false and startTime to null
          // The time calculation was already done in updateTimeOnCourt above
          return {
            ...player,
            onCourt: false,
            startTime: null
          };
        } else if (player.id === playerInId) {
          console.log('Setting player IN:', player.name, player.id);
          // Player coming in: set onCourt to true and startTime to current time
          return {
            ...player,
            onCourt: true,
            startTime: currentTime
          };
        }
        return player;
      });
      
      console.log('After substitution:', {
        onCourtCount: updatedPlayers.filter(p => p.onCourt).length,
        onCourtPlayers: updatedPlayers.filter(p => p.onCourt).map(p => ({ id: p.id, name: p.name }))
      });
      
      return updatedPlayers;
    });
  }, [updateTimeOnCourt]);

  const correctPlayerStats = useCallback((playerId: string, newStats: GamePlayer['stats'], onTeamScoreChange?: (pointsDifference: number) => void) => {
    setPlayers(prevPlayers => {
      const targetPlayer = prevPlayers.find(p => p.id === playerId);
      if (!targetPlayer) return prevPlayers;

      const oldStats = targetPlayer.stats;
      const pointsDifference = newStats.points - oldStats.points;
      
      // If points changed, notify parent component to update team score
      if (pointsDifference !== 0 && onTeamScoreChange) {
        onTeamScoreChange(pointsDifference);
      }

      console.log('Stat correction:', {
        playerId,
        playerName: targetPlayer.name,
        oldPoints: oldStats.points,
        newPoints: newStats.points,
        pointsDifference,
        oldStats: oldStats,
        newStats: newStats
      });

      return prevPlayers.map(player => {
        if (player.id === playerId) {
          return {
            ...player,
            stats: { ...newStats }
          };
        }
        return player;
      });
    });
  }, []);

  const resetPlayerStats = useCallback((playerId: string, onTeamScoreChange?: (pointsDifference: number) => void) => {
    setPlayers(prevPlayers => {
      const targetPlayer = prevPlayers.find(p => p.id === playerId);
      if (!targetPlayer) return prevPlayers;

      const oldPoints = targetPlayer.stats.points;
      
      // Reset stats to zero but keep timeOnCourt
      const resetStats: GamePlayer['stats'] = {
        points: 0,
        fouls: 0,
        turnovers: 0,
        offRebounds: 0,
        defRebounds: 0,
        assists: 0,
        steals: 0,
        blocks: 0,
        fgMade: 0,
        fgAttempts: 0,
        ftMade: 0,
        ftAttempts: 0,
        plusMinus: 0,
        timeOnCourt: targetPlayer.stats.timeOnCourt // Keep time tracking
      };

      // If player had points, subtract them from team score
      if (oldPoints > 0 && onTeamScoreChange) {
        onTeamScoreChange(-oldPoints);
      }

      console.log('Player stats reset:', {
        playerId,
        playerName: targetPlayer.name,
        oldPoints,
        pointsRemoved: oldPoints
      });

      return prevPlayers.map(player => {
        if (player.id === playerId) {
          return {
            ...player,
            stats: resetStats
          };
        }
        return player;
      });
    });
  }, []);

  const recordGameEvent = useCallback(async (
    eventType: string, 
    eventDetail: string, 
    _points?: number, 
    playerId?: string
  ) => {
    // For now, just log the event - can be enhanced with REST API calls later
    const periodTime = (lastUpdateTime - periodStartTime) / 1000;
    
    // Format period time as MM:SS
    const minutes = Math.floor(periodTime / 60);
    const seconds = Math.floor(periodTime % 60);
    const formattedPeriodTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    console.log('Game event recorded:', {
      eventType,
      eventDetail,
      period: currentPeriod,
      periodTime: formattedPeriodTime,
      playerId,
      gameId,
      teamId
    });
  }, [gameId, teamId, currentPeriod, lastUpdateTime, periodStartTime]);

  const endPeriod = useCallback(async (homeScore: number, awayScore: number, gameTime: number) => {
    const periodDuration = gameTime - periodStartTime;

    // Record period end event
    await recordGameEvent('PERIOD_END', gameFormat === 'quarters' ? `Quarter ${currentPeriod}` : `Half ${currentPeriod}`);

    console.log('Period ended:', {
      period: currentPeriod,
      homeScore,
      awayScore,
      duration: periodDuration,
      gameId
    });
  }, [gameId, gameFormat, currentPeriod, periodStartTime, recordGameEvent]);

  const startNewPeriod = useCallback(() => {
    const newPeriod = currentPeriod + 1;
    const maxPeriods = gameFormat === 'quarters' ? 4 : 2;
    
    if (newPeriod <= maxPeriods) {
      setCurrentPeriod(newPeriod);
      setPeriodStartTime(lastUpdateTime);
      
      console.log('New period started:', {
        period: newPeriod,
        startTime: lastUpdateTime
      });
    }
  }, [currentPeriod, gameFormat, lastUpdateTime]);

  return {
    players,
    selectedPlayerId,
    selectedPlayerName,
    currentPeriod,
    periodStartTime,
    setSelectedPlayerId,
    updatePlayerName,
    updatePlayerStat,
    updatePlusMinus,
    substitutePlayer,
    setPlayers,
    updateTimeOnCourt,
    correctPlayerStats,
    resetPlayerStats,
    recordGameEvent,
    endPeriod,
    startNewPeriod,
  };
}


=== ./src/hooks/useTeamManagement.ts ===
import { useState, useEffect, useCallback } from 'react';
import { api } from '../services/api';

export interface Team {
  id: string;
  name: string;
  description?: string;
  logoUrl?: string;
  isActive: boolean;
  playerCount?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface PlayerWithTeam {
  id: string;
  name: string;
  position?: string;
  profileImageUrl?: string;
  isActive: boolean;
  teams: Team[];
  currentTeamId?: string;
}

interface UseTeamManagementResult {
  teams: Team[];
  players: PlayerWithTeam[];
  selectedTeamId: string | null;
  loading: boolean;
  
  // Team operations
  createTeam: (name: string, description?: string, logoUrl?: string) => Promise<Team | null>;
  updateTeam: (teamId: string, updates: Partial<Team>) => Promise<boolean>;
  deleteTeam: (teamId: string) => Promise<boolean>;
  setSelectedTeamId: (teamId: string | null) => void;
  
  // Player-team operations
  assignPlayerToTeam: (playerId: string, teamId: string) => Promise<boolean>;
  removePlayerFromTeam: (playerId: string, teamId: string) => Promise<boolean>;
  transferPlayer: (playerId: string, fromTeamId: string, toTeamId: string) => Promise<boolean>;
  
  // Data fetching
  fetchTeams: () => Promise<void>;
  fetchPlayersWithTeams: () => Promise<void>;
  getTeamPlayers: (teamId: string) => PlayerWithTeam[];
  getUnassignedPlayers: () => PlayerWithTeam[];
}

export const useTeamManagement = (): UseTeamManagementResult => {
  const [teams, setTeams] = useState<Team[]>([]);
  const [players, setPlayers] = useState<PlayerWithTeam[]>([]);
  const [selectedTeamId, setSelectedTeamId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch all teams
  const fetchTeams = useCallback(async () => {
    try {
      const response = await api.teams.list();
      if (response.success) {
        const teamsData = (response.data || []).map((team: any) => ({
          id: team.id,
          name: team.name,
          description: team.description || undefined,
          logoUrl: team.logoUrl || undefined,
          isActive: team.isActive || true,
          playerCount: team.players?.length || 0,
          createdAt: team.createdAt,
          updatedAt: team.updatedAt
        }));
        setTeams(teamsData);
      }
    } catch (error) {
      console.error('Error fetching teams:', error);
    }
  }, []);

  // Fetch all players with their team associations
  const fetchPlayersWithTeams = useCallback(async () => {
    try {
      setLoading(true);
      
      // Get both players and teams
      const [playersResponse, teamsResponse] = await Promise.all([
        api.players.list(),
        api.teams.list()
      ]);
      
      if (playersResponse.success && teamsResponse.success) {
        const allTeams = teamsResponse.data || [];
        const allPlayers = playersResponse.data || [];
        
        // Create a map of player ID to teams they belong to
        const playerTeamsMap = new Map<string, Team[]>();
        
        allTeams.forEach((team: any) => {
          if (team.players && Array.isArray(team.players)) {
            team.players.forEach((playerId: string) => {
              if (!playerTeamsMap.has(playerId)) {
                playerTeamsMap.set(playerId, []);
              }
              playerTeamsMap.get(playerId)!.push({
                id: team.id,
                name: team.name,
                description: team.description || undefined,
                logoUrl: team.logoUrl || undefined,
                isActive: team.isActive || true,
                playerCount: team.players?.length || 0
              });
            });
          }
        });
        
        // Map players with their teams
        const playersWithTeams: PlayerWithTeam[] = allPlayers.map((player: any) => ({
          id: player.id,
          name: player.name,
          position: player.position || undefined,
          profileImageUrl: player.profileImageUrl || undefined,
          isActive: player.isActive || true,
          teams: playerTeamsMap.get(player.id) || [],
          currentTeamId: playerTeamsMap.get(player.id)?.[0]?.id
        }));
        
        setPlayers(playersWithTeams);
      }
    } catch (error) {
      console.error('Error fetching players with teams:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  // Create a new team
  const createTeam = useCallback(async (name: string, description?: string, logoUrl?: string): Promise<Team | null> => {
    try {
      const response = await api.teams.create({
        name: name.trim(),
        description: description?.trim(),
        logoUrl: logoUrl?.trim(),
        isActive: true
      });

      if (response.success && response.data) {
        const newTeam: Team = {
          id: response.data.id,
          name: response.data.name,
          description: response.data.description || undefined,
          logoUrl: response.data.logoUrl || undefined,
          isActive: response.data.isActive || true,
          playerCount: 0
        };
        
        setTeams(prev => [...prev, newTeam]);
        return newTeam;
      }
      return null;
    } catch (error) {
      console.error('Error creating team:', error);
      return null;
    }
  }, []);

  // Update team
  const updateTeam = useCallback(async (teamId: string, updates: Partial<Team>): Promise<boolean> => {
    try {
      const response = await api.teams.update(teamId, updates);

      if (response.success) {
        setTeams(prev => prev.map(team => 
          team.id === teamId ? { ...team, ...updates } : team
        ));
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error updating team:', error);
      return false;
    }
  }, []);

  // Delete team
  const deleteTeam = useCallback(async (teamId: string): Promise<boolean> => {
    try {
      const response = await api.teams.delete(teamId);
      
      if (response.success) {
        setTeams(prev => prev.filter(team => team.id !== teamId));
        
        if (selectedTeamId === teamId) {
          setSelectedTeamId(null);
        }
        
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error deleting team:', error);
      return false;
    }
  }, [selectedTeamId]);

  // Assign player to team
  const assignPlayerToTeam = useCallback(async (playerId: string, teamId: string): Promise<boolean> => {
    try {
      console.log(`Assigning player ${playerId} to team ${teamId}`);
      const response = await api.teams.addPlayer(teamId, playerId);
      if (response.success) {
        // Refresh both teams and players to ensure UI is in sync
        await Promise.all([fetchTeams(), fetchPlayersWithTeams()]);
        return true;
      } else {
        console.error('Failed to assign player to team:', response.error);
        return false;
      }
    } catch (error) {
      console.error('Error assigning player to team:', error);
      return false;
    }
  }, [fetchTeams, fetchPlayersWithTeams]);

  // Remove player from team
  const removePlayerFromTeam = useCallback(async (playerId: string, teamId: string): Promise<boolean> => {
    try {
      console.log(`Removing player ${playerId} from team ${teamId}`);
      const response = await api.teams.removePlayer(teamId, playerId);
      if (response.success) {
        // Refresh both teams and players to ensure UI is in sync
        await Promise.all([fetchTeams(), fetchPlayersWithTeams()]);
        return true;
      } else {
        console.error('Failed to remove player from team:', response.error);
        return false;
      }
    } catch (error) {
      console.error('Error removing player from team:', error);
      return false;
    }
  }, [fetchTeams, fetchPlayersWithTeams]);

  // Transfer player between teams
  const transferPlayer = useCallback(async (playerId: string, fromTeamId: string, toTeamId: string): Promise<boolean> => {
    try {
      const removeSuccess = await removePlayerFromTeam(playerId, fromTeamId);
      if (removeSuccess) {
        return await assignPlayerToTeam(playerId, toTeamId);
      }
      return false;
    } catch (error) {
      console.error('Error transferring player:', error);
      return false;
    }
  }, [removePlayerFromTeam, assignPlayerToTeam]);

  // Get players for a specific team
  const getTeamPlayers = useCallback((teamId: string): PlayerWithTeam[] => {
    return players.filter(player => 
      player.teams.some(team => team.id === teamId)
    );
  }, [players]);

  // Get unassigned players
  const getUnassignedPlayers = useCallback((): PlayerWithTeam[] => {
    return players.filter(player => player.teams.length === 0);
  }, [players]);

  // Initial data fetch
  useEffect(() => {
    const initializeData = async () => {
      await Promise.all([fetchTeams(), fetchPlayersWithTeams()]);
    };
    initializeData();
  }, [fetchTeams, fetchPlayersWithTeams]);

  return {
    teams,
    players,
    selectedTeamId,
    loading,
    createTeam,
    updateTeam,
    deleteTeam,
    setSelectedTeamId,
    assignPlayerToTeam,
    removePlayerFromTeam,
    transferPlayer,
    fetchTeams,
    fetchPlayersWithTeams,
    getTeamPlayers,
    getUnassignedPlayers
  };
}; 


=== ./src/hooks/useGameClock.ts ===
import { useState, useEffect, useRef } from 'react';
import type { Player } from '../types/game.types';

export const useGameClock = (onPlayersUpdate: (updater: (players: Player[]) => Player[]) => void) => {
  const [gameClock, setGameClock] = useState(0);
  const [isClockRunning, setIsClockRunning] = useState(false);
  const onPlayersUpdateRef = useRef(onPlayersUpdate);

  // Keep the callback reference up to date
  useEffect(() => {
    onPlayersUpdateRef.current = onPlayersUpdate;
  }, [onPlayersUpdate]);

  useEffect(() => {
    let interval: NodeJS.Timeout | null = null;
    
    if (isClockRunning) {
      interval = setInterval(() => {
        setGameClock(prev => prev + 1);
        // Update time for players on court using stable ref
        onPlayersUpdateRef.current(prevPlayers => 
          prevPlayers.map(player => {
            if (player.onCourt) {
              return {
                ...player,
                stats: {
                  ...player.stats,
                  timeOnCourt: player.stats.timeOnCourt + 1
                }
              };
            }
            return player;
          })
        );
      }, 1000);
    }
    
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isClockRunning]); // Removed onPlayersUpdate dependency

  const toggleClock = () => {
    setIsClockRunning(!isClockRunning);
  };

  const resetClock = () => {
    setIsClockRunning(false);
    setGameClock(0);
  };

  return {
    gameClock,
    isClockRunning,
    toggleClock,
    resetClock,
  };
}; 


=== ./src/services/api.ts ===
// API Service Layer - REST API client for Basketball Review SAAS App

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

// Add mock mode flag - set to true for development without backend
const IS_MOCK_MODE = import.meta.env.VITE_MOCK_API === 'true';

// Organization management - for SAAS multi-tenancy
// In a real app, this would come from authentication/user context
let currentOrgId = localStorage.getItem('basketball-org-id') || 'default';

export const setOrganizationId = (orgId: string) => {
  currentOrgId = orgId;
  localStorage.setItem('basketball-org-id', orgId);
};

export const getOrganizationId = () => currentOrgId;

// Mock data storage system using localStorage
class MockDataStore {
  private prefix = 'basketball-mock-';

  private getKey(type: string) {
    return `${this.prefix}${currentOrgId}-${type}`;
  }

  get(type: string): any[] {
    const data = localStorage.getItem(this.getKey(type));
    return data ? JSON.parse(data) : [];
  }

  set(type: string, data: any[]): void {
    localStorage.setItem(this.getKey(type), JSON.stringify(data));
  }

  add(type: string, item: any): any {
    const items = this.get(type);
    const newItem = {
      ...item,
      id: item.id || `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: item.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      orgId: currentOrgId
    };
    items.push(newItem);
    this.set(type, items);
    return newItem;
  }

  update(type: string, id: string, updates: any): any {
    const items = this.get(type);
    const index = items.findIndex(item => item.id === id);
    if (index === -1) throw new Error(`${type} not found`);
    
    items[index] = {
      ...items[index],
      ...updates,
      updatedAt: new Date().toISOString()
    };
    this.set(type, items);
    return items[index];
  }

  delete(type: string, id: string): void {
    const items = this.get(type);
    const filtered = items.filter(item => item.id !== id);
    this.set(type, filtered);
  }

  find(type: string, id: string): any {
    const items = this.get(type);
    return items.find(item => item.id === id);
  }

  // Initialize with sample data if empty
  initializeIfEmpty() {
    if (this.get('players').length === 0) {
      // Sample players
      this.add('players', {
        id: 'player-1',
        name: 'John Smith',
        position: 'PG',
        jerseyNumber: 23,
        height: "6'2\"",
        weight: '185 lbs',
        profileImageUrl: null,
        isActive: true
      });
      this.add('players', {
        id: 'player-2',
        name: 'Mike Johnson',
        position: 'SG',
        jerseyNumber: 3,
        height: "6'4\"",
        weight: '200 lbs',
        profileImageUrl: null,
        isActive: true
      });
    }

    if (this.get('teams').length === 0) {
      // Sample teams - initialize with empty players array
      this.add('teams', {
        id: 'team-1',
        name: 'Warriors',
        description: 'Sample team',
        logoUrl: null,
        players: [],
        isActive: true
      });
    }
  }
}

const mockStore = new MockDataStore();
mockStore.initializeIfEmpty();

// Mock API request handler
const mockApiRequest = async (endpoint: string, options: RequestInit = {}) => {
  console.log(`[MOCK] ${options.method || 'GET'} ${endpoint}`);
  
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 100));

  const method = options.method || 'GET';
  const body = options.body ? JSON.parse(options.body as string) : {};

  // Parse endpoint to extract resource type and id
  const match = endpoint.match(/^\/api\/(\w+)(?:\/([^/]+))?(?:\/(\w+))?$/);
  if (!match) throw new Error(`Invalid endpoint: ${endpoint}`);

  const [, resource, id] = match;

  try {
    // Handle different resources
    switch (resource) {
      case 'players':
        if (method === 'GET' && !id) {
          return { success: true, data: mockStore.get('players') };
        }
        if (method === 'GET' && id) {
          const player = mockStore.find('players', id);
          if (!player) throw new Error('Player not found');
          return { success: true, data: player };
        }
        if (method === 'POST') {
          const newPlayer = mockStore.add('players', body);
          return { success: true, data: newPlayer };
        }
        if (method === 'PUT' && id) {
          const updated = mockStore.update('players', id, body);
          return { success: true, data: updated };
        }
        if (method === 'DELETE' && id) {
          mockStore.delete('players', id);
          return { success: true };
        }
        break;

      case 'teams':
        if (method === 'GET' && !id) {
          return { success: true, data: mockStore.get('teams') };
        }
        if (method === 'GET' && id) {
          const team = mockStore.find('teams', id);
          if (!team) throw new Error('Team not found');
          return { success: true, data: team };
        }
        if (method === 'POST') {
          const newTeam = mockStore.add('teams', body);
          return { success: true, data: newTeam };
        }
        if (method === 'PUT' && id) {
          const updated = mockStore.update('teams', id, body);
          return { success: true, data: updated };
        }
        if (method === 'DELETE' && id) {
          mockStore.delete('teams', id);
          return { success: true };
        }
        break;

      case 'games':
        if (method === 'GET' && !id) {
          return { success: true, data: mockStore.get('games') };
        }
        if (method === 'GET' && id) {
          const game = mockStore.find('games', id);
          if (!game) throw new Error('Game not found');
          return { success: true, data: game };
        }
        if (method === 'POST') {
          const newGame = mockStore.add('games', body);
          return { success: true, data: newGame };
        }
        if (method === 'PUT' && id) {
          const updated = mockStore.update('games', id, body);
          return { success: true, data: updated };
        }
        if (method === 'DELETE' && id) {
          mockStore.delete('games', id);
          return { success: true };
        }
        break;

      case 'uploads':
        if (method === 'POST') {
          // Mock file upload - return fake presigned URL
          const fileId = `file-${Date.now()}`;
          const s3Key = `${body.uploadType}/${fileId}-${body.fileName}`;
          return {
            success: true,
            data: {
              uploadUrl: `data:mock-upload-url/${s3Key}`,
              fileId,
              s3Key
            }
          };
        }
        if (method === 'PUT' && id) {
          // Mock upload completion
          return { success: true };
        }
        break;

      default:
        throw new Error(`Unknown resource: ${resource}`);
    }

    throw new Error(`Unhandled request: ${method} ${endpoint}`);
  } catch (error) {
    console.error('[MOCK] Error:', error);
    throw error;
  }
};

// Generic API request function with multi-tenant support
const apiRequest = async (endpoint: string, options: RequestInit = {}) => {
  if (IS_MOCK_MODE) {
    return mockApiRequest(endpoint, options);
  }

  const url = `${API_BASE_URL}${endpoint}`;
  
  const config: RequestInit = {
    headers: {
      'Content-Type': 'application/json',
      'X-Org-Id': currentOrgId,
      ...options.headers,
    },
    ...options,
  };

  try {
    const response = await fetch(url, config);
    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error?.message || `HTTP ${response.status}`);
    }

    return data;
  } catch (error) {
    console.error(`API request failed: ${endpoint}`, error);
    throw error;
  }
};

// Player API
export const playerApi = {
  list: async () => {
    return apiRequest('/api/players');
  },

  getById: async (id: string) => {
    return apiRequest(`/api/players/${id}`);
  },

  create: async (playerData: any) => {
    return apiRequest('/api/players', {
      method: 'POST',
      body: JSON.stringify(playerData),
    });
  },

  update: async (id: string, playerData: any) => {
    return apiRequest(`/api/players/${id}`, {
      method: 'PUT',
      body: JSON.stringify(playerData),
    });
  },

  delete: async (id: string) => {
    return apiRequest(`/api/players/${id}`, {
      method: 'DELETE',
    });
  },
};

// Team API
export const teamApi = {
  list: async () => {
    return apiRequest('/api/teams');
  },

  getById: async (id: string) => {
    return apiRequest(`/api/teams/${id}`);
  },

  create: async (teamData: any) => {
    return apiRequest('/api/teams', {
      method: 'POST',
      body: JSON.stringify(teamData),
    });
  },

  update: async (id: string, teamData: any) => {
    return apiRequest(`/api/teams/${id}`, {
      method: 'PUT',
      body: JSON.stringify(teamData),
    });
  },

  delete: async (id: string) => {
    return apiRequest(`/api/teams/${id}`, {
      method: 'DELETE',
    });
  },

  addPlayer: async (teamId: string, playerId: string) => {
    try {
      const teamResponse = await teamApi.getById(teamId);
      if (!teamResponse.success) {
        return { success: false, error: { message: 'Team not found' } };
      }
      
      const team = teamResponse.data;
      const currentPlayers = team.players || [];
      
      // Check if player is already in team
      if (currentPlayers.includes(playerId)) {
        return { success: true, data: team }; // Already in team, return success
      }
      
      const updatedPlayers = [...currentPlayers, playerId];
      return teamApi.update(teamId, { players: updatedPlayers });
    } catch (error) {
      return { 
        success: false, 
        error: { message: error instanceof Error ? error.message : 'Failed to add player to team' } 
      };
    }
  },

  removePlayer: async (teamId: string, playerId: string) => {
    try {
      const teamResponse = await teamApi.getById(teamId);
      if (!teamResponse.success) {
        return { success: false, error: { message: 'Team not found' } };
      }
      
      const team = teamResponse.data;
      const updatedPlayers = (team.players || []).filter((id: string) => id !== playerId);
      return teamApi.update(teamId, { players: updatedPlayers });
    } catch (error) {
      return { 
        success: false, 
        error: { message: error instanceof Error ? error.message : 'Failed to remove player from team' } 
      };
    }
  },
};

// Game API
export const gameApi = {
  list: async () => {
    return apiRequest('/api/games');
  },

  getById: async (id: string) => {
    return apiRequest(`/api/games/${id}`);
  },

  create: async (gameData: any) => {
    return apiRequest('/api/games', {
      method: 'POST',
      body: JSON.stringify(gameData),
    });
  },

  update: async (id: string, gameData: any) => {
    return apiRequest(`/api/games/${id}`, {
      method: 'PUT',
      body: JSON.stringify(gameData),
    });
  },

  complete: async (id: string) => {
    return apiRequest(`/api/games/${id}`, {
      method: 'PUT',
      body: JSON.stringify({ isCompleted: true }),
    });
  },

  delete: async (id: string) => {
    return apiRequest(`/api/games/${id}`, {
      method: 'DELETE',
    });
  },
};

// Upload API - now uses S3 presigned URLs
export const uploadApi = {
  getUploadUrl: async (fileName: string, fileType: string, uploadType: string = 'general') => {
    return apiRequest('/api/uploads', {
      method: 'POST',
      body: JSON.stringify({ fileName, fileType, uploadType }),
    });
  },

  uploadFile: async (file: File, uploadUrl: string) => {
    if (IS_MOCK_MODE) {
      // In mock mode, convert file to data URL and store in localStorage
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const dataUrl = reader.result as string;
          // Store the file data URL with a key derived from the upload URL
          const key = uploadUrl.replace('data:mock-upload-url/', 'mock-file-');
          localStorage.setItem(key, dataUrl);
          resolve(new Response('OK', { status: 200 }));
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    const response = await fetch(uploadUrl, {
      method: 'PUT',
      body: file,
      headers: {
        'Content-Type': file.type,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to upload file to S3');
    }

    return response;
  },

  uploadFileComplete: async (file: File, uploadType: string = 'general') => {
    const uploadResponse = await uploadApi.getUploadUrl(file.name, file.type, uploadType);
    const { uploadUrl, fileId, s3Key } = uploadResponse.data;

    await uploadApi.uploadFile(file, uploadUrl);

    await apiRequest(`/api/uploads/${fileId}`, {
      method: 'PUT',
      body: JSON.stringify({ status: 'completed' }),
    });

    if (IS_MOCK_MODE) {
      // In mock mode, return the localStorage key as URL
      const mockUrl = `mock-file-${s3Key}`;
      return { fileId, s3Key, url: mockUrl };
    }
    
    return { fileId, s3Key, url: `https://your-bucket-name.s3.amazonaws.com/${s3Key}` };
  },

  playerImage: async (file: File, playerId: string) => {
    try {
      const uploadResult = await uploadApi.uploadFileComplete(file, 'player-images');
      await playerApi.update(playerId, { profileImageUrl: uploadResult.url });
      return { 
        success: true, 
        data: { 
          imageUrl: uploadResult.url,
          fileId: uploadResult.fileId,
          s3Key: uploadResult.s3Key
        } 
      };
    } catch (error) {
      return { 
        success: false, 
        error: { 
          message: error instanceof Error ? error.message : 'Upload failed' 
        } 
      };
    }
  },

  teamLogo: async (file: File, teamId: string) => {
    try {
      const uploadResult = await uploadApi.uploadFileComplete(file, 'team-logos');
      await teamApi.update(teamId, { logoUrl: uploadResult.url });
      return { 
        success: true, 
        data: { 
          logoUrl: uploadResult.url,
          fileId: uploadResult.fileId,
          s3Key: uploadResult.s3Key
        } 
      };
    } catch (error) {
      return { 
        success: false, 
        error: { 
          message: error instanceof Error ? error.message : 'Upload failed' 
        } 
      };
    }
  },
};

// Stats API (simplified - now part of games)
export const statsApi = {
  getByGame: async (gameId: string) => {
    const game = await gameApi.getById(gameId);
    return { success: true, data: game.data.playerStats || {} };
  },

  getByPlayer: async (playerId: string, gameId?: string) => {
    if (gameId) {
      const game = await gameApi.getById(gameId);
      return { success: true, data: game.data.playerStats?.[playerId] || {} };
    }
    // For career stats, we'd need to aggregate across games
    return { success: true, data: {} };
  },

  createOrUpdate: async (statData: any) => {
    const { gameId, playerId, ...stats } = statData;
    const game = await gameApi.getById(gameId);
    const updatedStats = {
      ...game.data.playerStats,
      [playerId]: { ...game.data.playerStats?.[playerId], ...stats }
    };
    return gameApi.update(gameId, { playerStats: updatedStats });
  },

  createEvent: async (eventData: any) => {
    const { gameId, ...event } = eventData;
    const game = await gameApi.getById(gameId);
    const updatedEvents = [...(game.data.gameEvents || []), event];
    return gameApi.update(gameId, { gameEvents: updatedEvents });
  },
};

// Helper function to get mock image URLs
export const getMockImageUrl = (url: string | null | undefined): string | null => {
  if (!url || !IS_MOCK_MODE) return url || null;
  
  // If it's a mock URL, retrieve from localStorage
  if (url.startsWith('mock-file-')) {
    const dataUrl = localStorage.getItem(url);
    return dataUrl || null;
  }
  
  return url;
};

// Combined API object for easy importing
export const api = {
  players: playerApi,
  teams: teamApi,
  games: gameApi,
  stats: statsApi,
  upload: uploadApi,
  setOrganizationId,
  getOrganizationId,
  getMockImageUrl,
};


